/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// A credit spread curve matching tenors against par spread quotes
    /// </summary>
    [DataContract(Name = "CreditSpreadCurveData")]
    [JsonConverter(typeof(JsonSubtypes), "MarketDataType")]
    public partial class CreditSpreadCurveData : ComplexMarketData, IEquatable<CreditSpreadCurveData>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CreditSpreadCurveData" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CreditSpreadCurveData() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreditSpreadCurveData" /> class.
        /// </summary>
        /// <param name="baseDate">EffectiveAt date of the quoted rates (required).</param>
        /// <param name="domCcy">Domestic currency of the curve (required).</param>
        /// <param name="tenors">The tenors for which the rates apply For more information on tenors, see [knowledge base article KA-02097](https://support.lusid.com/knowledgebase/article/KA-02097) (required).</param>
        /// <param name="spreads">Par spread quotes corresponding to the tenors. (required).</param>
        /// <param name="recoveryRate">The recovery rate in default. (required).</param>
        /// <param name="referenceDate">If tenors are provided, this is the date against which the tenors will be resolved. This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date. In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid. If not provided, this defaults to the BaseDate of the curve..</param>
        /// <param name="maturities">The maturity dates for which the rates apply. Either tenors or maturities should be provided, not both..</param>
        /// <param name="lineage">Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;..</param>
        /// <param name="marketDataOptions">marketDataOptions.</param>
        /// <param name="marketDataType">The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData, ConstantVolatilitySurface (required) (default to &quot;CreditSpreadCurveData&quot;).</param>
        public CreditSpreadCurveData(DateTimeOffset baseDate = default(DateTimeOffset), string domCcy = default(string), List<string> tenors = default(List<string>), List<decimal> spreads = default(List<decimal>), decimal recoveryRate = default(decimal), DateTimeOffset? referenceDate = default(DateTimeOffset?), List<DateTimeOffset> maturities = default(List<DateTimeOffset>), string lineage = default(string), MarketDataOptions marketDataOptions = default(MarketDataOptions), MarketDataTypeEnum marketDataType = default(MarketDataTypeEnum)) : base(marketDataType)
        {
            this.BaseDate = baseDate;
            // to ensure "domCcy" is required (not null)
            if (domCcy == null)
            {
                throw new ArgumentNullException("domCcy is a required property for CreditSpreadCurveData and cannot be null");
            }
            this.DomCcy = domCcy;
            // to ensure "tenors" is required (not null)
            if (tenors == null)
            {
                throw new ArgumentNullException("tenors is a required property for CreditSpreadCurveData and cannot be null");
            }
            this.Tenors = tenors;
            // to ensure "spreads" is required (not null)
            if (spreads == null)
            {
                throw new ArgumentNullException("spreads is a required property for CreditSpreadCurveData and cannot be null");
            }
            this.Spreads = spreads;
            this.RecoveryRate = recoveryRate;
            this.ReferenceDate = referenceDate;
            this.Maturities = maturities;
            this.Lineage = lineage;
            this.MarketDataOptions = marketDataOptions;
        }

        /// <summary>
        /// EffectiveAt date of the quoted rates
        /// </summary>
        /// <value>EffectiveAt date of the quoted rates</value>
        [DataMember(Name = "baseDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset BaseDate { get; set; }

        /// <summary>
        /// Domestic currency of the curve
        /// </summary>
        /// <value>Domestic currency of the curve</value>
        [DataMember(Name = "domCcy", IsRequired = true, EmitDefaultValue = true)]
        public string DomCcy { get; set; }

        /// <summary>
        /// The tenors for which the rates apply For more information on tenors, see [knowledge base article KA-02097](https://support.lusid.com/knowledgebase/article/KA-02097)
        /// </summary>
        /// <value>The tenors for which the rates apply For more information on tenors, see [knowledge base article KA-02097](https://support.lusid.com/knowledgebase/article/KA-02097)</value>
        [DataMember(Name = "tenors", IsRequired = true, EmitDefaultValue = true)]
        public List<string> Tenors { get; set; }

        /// <summary>
        /// Par spread quotes corresponding to the tenors.
        /// </summary>
        /// <value>Par spread quotes corresponding to the tenors.</value>
        [DataMember(Name = "spreads", IsRequired = true, EmitDefaultValue = true)]
        public List<decimal> Spreads { get; set; }

        /// <summary>
        /// The recovery rate in default.
        /// </summary>
        /// <value>The recovery rate in default.</value>
        [DataMember(Name = "recoveryRate", IsRequired = true, EmitDefaultValue = true)]
        public decimal RecoveryRate { get; set; }

        /// <summary>
        /// If tenors are provided, this is the date against which the tenors will be resolved. This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date. In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid. If not provided, this defaults to the BaseDate of the curve.
        /// </summary>
        /// <value>If tenors are provided, this is the date against which the tenors will be resolved. This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date. In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid. If not provided, this defaults to the BaseDate of the curve.</value>
        [DataMember(Name = "referenceDate", EmitDefaultValue = true)]
        public DateTimeOffset? ReferenceDate { get; set; }

        /// <summary>
        /// The maturity dates for which the rates apply. Either tenors or maturities should be provided, not both.
        /// </summary>
        /// <value>The maturity dates for which the rates apply. Either tenors or maturities should be provided, not both.</value>
        [DataMember(Name = "maturities", EmitDefaultValue = true)]
        public List<DateTimeOffset> Maturities { get; set; }

        /// <summary>
        /// Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.
        /// </summary>
        /// <value>Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.</value>
        [DataMember(Name = "lineage", EmitDefaultValue = true)]
        public string Lineage { get; set; }

        /// <summary>
        /// Gets or Sets MarketDataOptions
        /// </summary>
        [DataMember(Name = "marketDataOptions", EmitDefaultValue = false)]
        public MarketDataOptions MarketDataOptions { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CreditSpreadCurveData {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  BaseDate: ").Append(BaseDate).Append("\n");
            sb.Append("  DomCcy: ").Append(DomCcy).Append("\n");
            sb.Append("  Tenors: ").Append(Tenors).Append("\n");
            sb.Append("  Spreads: ").Append(Spreads).Append("\n");
            sb.Append("  RecoveryRate: ").Append(RecoveryRate).Append("\n");
            sb.Append("  ReferenceDate: ").Append(ReferenceDate).Append("\n");
            sb.Append("  Maturities: ").Append(Maturities).Append("\n");
            sb.Append("  Lineage: ").Append(Lineage).Append("\n");
            sb.Append("  MarketDataOptions: ").Append(MarketDataOptions).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CreditSpreadCurveData);
        }

        /// <summary>
        /// Returns true if CreditSpreadCurveData instances are equal
        /// </summary>
        /// <param name="input">Instance of CreditSpreadCurveData to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CreditSpreadCurveData input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.BaseDate == input.BaseDate ||
                    (this.BaseDate != null &&
                    this.BaseDate.Equals(input.BaseDate))
                ) && base.Equals(input) && 
                (
                    this.DomCcy == input.DomCcy ||
                    (this.DomCcy != null &&
                    this.DomCcy.Equals(input.DomCcy))
                ) && base.Equals(input) && 
                (
                    this.Tenors == input.Tenors ||
                    this.Tenors != null &&
                    input.Tenors != null &&
                    this.Tenors.SequenceEqual(input.Tenors)
                ) && base.Equals(input) && 
                (
                    this.Spreads == input.Spreads ||
                    this.Spreads != null &&
                    input.Spreads != null &&
                    this.Spreads.SequenceEqual(input.Spreads)
                ) && base.Equals(input) && 
                (
                    this.RecoveryRate == input.RecoveryRate ||
                    this.RecoveryRate.Equals(input.RecoveryRate)
                ) && base.Equals(input) && 
                (
                    this.ReferenceDate == input.ReferenceDate ||
                    (this.ReferenceDate != null &&
                    this.ReferenceDate.Equals(input.ReferenceDate))
                ) && base.Equals(input) && 
                (
                    this.Maturities == input.Maturities ||
                    this.Maturities != null &&
                    input.Maturities != null &&
                    this.Maturities.SequenceEqual(input.Maturities)
                ) && base.Equals(input) && 
                (
                    this.Lineage == input.Lineage ||
                    (this.Lineage != null &&
                    this.Lineage.Equals(input.Lineage))
                ) && base.Equals(input) && 
                (
                    this.MarketDataOptions == input.MarketDataOptions ||
                    (this.MarketDataOptions != null &&
                    this.MarketDataOptions.Equals(input.MarketDataOptions))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.BaseDate != null)
                {
                    hashCode = (hashCode * 59) + this.BaseDate.GetHashCode();
                }
                if (this.DomCcy != null)
                {
                    hashCode = (hashCode * 59) + this.DomCcy.GetHashCode();
                }
                if (this.Tenors != null)
                {
                    hashCode = (hashCode * 59) + this.Tenors.GetHashCode();
                }
                if (this.Spreads != null)
                {
                    hashCode = (hashCode * 59) + this.Spreads.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RecoveryRate.GetHashCode();
                if (this.ReferenceDate != null)
                {
                    hashCode = (hashCode * 59) + this.ReferenceDate.GetHashCode();
                }
                if (this.Maturities != null)
                {
                    hashCode = (hashCode * 59) + this.Maturities.GetHashCode();
                }
                if (this.Lineage != null)
                {
                    hashCode = (hashCode * 59) + this.Lineage.GetHashCode();
                }
                if (this.MarketDataOptions != null)
                {
                    hashCode = (hashCode * 59) + this.MarketDataOptions.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // Lineage (string) maxLength
            if (this.Lineage != null && this.Lineage.Length > 1024)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Lineage, length must be less than 1024.", new [] { "Lineage" });
            }

            // Lineage (string) minLength
            if (this.Lineage != null && this.Lineage.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Lineage, length must be greater than 0.", new [] { "Lineage" });
            }

            yield break;
        }
    }
}
