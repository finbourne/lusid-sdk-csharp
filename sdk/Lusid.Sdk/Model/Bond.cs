/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// LUSID representation of a Vanilla Fixed Rate Bond.
    /// </summary>
    [DataContract(Name = "Bond")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentType")]
    public partial class Bond : LusidInstrument, IEquatable<Bond>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Bond" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Bond() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Bond" /> class.
        /// </summary>
        /// <param name="startDate">The Start date of the bond, this is normally when accrual of the first coupon begins. (required).</param>
        /// <param name="maturityDate">The Maturity date of the bond, this is when the last coupon accrual period ends.  Note that while most bonds have their last payment on this date there are some cases where the final payment is the next working day. (required).</param>
        /// <param name="domCcy">The domestic currency of the instrument. This should be the same as the Currency set on the FlowConventions. (required).</param>
        /// <param name="flowConventions">flowConventions (required).</param>
        /// <param name="principal">The face-value or principal for the bond at outset.  This might be reduced through its lifetime in the event of amortisation or similar. (required).</param>
        /// <param name="couponRate">Simple coupon rate. (required).</param>
        /// <param name="identifiers">External market codes and identifiers for the bond, e.g. ISIN..</param>
        /// <param name="exDividendDays">Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration..</param>
        /// <param name="initialCouponDate">Optional and to be DEPRECATED. If set, this is the date at which the bond begins to accrue interest. Instead, this information should be entered in the field StartDate..</param>
        /// <param name="firstCouponPayDate">The date that the first coupon of the bond is paid. This is required for bonds that have a long first coupon or short first coupon. The first coupon pay date is used  as an anchor to compare with the start date and determine if this is a long/short coupon period..</param>
        /// <param name="calculationType">The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal * Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon, StandardWithCappedAccruedInterest]..</param>
        /// <param name="roundingConventions">Rounding conventions for analytics, if any..</param>
        /// <param name="exDividendConfiguration">exDividendConfiguration.</param>
        /// <param name="originalIssuePrice">The price the bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%..</param>
        /// <param name="instrumentType">The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap, InflationLeg, FundShareClass, FlexibleLoan, UnsettledCash, Cash, MasteredInstrument (required) (default to &quot;Bond&quot;).</param>
        public Bond(DateTimeOffset startDate = default(DateTimeOffset), DateTimeOffset maturityDate = default(DateTimeOffset), string domCcy = default(string), FlowConventions flowConventions = default(FlowConventions), decimal principal = default(decimal), decimal couponRate = default(decimal), Dictionary<string, string> identifiers = default(Dictionary<string, string>), int? exDividendDays = default(int?), DateTimeOffset? initialCouponDate = default(DateTimeOffset?), DateTimeOffset? firstCouponPayDate = default(DateTimeOffset?), string calculationType = default(string), List<RoundingConvention> roundingConventions = default(List<RoundingConvention>), ExDividendConfiguration exDividendConfiguration = default(ExDividendConfiguration), decimal? originalIssuePrice = default(decimal?), InstrumentTypeEnum instrumentType = default(InstrumentTypeEnum)) : base(instrumentType)
        {
            this.StartDate = startDate;
            this.MaturityDate = maturityDate;
            // to ensure "domCcy" is required (not null)
            if (domCcy == null)
            {
                throw new ArgumentNullException("domCcy is a required property for Bond and cannot be null");
            }
            this.DomCcy = domCcy;
            // to ensure "flowConventions" is required (not null)
            if (flowConventions == null)
            {
                throw new ArgumentNullException("flowConventions is a required property for Bond and cannot be null");
            }
            this.FlowConventions = flowConventions;
            this.Principal = principal;
            this.CouponRate = couponRate;
            this.Identifiers = identifiers;
            this.ExDividendDays = exDividendDays;
            this.InitialCouponDate = initialCouponDate;
            this.FirstCouponPayDate = firstCouponPayDate;
            this.CalculationType = calculationType;
            this.RoundingConventions = roundingConventions;
            this.ExDividendConfiguration = exDividendConfiguration;
            this.OriginalIssuePrice = originalIssuePrice;
        }

        /// <summary>
        /// The Start date of the bond, this is normally when accrual of the first coupon begins.
        /// </summary>
        /// <value>The Start date of the bond, this is normally when accrual of the first coupon begins.</value>
        [DataMember(Name = "startDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// The Maturity date of the bond, this is when the last coupon accrual period ends.  Note that while most bonds have their last payment on this date there are some cases where the final payment is the next working day.
        /// </summary>
        /// <value>The Maturity date of the bond, this is when the last coupon accrual period ends.  Note that while most bonds have their last payment on this date there are some cases where the final payment is the next working day.</value>
        [DataMember(Name = "maturityDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset MaturityDate { get; set; }

        /// <summary>
        /// The domestic currency of the instrument. This should be the same as the Currency set on the FlowConventions.
        /// </summary>
        /// <value>The domestic currency of the instrument. This should be the same as the Currency set on the FlowConventions.</value>
        [DataMember(Name = "domCcy", IsRequired = true, EmitDefaultValue = true)]
        public string DomCcy { get; set; }

        /// <summary>
        /// Gets or Sets FlowConventions
        /// </summary>
        [DataMember(Name = "flowConventions", IsRequired = true, EmitDefaultValue = true)]
        public FlowConventions FlowConventions { get; set; }

        /// <summary>
        /// The face-value or principal for the bond at outset.  This might be reduced through its lifetime in the event of amortisation or similar.
        /// </summary>
        /// <value>The face-value or principal for the bond at outset.  This might be reduced through its lifetime in the event of amortisation or similar.</value>
        [DataMember(Name = "principal", IsRequired = true, EmitDefaultValue = true)]
        public decimal Principal { get; set; }

        /// <summary>
        /// Simple coupon rate.
        /// </summary>
        /// <value>Simple coupon rate.</value>
        [DataMember(Name = "couponRate", IsRequired = true, EmitDefaultValue = true)]
        public decimal CouponRate { get; set; }

        /// <summary>
        /// External market codes and identifiers for the bond, e.g. ISIN.
        /// </summary>
        /// <value>External market codes and identifiers for the bond, e.g. ISIN.</value>
        [DataMember(Name = "identifiers", EmitDefaultValue = true)]
        public Dictionary<string, string> Identifiers { get; set; }

        /// <summary>
        /// Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration.
        /// </summary>
        /// <value>Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration.</value>
        [DataMember(Name = "exDividendDays", EmitDefaultValue = true)]
        public int? ExDividendDays { get; set; }

        /// <summary>
        /// Optional and to be DEPRECATED. If set, this is the date at which the bond begins to accrue interest. Instead, this information should be entered in the field StartDate.
        /// </summary>
        /// <value>Optional and to be DEPRECATED. If set, this is the date at which the bond begins to accrue interest. Instead, this information should be entered in the field StartDate.</value>
        [DataMember(Name = "initialCouponDate", EmitDefaultValue = true)]
        public DateTimeOffset? InitialCouponDate { get; set; }

        /// <summary>
        /// The date that the first coupon of the bond is paid. This is required for bonds that have a long first coupon or short first coupon. The first coupon pay date is used  as an anchor to compare with the start date and determine if this is a long/short coupon period.
        /// </summary>
        /// <value>The date that the first coupon of the bond is paid. This is required for bonds that have a long first coupon or short first coupon. The first coupon pay date is used  as an anchor to compare with the start date and determine if this is a long/short coupon period.</value>
        [DataMember(Name = "firstCouponPayDate", EmitDefaultValue = true)]
        public DateTimeOffset? FirstCouponPayDate { get; set; }

        /// <summary>
        /// The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal * Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon, StandardWithCappedAccruedInterest].
        /// </summary>
        /// <value>The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal * Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon, StandardWithCappedAccruedInterest].</value>
        [DataMember(Name = "calculationType", EmitDefaultValue = true)]
        public string CalculationType { get; set; }

        /// <summary>
        /// Rounding conventions for analytics, if any.
        /// </summary>
        /// <value>Rounding conventions for analytics, if any.</value>
        [DataMember(Name = "roundingConventions", EmitDefaultValue = true)]
        public List<RoundingConvention> RoundingConventions { get; set; }

        /// <summary>
        /// Gets or Sets ExDividendConfiguration
        /// </summary>
        [DataMember(Name = "exDividendConfiguration", EmitDefaultValue = false)]
        public ExDividendConfiguration ExDividendConfiguration { get; set; }

        /// <summary>
        /// The price the bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%.
        /// </summary>
        /// <value>The price the bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%.</value>
        [DataMember(Name = "originalIssuePrice", EmitDefaultValue = true)]
        public decimal? OriginalIssuePrice { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Bond {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  MaturityDate: ").Append(MaturityDate).Append("\n");
            sb.Append("  DomCcy: ").Append(DomCcy).Append("\n");
            sb.Append("  FlowConventions: ").Append(FlowConventions).Append("\n");
            sb.Append("  Principal: ").Append(Principal).Append("\n");
            sb.Append("  CouponRate: ").Append(CouponRate).Append("\n");
            sb.Append("  Identifiers: ").Append(Identifiers).Append("\n");
            sb.Append("  ExDividendDays: ").Append(ExDividendDays).Append("\n");
            sb.Append("  InitialCouponDate: ").Append(InitialCouponDate).Append("\n");
            sb.Append("  FirstCouponPayDate: ").Append(FirstCouponPayDate).Append("\n");
            sb.Append("  CalculationType: ").Append(CalculationType).Append("\n");
            sb.Append("  RoundingConventions: ").Append(RoundingConventions).Append("\n");
            sb.Append("  ExDividendConfiguration: ").Append(ExDividendConfiguration).Append("\n");
            sb.Append("  OriginalIssuePrice: ").Append(OriginalIssuePrice).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Bond);
        }

        /// <summary>
        /// Returns true if Bond instances are equal
        /// </summary>
        /// <param name="input">Instance of Bond to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Bond input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && base.Equals(input) && 
                (
                    this.MaturityDate == input.MaturityDate ||
                    (this.MaturityDate != null &&
                    this.MaturityDate.Equals(input.MaturityDate))
                ) && base.Equals(input) && 
                (
                    this.DomCcy == input.DomCcy ||
                    (this.DomCcy != null &&
                    this.DomCcy.Equals(input.DomCcy))
                ) && base.Equals(input) && 
                (
                    this.FlowConventions == input.FlowConventions ||
                    (this.FlowConventions != null &&
                    this.FlowConventions.Equals(input.FlowConventions))
                ) && base.Equals(input) && 
                (
                    this.Principal == input.Principal ||
                    this.Principal.Equals(input.Principal)
                ) && base.Equals(input) && 
                (
                    this.CouponRate == input.CouponRate ||
                    this.CouponRate.Equals(input.CouponRate)
                ) && base.Equals(input) && 
                (
                    this.Identifiers == input.Identifiers ||
                    this.Identifiers != null &&
                    input.Identifiers != null &&
                    this.Identifiers.SequenceEqual(input.Identifiers)
                ) && base.Equals(input) && 
                (
                    this.ExDividendDays == input.ExDividendDays ||
                    (this.ExDividendDays != null &&
                    this.ExDividendDays.Equals(input.ExDividendDays))
                ) && base.Equals(input) && 
                (
                    this.InitialCouponDate == input.InitialCouponDate ||
                    (this.InitialCouponDate != null &&
                    this.InitialCouponDate.Equals(input.InitialCouponDate))
                ) && base.Equals(input) && 
                (
                    this.FirstCouponPayDate == input.FirstCouponPayDate ||
                    (this.FirstCouponPayDate != null &&
                    this.FirstCouponPayDate.Equals(input.FirstCouponPayDate))
                ) && base.Equals(input) && 
                (
                    this.CalculationType == input.CalculationType ||
                    (this.CalculationType != null &&
                    this.CalculationType.Equals(input.CalculationType))
                ) && base.Equals(input) && 
                (
                    this.RoundingConventions == input.RoundingConventions ||
                    this.RoundingConventions != null &&
                    input.RoundingConventions != null &&
                    this.RoundingConventions.SequenceEqual(input.RoundingConventions)
                ) && base.Equals(input) && 
                (
                    this.ExDividendConfiguration == input.ExDividendConfiguration ||
                    (this.ExDividendConfiguration != null &&
                    this.ExDividendConfiguration.Equals(input.ExDividendConfiguration))
                ) && base.Equals(input) && 
                (
                    this.OriginalIssuePrice == input.OriginalIssuePrice ||
                    (this.OriginalIssuePrice != null &&
                    this.OriginalIssuePrice.Equals(input.OriginalIssuePrice))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.StartDate != null)
                {
                    hashCode = (hashCode * 59) + this.StartDate.GetHashCode();
                }
                if (this.MaturityDate != null)
                {
                    hashCode = (hashCode * 59) + this.MaturityDate.GetHashCode();
                }
                if (this.DomCcy != null)
                {
                    hashCode = (hashCode * 59) + this.DomCcy.GetHashCode();
                }
                if (this.FlowConventions != null)
                {
                    hashCode = (hashCode * 59) + this.FlowConventions.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Principal.GetHashCode();
                hashCode = (hashCode * 59) + this.CouponRate.GetHashCode();
                if (this.Identifiers != null)
                {
                    hashCode = (hashCode * 59) + this.Identifiers.GetHashCode();
                }
                if (this.ExDividendDays != null)
                {
                    hashCode = (hashCode * 59) + this.ExDividendDays.GetHashCode();
                }
                if (this.InitialCouponDate != null)
                {
                    hashCode = (hashCode * 59) + this.InitialCouponDate.GetHashCode();
                }
                if (this.FirstCouponPayDate != null)
                {
                    hashCode = (hashCode * 59) + this.FirstCouponPayDate.GetHashCode();
                }
                if (this.CalculationType != null)
                {
                    hashCode = (hashCode * 59) + this.CalculationType.GetHashCode();
                }
                if (this.RoundingConventions != null)
                {
                    hashCode = (hashCode * 59) + this.RoundingConventions.GetHashCode();
                }
                if (this.ExDividendConfiguration != null)
                {
                    hashCode = (hashCode * 59) + this.ExDividendConfiguration.GetHashCode();
                }
                if (this.OriginalIssuePrice != null)
                {
                    hashCode = (hashCode * 59) + this.OriginalIssuePrice.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // CalculationType (string) maxLength
            if (this.CalculationType != null && this.CalculationType.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculationType, length must be less than 50.", new [] { "CalculationType" });
            }

            // CalculationType (string) minLength
            if (this.CalculationType != null && this.CalculationType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculationType, length must be greater than 0.", new [] { "CalculationType" });
            }

            yield break;
        }
    }
}
