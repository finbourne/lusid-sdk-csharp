/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// ReconcileDateTimeRuleAllOf
    /// </summary>
    [DataContract(Name = "ReconcileDateTimeRule_allOf")]
    public partial class ReconcileDateTimeRuleAllOf : IEquatable<ReconcileDateTimeRuleAllOf>, IValidatableObject
    {
        /// <summary>
        /// The available values are: Exact, AbsoluteDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ComparisonTypeEnum
        {
            /// <summary>
            /// Enum Exact for value: Exact
            /// </summary>
            [EnumMember(Value = "Exact")]
            Exact = 1,

            /// <summary>
            /// Enum AbsoluteDifference for value: AbsoluteDifference
            /// </summary>
            [EnumMember(Value = "AbsoluteDifference")]
            AbsoluteDifference = 2

        }


        /// <summary>
        /// The available values are: Exact, AbsoluteDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference</value>
        [DataMember(Name = "comparisonType", IsRequired = true, EmitDefaultValue = true)]
        public ComparisonTypeEnum ComparisonType { get; set; }
        /// <summary>
        /// The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact
        /// </summary>
        /// <value>The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RuleTypeEnum
        {
            /// <summary>
            /// Enum ReconcileNumericRule for value: ReconcileNumericRule
            /// </summary>
            [EnumMember(Value = "ReconcileNumericRule")]
            ReconcileNumericRule = 1,

            /// <summary>
            /// Enum ReconcileDateTimeRule for value: ReconcileDateTimeRule
            /// </summary>
            [EnumMember(Value = "ReconcileDateTimeRule")]
            ReconcileDateTimeRule = 2,

            /// <summary>
            /// Enum ReconcileStringRule for value: ReconcileStringRule
            /// </summary>
            [EnumMember(Value = "ReconcileStringRule")]
            ReconcileStringRule = 3,

            /// <summary>
            /// Enum ReconcileExact for value: ReconcileExact
            /// </summary>
            [EnumMember(Value = "ReconcileExact")]
            ReconcileExact = 4

        }


        /// <summary>
        /// The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact
        /// </summary>
        /// <value>The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact</value>
        [DataMember(Name = "ruleType", IsRequired = true, EmitDefaultValue = true)]
        public RuleTypeEnum RuleType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileDateTimeRuleAllOf" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReconcileDateTimeRuleAllOf() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileDateTimeRuleAllOf" /> class.
        /// </summary>
        /// <param name="comparisonType">The available values are: Exact, AbsoluteDifference (required).</param>
        /// <param name="tolerance">For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction..</param>
        /// <param name="appliesTo">appliesTo (required).</param>
        /// <param name="ruleType">The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact (required).</param>
        public ReconcileDateTimeRuleAllOf(ComparisonTypeEnum comparisonType = default(ComparisonTypeEnum), decimal tolerance = default(decimal), AggregateSpec appliesTo = default(AggregateSpec), RuleTypeEnum ruleType = default(RuleTypeEnum))
        {
            this.ComparisonType = comparisonType;
            // to ensure "appliesTo" is required (not null)
            if (appliesTo == null)
            {
                throw new ArgumentNullException("appliesTo is a required property for ReconcileDateTimeRuleAllOf and cannot be null");
            }
            this.AppliesTo = appliesTo;
            this.RuleType = ruleType;
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction.
        /// </summary>
        /// <value>For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction.</value>
        [DataMember(Name = "tolerance", EmitDefaultValue = true)]
        public decimal Tolerance { get; set; }

        /// <summary>
        /// Gets or Sets AppliesTo
        /// </summary>
        [DataMember(Name = "appliesTo", IsRequired = true, EmitDefaultValue = true)]
        public AggregateSpec AppliesTo { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReconcileDateTimeRuleAllOf {\n");
            sb.Append("  ComparisonType: ").Append(ComparisonType).Append("\n");
            sb.Append("  Tolerance: ").Append(Tolerance).Append("\n");
            sb.Append("  AppliesTo: ").Append(AppliesTo).Append("\n");
            sb.Append("  RuleType: ").Append(RuleType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReconcileDateTimeRuleAllOf);
        }

        /// <summary>
        /// Returns true if ReconcileDateTimeRuleAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of ReconcileDateTimeRuleAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReconcileDateTimeRuleAllOf input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ComparisonType == input.ComparisonType ||
                    this.ComparisonType.Equals(input.ComparisonType)
                ) && 
                (
                    this.Tolerance == input.Tolerance ||
                    this.Tolerance.Equals(input.Tolerance)
                ) && 
                (
                    this.AppliesTo == input.AppliesTo ||
                    (this.AppliesTo != null &&
                    this.AppliesTo.Equals(input.AppliesTo))
                ) && 
                (
                    this.RuleType == input.RuleType ||
                    this.RuleType.Equals(input.RuleType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.ComparisonType.GetHashCode();
                hashCode = (hashCode * 59) + this.Tolerance.GetHashCode();
                if (this.AppliesTo != null)
                {
                    hashCode = (hashCode * 59) + this.AppliesTo.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RuleType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
