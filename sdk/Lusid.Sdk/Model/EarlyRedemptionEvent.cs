/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Early redemption as a consequence of a bond being called or putted.
    /// </summary>
    [DataContract(Name = "EarlyRedemptionEvent")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentEventType")]
    public partial class EarlyRedemptionEvent : InstrumentEvent, IEquatable<EarlyRedemptionEvent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EarlyRedemptionEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EarlyRedemptionEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EarlyRedemptionEvent" /> class.
        /// </summary>
        /// <param name="effectiveDate">Date of redemption.  For internally generated European callables, this is set to the exercise date.  For internally generated American callables, this is set to the start of the exercise period..</param>
        /// <param name="currency">Currency of the redemption. (required).</param>
        /// <param name="earlyRedemptionElections">EarlyRedemptionElection for the redemption.  Used to trigger the redemption. (required).</param>
        /// <param name="redemptionPercentage">Percentage of the original issue that is redeemed, where 0.5 implies 50%.  Defaults to 1 if not set.  Must be between 0 and 1..</param>
        /// <param name="pricePerUnit">The price, or strike, that each unit is redeemed at..</param>
        /// <param name="accruedInterestPerUnit">Unpaid accrued interest also repaid as part of the redemption, per unit.  Optional field.  If left empty, will be resolved internally by calculating the accrued owed on the EffectiveDate.  This process may require additional market data..</param>
        /// <param name="instrumentEventType">The Type of Event. The available values are: TransitionEvent, InformationalEvent, OpenEvent, CloseEvent, StockSplitEvent, BondDefaultEvent, CashDividendEvent, AmortisationEvent, CashFlowEvent, ExerciseEvent, ResetEvent, TriggerEvent, RawVendorEvent, InformationalErrorEvent, BondCouponEvent, DividendReinvestmentEvent, AccumulationEvent, BondPrincipalEvent, DividendOptionEvent, MaturityEvent, FxForwardSettlementEvent, ExpiryEvent, ScripDividendEvent, StockDividendEvent, ReverseStockSplitEvent, CapitalDistributionEvent, SpinOffEvent, MergerEvent, FutureExpiryEvent, SwapCashFlowEvent, SwapPrincipalEvent, CreditPremiumCashFlowEvent, CdsCreditEvent, CdxCreditEvent, MbsCouponEvent, MbsPrincipalEvent, BonusIssueEvent, MbsPrincipalWriteOffEvent, MbsInterestDeferralEvent, MbsInterestShortfallEvent, TenderEvent, CallOnIntermediateSecuritiesEvent, IntermediateSecuritiesDistributionEvent, OptionExercisePhysicalEvent, OptionExerciseCashEvent, ProtectionPayoutCashFlowEvent, TermDepositInterestEvent, TermDepositPrincipalEvent, EarlyRedemptionEvent, FutureMarkToMarketEvent, AdjustGlobalCommitmentEvent, ContractInitialisationEvent, DrawdownEvent, LoanInterestRepaymentEvent (required) (default to &quot;EarlyRedemptionEvent&quot;).</param>
        public EarlyRedemptionEvent(DateTimeOffset? effectiveDate = default(DateTimeOffset?), string currency = default(string), List<EarlyRedemptionElection> earlyRedemptionElections = default(List<EarlyRedemptionElection>), decimal redemptionPercentage = default(decimal), decimal? pricePerUnit = default(decimal?), decimal? accruedInterestPerUnit = default(decimal?), InstrumentEventTypeEnum instrumentEventType = default(InstrumentEventTypeEnum)) : base(instrumentEventType)
        {
            // to ensure "currency" is required (not null)
            if (currency == null)
            {
                throw new ArgumentNullException("currency is a required property for EarlyRedemptionEvent and cannot be null");
            }
            this.Currency = currency;
            // to ensure "earlyRedemptionElections" is required (not null)
            if (earlyRedemptionElections == null)
            {
                throw new ArgumentNullException("earlyRedemptionElections is a required property for EarlyRedemptionEvent and cannot be null");
            }
            this.EarlyRedemptionElections = earlyRedemptionElections;
            this.EffectiveDate = effectiveDate;
            this.RedemptionPercentage = redemptionPercentage;
            this.PricePerUnit = pricePerUnit;
            this.AccruedInterestPerUnit = accruedInterestPerUnit;
        }

        /// <summary>
        /// Date of redemption.  For internally generated European callables, this is set to the exercise date.  For internally generated American callables, this is set to the start of the exercise period.
        /// </summary>
        /// <value>Date of redemption.  For internally generated European callables, this is set to the exercise date.  For internally generated American callables, this is set to the start of the exercise period.</value>
        [DataMember(Name = "effectiveDate", EmitDefaultValue = true)]
        public DateTimeOffset? EffectiveDate { get; set; }

        /// <summary>
        /// Currency of the redemption.
        /// </summary>
        /// <value>Currency of the redemption.</value>
        [DataMember(Name = "currency", IsRequired = true, EmitDefaultValue = true)]
        public string Currency { get; set; }

        /// <summary>
        /// EarlyRedemptionElection for the redemption.  Used to trigger the redemption.
        /// </summary>
        /// <value>EarlyRedemptionElection for the redemption.  Used to trigger the redemption.</value>
        [DataMember(Name = "earlyRedemptionElections", IsRequired = true, EmitDefaultValue = true)]
        public List<EarlyRedemptionElection> EarlyRedemptionElections { get; set; }

        /// <summary>
        /// Percentage of the original issue that is redeemed, where 0.5 implies 50%.  Defaults to 1 if not set.  Must be between 0 and 1.
        /// </summary>
        /// <value>Percentage of the original issue that is redeemed, where 0.5 implies 50%.  Defaults to 1 if not set.  Must be between 0 and 1.</value>
        [DataMember(Name = "redemptionPercentage", EmitDefaultValue = true)]
        public decimal RedemptionPercentage { get; set; }

        /// <summary>
        /// The price, or strike, that each unit is redeemed at.
        /// </summary>
        /// <value>The price, or strike, that each unit is redeemed at.</value>
        [DataMember(Name = "pricePerUnit", EmitDefaultValue = true)]
        public decimal? PricePerUnit { get; set; }

        /// <summary>
        /// Unpaid accrued interest also repaid as part of the redemption, per unit.  Optional field.  If left empty, will be resolved internally by calculating the accrued owed on the EffectiveDate.  This process may require additional market data.
        /// </summary>
        /// <value>Unpaid accrued interest also repaid as part of the redemption, per unit.  Optional field.  If left empty, will be resolved internally by calculating the accrued owed on the EffectiveDate.  This process may require additional market data.</value>
        [DataMember(Name = "accruedInterestPerUnit", EmitDefaultValue = true)]
        public decimal? AccruedInterestPerUnit { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EarlyRedemptionEvent {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  EffectiveDate: ").Append(EffectiveDate).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  EarlyRedemptionElections: ").Append(EarlyRedemptionElections).Append("\n");
            sb.Append("  RedemptionPercentage: ").Append(RedemptionPercentage).Append("\n");
            sb.Append("  PricePerUnit: ").Append(PricePerUnit).Append("\n");
            sb.Append("  AccruedInterestPerUnit: ").Append(AccruedInterestPerUnit).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EarlyRedemptionEvent);
        }

        /// <summary>
        /// Returns true if EarlyRedemptionEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of EarlyRedemptionEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EarlyRedemptionEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.EffectiveDate == input.EffectiveDate ||
                    (this.EffectiveDate != null &&
                    this.EffectiveDate.Equals(input.EffectiveDate))
                ) && base.Equals(input) && 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                ) && base.Equals(input) && 
                (
                    this.EarlyRedemptionElections == input.EarlyRedemptionElections ||
                    this.EarlyRedemptionElections != null &&
                    input.EarlyRedemptionElections != null &&
                    this.EarlyRedemptionElections.SequenceEqual(input.EarlyRedemptionElections)
                ) && base.Equals(input) && 
                (
                    this.RedemptionPercentage == input.RedemptionPercentage ||
                    this.RedemptionPercentage.Equals(input.RedemptionPercentage)
                ) && base.Equals(input) && 
                (
                    this.PricePerUnit == input.PricePerUnit ||
                    (this.PricePerUnit != null &&
                    this.PricePerUnit.Equals(input.PricePerUnit))
                ) && base.Equals(input) && 
                (
                    this.AccruedInterestPerUnit == input.AccruedInterestPerUnit ||
                    (this.AccruedInterestPerUnit != null &&
                    this.AccruedInterestPerUnit.Equals(input.AccruedInterestPerUnit))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.EffectiveDate != null)
                {
                    hashCode = (hashCode * 59) + this.EffectiveDate.GetHashCode();
                }
                if (this.Currency != null)
                {
                    hashCode = (hashCode * 59) + this.Currency.GetHashCode();
                }
                if (this.EarlyRedemptionElections != null)
                {
                    hashCode = (hashCode * 59) + this.EarlyRedemptionElections.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RedemptionPercentage.GetHashCode();
                if (this.PricePerUnit != null)
                {
                    hashCode = (hashCode * 59) + this.PricePerUnit.GetHashCode();
                }
                if (this.AccruedInterestPerUnit != null)
                {
                    hashCode = (hashCode * 59) + this.AccruedInterestPerUnit.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            yield break;
        }
    }
}
