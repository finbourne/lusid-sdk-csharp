/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Specification object for the parameters of an inline valuation
    /// </summary>
    [DataContract(Name = "InlineValuationRequest")]
    public partial class InlineValuationRequest : IEquatable<InlineValuationRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InlineValuationRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected InlineValuationRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InlineValuationRequest" /> class.
        /// </summary>
        /// <param name="recipeId">recipeId.</param>
        /// <param name="asAt">The asAt date to use.</param>
        /// <param name="metrics">The set of specifications to calculate or retrieve during the valuation and present in the results. For example:  AggregateSpec(&#39;Valuation/PV&#39;,&#39;Sum&#39;) for returning the PV (present value) of holdings  AggregateSpec(&#39;Holding/default/Units&#39;,&#39;Sum&#39;) for returning the units of holidays  AggregateSpec(&#39;Instrument/default/LusidInstrumentId&#39;,&#39;Value&#39;) for returning the Lusid Instrument identifier (required).</param>
        /// <param name="groupBy">The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out..</param>
        /// <param name="filters">A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value..</param>
        /// <param name="sort">A (possibly empty/null) set of specifications for how to order the results..</param>
        /// <param name="reportCurrency">Three letter ISO currency string indicating what currency to report in for ReportCurrency denominated queries.  If not present, then the currency of the relevant portfolio will be used in its place..</param>
        /// <param name="equipWithSubtotals">Flag directing the Valuation call to populate the results with subtotals of aggregates..</param>
        /// <param name="returnResultAsExpandedTypes">Financially meaningful results can be presented as either simple flat types or more complex expanded types.  For example, the present value (PV) of a holding could be represented either as a simple decimal (with currency implied)  or as a decimal-currency pair. This flag allows either representation to be returned. In the PV example,  the returned value would be the decimal-currency pair if this flag is true, or the decimal only if this flag is false..</param>
        /// <param name="valuationSchedule">valuationSchedule.</param>
        /// <param name="instruments">The set of instruments, weighted by the quantities held that are required.  It is identified by an identifier tag that can be used to identify it externally.  For a single, unique trade or transaction this can be thought of as equivalent to the transaction identifier, or  a composite of the sub-holding keys for a regular sub-holding. When there are multiple transactions sharing the same underlying instrument  such as purchase of shares on multiple dates where tax implications are different this would not be the case. (required).</param>
        /// <param name="marketDataOverrides">marketDataOverrides.</param>
        /// <param name="corporateActionSourceId">corporateActionSourceId.</param>
        public InlineValuationRequest(ResourceId recipeId = default(ResourceId), DateTimeOffset? asAt = default(DateTimeOffset?), List<AggregateSpec> metrics = default(List<AggregateSpec>), List<string> groupBy = default(List<string>), List<PropertyFilter> filters = default(List<PropertyFilter>), List<OrderBySpec> sort = default(List<OrderBySpec>), string reportCurrency = default(string), bool equipWithSubtotals = default(bool), bool returnResultAsExpandedTypes = default(bool), ValuationSchedule valuationSchedule = default(ValuationSchedule), List<WeightedInstrument> instruments = default(List<WeightedInstrument>), MarketDataOverrides marketDataOverrides = default(MarketDataOverrides), ResourceId corporateActionSourceId = default(ResourceId))
        {
            // to ensure "metrics" is required (not null)
            if (metrics == null)
            {
                throw new ArgumentNullException("metrics is a required property for InlineValuationRequest and cannot be null");
            }
            this.Metrics = metrics;
            // to ensure "instruments" is required (not null)
            if (instruments == null)
            {
                throw new ArgumentNullException("instruments is a required property for InlineValuationRequest and cannot be null");
            }
            this.Instruments = instruments;
            this.RecipeId = recipeId;
            this.AsAt = asAt;
            this.GroupBy = groupBy;
            this.Filters = filters;
            this.Sort = sort;
            this.ReportCurrency = reportCurrency;
            this.EquipWithSubtotals = equipWithSubtotals;
            this.ReturnResultAsExpandedTypes = returnResultAsExpandedTypes;
            this.ValuationSchedule = valuationSchedule;
            this.MarketDataOverrides = marketDataOverrides;
            this.CorporateActionSourceId = corporateActionSourceId;
        }

        /// <summary>
        /// Gets or Sets RecipeId
        /// </summary>
        [DataMember(Name = "recipeId", EmitDefaultValue = false)]
        public ResourceId RecipeId { get; set; }

        /// <summary>
        /// The asAt date to use
        /// </summary>
        /// <value>The asAt date to use</value>
        [DataMember(Name = "asAt", EmitDefaultValue = true)]
        public DateTimeOffset? AsAt { get; set; }

        /// <summary>
        /// The set of specifications to calculate or retrieve during the valuation and present in the results. For example:  AggregateSpec(&#39;Valuation/PV&#39;,&#39;Sum&#39;) for returning the PV (present value) of holdings  AggregateSpec(&#39;Holding/default/Units&#39;,&#39;Sum&#39;) for returning the units of holidays  AggregateSpec(&#39;Instrument/default/LusidInstrumentId&#39;,&#39;Value&#39;) for returning the Lusid Instrument identifier
        /// </summary>
        /// <value>The set of specifications to calculate or retrieve during the valuation and present in the results. For example:  AggregateSpec(&#39;Valuation/PV&#39;,&#39;Sum&#39;) for returning the PV (present value) of holdings  AggregateSpec(&#39;Holding/default/Units&#39;,&#39;Sum&#39;) for returning the units of holidays  AggregateSpec(&#39;Instrument/default/LusidInstrumentId&#39;,&#39;Value&#39;) for returning the Lusid Instrument identifier</value>
        [DataMember(Name = "metrics", IsRequired = true, EmitDefaultValue = true)]
        public List<AggregateSpec> Metrics { get; set; }

        /// <summary>
        /// The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.
        /// </summary>
        /// <value>The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.</value>
        [DataMember(Name = "groupBy", EmitDefaultValue = true)]
        public List<string> GroupBy { get; set; }

        /// <summary>
        /// A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value.
        /// </summary>
        /// <value>A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value.</value>
        [DataMember(Name = "filters", EmitDefaultValue = true)]
        public List<PropertyFilter> Filters { get; set; }

        /// <summary>
        /// A (possibly empty/null) set of specifications for how to order the results.
        /// </summary>
        /// <value>A (possibly empty/null) set of specifications for how to order the results.</value>
        [DataMember(Name = "sort", EmitDefaultValue = true)]
        public List<OrderBySpec> Sort { get; set; }

        /// <summary>
        /// Three letter ISO currency string indicating what currency to report in for ReportCurrency denominated queries.  If not present, then the currency of the relevant portfolio will be used in its place.
        /// </summary>
        /// <value>Three letter ISO currency string indicating what currency to report in for ReportCurrency denominated queries.  If not present, then the currency of the relevant portfolio will be used in its place.</value>
        [DataMember(Name = "reportCurrency", EmitDefaultValue = true)]
        public string ReportCurrency { get; set; }

        /// <summary>
        /// Flag directing the Valuation call to populate the results with subtotals of aggregates.
        /// </summary>
        /// <value>Flag directing the Valuation call to populate the results with subtotals of aggregates.</value>
        [DataMember(Name = "equipWithSubtotals", EmitDefaultValue = true)]
        public bool EquipWithSubtotals { get; set; }

        /// <summary>
        /// Financially meaningful results can be presented as either simple flat types or more complex expanded types.  For example, the present value (PV) of a holding could be represented either as a simple decimal (with currency implied)  or as a decimal-currency pair. This flag allows either representation to be returned. In the PV example,  the returned value would be the decimal-currency pair if this flag is true, or the decimal only if this flag is false.
        /// </summary>
        /// <value>Financially meaningful results can be presented as either simple flat types or more complex expanded types.  For example, the present value (PV) of a holding could be represented either as a simple decimal (with currency implied)  or as a decimal-currency pair. This flag allows either representation to be returned. In the PV example,  the returned value would be the decimal-currency pair if this flag is true, or the decimal only if this flag is false.</value>
        [DataMember(Name = "returnResultAsExpandedTypes", EmitDefaultValue = true)]
        public bool ReturnResultAsExpandedTypes { get; set; }

        /// <summary>
        /// Gets or Sets ValuationSchedule
        /// </summary>
        [DataMember(Name = "valuationSchedule", EmitDefaultValue = false)]
        public ValuationSchedule ValuationSchedule { get; set; }

        /// <summary>
        /// The set of instruments, weighted by the quantities held that are required.  It is identified by an identifier tag that can be used to identify it externally.  For a single, unique trade or transaction this can be thought of as equivalent to the transaction identifier, or  a composite of the sub-holding keys for a regular sub-holding. When there are multiple transactions sharing the same underlying instrument  such as purchase of shares on multiple dates where tax implications are different this would not be the case.
        /// </summary>
        /// <value>The set of instruments, weighted by the quantities held that are required.  It is identified by an identifier tag that can be used to identify it externally.  For a single, unique trade or transaction this can be thought of as equivalent to the transaction identifier, or  a composite of the sub-holding keys for a regular sub-holding. When there are multiple transactions sharing the same underlying instrument  such as purchase of shares on multiple dates where tax implications are different this would not be the case.</value>
        [DataMember(Name = "instruments", IsRequired = true, EmitDefaultValue = true)]
        public List<WeightedInstrument> Instruments { get; set; }

        /// <summary>
        /// Gets or Sets MarketDataOverrides
        /// </summary>
        [DataMember(Name = "marketDataOverrides", EmitDefaultValue = false)]
        public MarketDataOverrides MarketDataOverrides { get; set; }

        /// <summary>
        /// Gets or Sets CorporateActionSourceId
        /// </summary>
        [DataMember(Name = "corporateActionSourceId", EmitDefaultValue = false)]
        public ResourceId CorporateActionSourceId { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class InlineValuationRequest {\n");
            sb.Append("  RecipeId: ").Append(RecipeId).Append("\n");
            sb.Append("  AsAt: ").Append(AsAt).Append("\n");
            sb.Append("  Metrics: ").Append(Metrics).Append("\n");
            sb.Append("  GroupBy: ").Append(GroupBy).Append("\n");
            sb.Append("  Filters: ").Append(Filters).Append("\n");
            sb.Append("  Sort: ").Append(Sort).Append("\n");
            sb.Append("  ReportCurrency: ").Append(ReportCurrency).Append("\n");
            sb.Append("  EquipWithSubtotals: ").Append(EquipWithSubtotals).Append("\n");
            sb.Append("  ReturnResultAsExpandedTypes: ").Append(ReturnResultAsExpandedTypes).Append("\n");
            sb.Append("  ValuationSchedule: ").Append(ValuationSchedule).Append("\n");
            sb.Append("  Instruments: ").Append(Instruments).Append("\n");
            sb.Append("  MarketDataOverrides: ").Append(MarketDataOverrides).Append("\n");
            sb.Append("  CorporateActionSourceId: ").Append(CorporateActionSourceId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as InlineValuationRequest);
        }

        /// <summary>
        /// Returns true if InlineValuationRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of InlineValuationRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InlineValuationRequest input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.RecipeId == input.RecipeId ||
                    (this.RecipeId != null &&
                    this.RecipeId.Equals(input.RecipeId))
                ) && 
                (
                    this.AsAt == input.AsAt ||
                    (this.AsAt != null &&
                    this.AsAt.Equals(input.AsAt))
                ) && 
                (
                    this.Metrics == input.Metrics ||
                    this.Metrics != null &&
                    input.Metrics != null &&
                    this.Metrics.SequenceEqual(input.Metrics)
                ) && 
                (
                    this.GroupBy == input.GroupBy ||
                    this.GroupBy != null &&
                    input.GroupBy != null &&
                    this.GroupBy.SequenceEqual(input.GroupBy)
                ) && 
                (
                    this.Filters == input.Filters ||
                    this.Filters != null &&
                    input.Filters != null &&
                    this.Filters.SequenceEqual(input.Filters)
                ) && 
                (
                    this.Sort == input.Sort ||
                    this.Sort != null &&
                    input.Sort != null &&
                    this.Sort.SequenceEqual(input.Sort)
                ) && 
                (
                    this.ReportCurrency == input.ReportCurrency ||
                    (this.ReportCurrency != null &&
                    this.ReportCurrency.Equals(input.ReportCurrency))
                ) && 
                (
                    this.EquipWithSubtotals == input.EquipWithSubtotals ||
                    this.EquipWithSubtotals.Equals(input.EquipWithSubtotals)
                ) && 
                (
                    this.ReturnResultAsExpandedTypes == input.ReturnResultAsExpandedTypes ||
                    this.ReturnResultAsExpandedTypes.Equals(input.ReturnResultAsExpandedTypes)
                ) && 
                (
                    this.ValuationSchedule == input.ValuationSchedule ||
                    (this.ValuationSchedule != null &&
                    this.ValuationSchedule.Equals(input.ValuationSchedule))
                ) && 
                (
                    this.Instruments == input.Instruments ||
                    this.Instruments != null &&
                    input.Instruments != null &&
                    this.Instruments.SequenceEqual(input.Instruments)
                ) && 
                (
                    this.MarketDataOverrides == input.MarketDataOverrides ||
                    (this.MarketDataOverrides != null &&
                    this.MarketDataOverrides.Equals(input.MarketDataOverrides))
                ) && 
                (
                    this.CorporateActionSourceId == input.CorporateActionSourceId ||
                    (this.CorporateActionSourceId != null &&
                    this.CorporateActionSourceId.Equals(input.CorporateActionSourceId))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.RecipeId != null)
                {
                    hashCode = (hashCode * 59) + this.RecipeId.GetHashCode();
                }
                if (this.AsAt != null)
                {
                    hashCode = (hashCode * 59) + this.AsAt.GetHashCode();
                }
                if (this.Metrics != null)
                {
                    hashCode = (hashCode * 59) + this.Metrics.GetHashCode();
                }
                if (this.GroupBy != null)
                {
                    hashCode = (hashCode * 59) + this.GroupBy.GetHashCode();
                }
                if (this.Filters != null)
                {
                    hashCode = (hashCode * 59) + this.Filters.GetHashCode();
                }
                if (this.Sort != null)
                {
                    hashCode = (hashCode * 59) + this.Sort.GetHashCode();
                }
                if (this.ReportCurrency != null)
                {
                    hashCode = (hashCode * 59) + this.ReportCurrency.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.EquipWithSubtotals.GetHashCode();
                hashCode = (hashCode * 59) + this.ReturnResultAsExpandedTypes.GetHashCode();
                if (this.ValuationSchedule != null)
                {
                    hashCode = (hashCode * 59) + this.ValuationSchedule.GetHashCode();
                }
                if (this.Instruments != null)
                {
                    hashCode = (hashCode * 59) + this.Instruments.GetHashCode();
                }
                if (this.MarketDataOverrides != null)
                {
                    hashCode = (hashCode * 59) + this.MarketDataOverrides.GetHashCode();
                }
                if (this.CorporateActionSourceId != null)
                {
                    hashCode = (hashCode * 59) + this.CorporateActionSourceId.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // ReportCurrency (string) maxLength
            if (this.ReportCurrency != null && this.ReportCurrency.Length > 3)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ReportCurrency, length must be less than 3.", new [] { "ReportCurrency" });
            }

            // ReportCurrency (string) minLength
            if (this.ReportCurrency != null && this.ReportCurrency.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ReportCurrency, length must be greater than 0.", new [] { "ReportCurrency" });
            }

            yield break;
        }
    }
}
