/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// The conventions for the calculation of FX fixings, where the fixing rate is expected to be the amount of  DomCcy per unit of FgnCcy.  As an example, assume the required fixing is the WM/R 4pm mid closing rate for the USD amount per 1 EUR.  This is published with RIC EURUSDFIXM&#x3D;WM, which would be the FixingReference, with FgnCcy EUR and DomCcy USD.
    /// </summary>
    [DataContract(Name = "FxConventions")]
    public partial class FxConventions : IEquatable<FxConventions>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FxConventions" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FxConventions() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FxConventions" /> class.
        /// </summary>
        /// <param name="fgnCcy">The foreign currency (required).</param>
        /// <param name="domCcy">The domestic currency (required).</param>
        /// <param name="fixingReference">The reference name used to find the desired quote (required).</param>
        public FxConventions(string fgnCcy = default(string), string domCcy = default(string), string fixingReference = default(string))
        {
            // to ensure "fgnCcy" is required (not null)
            if (fgnCcy == null)
            {
                throw new ArgumentNullException("fgnCcy is a required property for FxConventions and cannot be null");
            }
            this.FgnCcy = fgnCcy;
            // to ensure "domCcy" is required (not null)
            if (domCcy == null)
            {
                throw new ArgumentNullException("domCcy is a required property for FxConventions and cannot be null");
            }
            this.DomCcy = domCcy;
            // to ensure "fixingReference" is required (not null)
            if (fixingReference == null)
            {
                throw new ArgumentNullException("fixingReference is a required property for FxConventions and cannot be null");
            }
            this.FixingReference = fixingReference;
        }

        /// <summary>
        /// The foreign currency
        /// </summary>
        /// <value>The foreign currency</value>
        [DataMember(Name = "fgnCcy", IsRequired = true, EmitDefaultValue = true)]
        public string FgnCcy { get; set; }

        /// <summary>
        /// The domestic currency
        /// </summary>
        /// <value>The domestic currency</value>
        [DataMember(Name = "domCcy", IsRequired = true, EmitDefaultValue = true)]
        public string DomCcy { get; set; }

        /// <summary>
        /// The reference name used to find the desired quote
        /// </summary>
        /// <value>The reference name used to find the desired quote</value>
        [DataMember(Name = "fixingReference", IsRequired = true, EmitDefaultValue = true)]
        public string FixingReference { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FxConventions {\n");
            sb.Append("  FgnCcy: ").Append(FgnCcy).Append("\n");
            sb.Append("  DomCcy: ").Append(DomCcy).Append("\n");
            sb.Append("  FixingReference: ").Append(FixingReference).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FxConventions);
        }

        /// <summary>
        /// Returns true if FxConventions instances are equal
        /// </summary>
        /// <param name="input">Instance of FxConventions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FxConventions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.FgnCcy == input.FgnCcy ||
                    (this.FgnCcy != null &&
                    this.FgnCcy.Equals(input.FgnCcy))
                ) && 
                (
                    this.DomCcy == input.DomCcy ||
                    (this.DomCcy != null &&
                    this.DomCcy.Equals(input.DomCcy))
                ) && 
                (
                    this.FixingReference == input.FixingReference ||
                    (this.FixingReference != null &&
                    this.FixingReference.Equals(input.FixingReference))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.FgnCcy != null)
                {
                    hashCode = (hashCode * 59) + this.FgnCcy.GetHashCode();
                }
                if (this.DomCcy != null)
                {
                    hashCode = (hashCode * 59) + this.DomCcy.GetHashCode();
                }
                if (this.FixingReference != null)
                {
                    hashCode = (hashCode * 59) + this.FixingReference.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // FixingReference (string) maxLength
            if (this.FixingReference != null && this.FixingReference.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FixingReference, length must be less than 64.", new [] { "FixingReference" });
            }

            // FixingReference (string) minLength
            if (this.FixingReference != null && this.FixingReference.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for FixingReference, length must be greater than 0.", new [] { "FixingReference" });
            }

            yield break;
        }
    }
}
