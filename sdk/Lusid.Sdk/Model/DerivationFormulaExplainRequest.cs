/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// DerivationFormulaExplainRequest
    /// </summary>
    [DataContract(Name = "DerivationFormulaExplainRequest")]
    public partial class DerivationFormulaExplainRequest : IEquatable<DerivationFormulaExplainRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DerivationFormulaExplainRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected DerivationFormulaExplainRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DerivationFormulaExplainRequest" /> class.
        /// </summary>
        /// <param name="entityType">The type of the entity for which the derived property or partial formula is to be resolved against. (required).</param>
        /// <param name="scope">(Optional) The scope that entity exists in. If no scope is provided, the default scope for the entity type will be used..</param>
        /// <param name="code">(Optional) The code of the entity, to be provided for entities that support scope/code retrieval. If no code or identifier is provided, the logical evaluation tree without resolved values is returned..</param>
        /// <param name="identifier">(Optional). An identifier key/value pair that uniquely identifies the entity to explain the derived property for. This can be either an instrument identifier, or an identifier property. If no code or identifier is provided, the logical evaluation tree without resolved values is returned..</param>
        /// <param name="propertyKey">(Optional) The key of the derived property to get an explanation for. This takes the format {domain}/{scope}/{code}. One of either property key or partial formula must be provided..</param>
        /// <param name="partialFormula">(Optional) A partial derivation formula to get an explanation for. Can be provided in lieu of a property key. One of either property key or partial formula must be provided..</param>
        public DerivationFormulaExplainRequest(string entityType = default(string), string scope = default(string), string code = default(string), Dictionary<string, string> identifier = default(Dictionary<string, string>), string propertyKey = default(string), string partialFormula = default(string))
        {
            // to ensure "entityType" is required (not null)
            if (entityType == null)
            {
                throw new ArgumentNullException("entityType is a required property for DerivationFormulaExplainRequest and cannot be null");
            }
            this.EntityType = entityType;
            this.Scope = scope;
            this.Code = code;
            this.Identifier = identifier;
            this.PropertyKey = propertyKey;
            this.PartialFormula = partialFormula;
        }

        /// <summary>
        /// The type of the entity for which the derived property or partial formula is to be resolved against.
        /// </summary>
        /// <value>The type of the entity for which the derived property or partial formula is to be resolved against.</value>
        [DataMember(Name = "entityType", IsRequired = true, EmitDefaultValue = true)]
        public string EntityType { get; set; }

        /// <summary>
        /// (Optional) The scope that entity exists in. If no scope is provided, the default scope for the entity type will be used.
        /// </summary>
        /// <value>(Optional) The scope that entity exists in. If no scope is provided, the default scope for the entity type will be used.</value>
        [DataMember(Name = "scope", EmitDefaultValue = true)]
        public string Scope { get; set; }

        /// <summary>
        /// (Optional) The code of the entity, to be provided for entities that support scope/code retrieval. If no code or identifier is provided, the logical evaluation tree without resolved values is returned.
        /// </summary>
        /// <value>(Optional) The code of the entity, to be provided for entities that support scope/code retrieval. If no code or identifier is provided, the logical evaluation tree without resolved values is returned.</value>
        [DataMember(Name = "code", EmitDefaultValue = true)]
        public string Code { get; set; }

        /// <summary>
        /// (Optional). An identifier key/value pair that uniquely identifies the entity to explain the derived property for. This can be either an instrument identifier, or an identifier property. If no code or identifier is provided, the logical evaluation tree without resolved values is returned.
        /// </summary>
        /// <value>(Optional). An identifier key/value pair that uniquely identifies the entity to explain the derived property for. This can be either an instrument identifier, or an identifier property. If no code or identifier is provided, the logical evaluation tree without resolved values is returned.</value>
        [DataMember(Name = "identifier", EmitDefaultValue = true)]
        public Dictionary<string, string> Identifier { get; set; }

        /// <summary>
        /// (Optional) The key of the derived property to get an explanation for. This takes the format {domain}/{scope}/{code}. One of either property key or partial formula must be provided.
        /// </summary>
        /// <value>(Optional) The key of the derived property to get an explanation for. This takes the format {domain}/{scope}/{code}. One of either property key or partial formula must be provided.</value>
        [DataMember(Name = "propertyKey", EmitDefaultValue = true)]
        public string PropertyKey { get; set; }

        /// <summary>
        /// (Optional) A partial derivation formula to get an explanation for. Can be provided in lieu of a property key. One of either property key or partial formula must be provided.
        /// </summary>
        /// <value>(Optional) A partial derivation formula to get an explanation for. Can be provided in lieu of a property key. One of either property key or partial formula must be provided.</value>
        [DataMember(Name = "partialFormula", EmitDefaultValue = true)]
        public string PartialFormula { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DerivationFormulaExplainRequest {\n");
            sb.Append("  EntityType: ").Append(EntityType).Append("\n");
            sb.Append("  Scope: ").Append(Scope).Append("\n");
            sb.Append("  Code: ").Append(Code).Append("\n");
            sb.Append("  Identifier: ").Append(Identifier).Append("\n");
            sb.Append("  PropertyKey: ").Append(PropertyKey).Append("\n");
            sb.Append("  PartialFormula: ").Append(PartialFormula).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DerivationFormulaExplainRequest);
        }

        /// <summary>
        /// Returns true if DerivationFormulaExplainRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of DerivationFormulaExplainRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DerivationFormulaExplainRequest input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.EntityType == input.EntityType ||
                    (this.EntityType != null &&
                    this.EntityType.Equals(input.EntityType))
                ) && 
                (
                    this.Scope == input.Scope ||
                    (this.Scope != null &&
                    this.Scope.Equals(input.Scope))
                ) && 
                (
                    this.Code == input.Code ||
                    (this.Code != null &&
                    this.Code.Equals(input.Code))
                ) && 
                (
                    this.Identifier == input.Identifier ||
                    this.Identifier != null &&
                    input.Identifier != null &&
                    this.Identifier.SequenceEqual(input.Identifier)
                ) && 
                (
                    this.PropertyKey == input.PropertyKey ||
                    (this.PropertyKey != null &&
                    this.PropertyKey.Equals(input.PropertyKey))
                ) && 
                (
                    this.PartialFormula == input.PartialFormula ||
                    (this.PartialFormula != null &&
                    this.PartialFormula.Equals(input.PartialFormula))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EntityType != null)
                {
                    hashCode = (hashCode * 59) + this.EntityType.GetHashCode();
                }
                if (this.Scope != null)
                {
                    hashCode = (hashCode * 59) + this.Scope.GetHashCode();
                }
                if (this.Code != null)
                {
                    hashCode = (hashCode * 59) + this.Code.GetHashCode();
                }
                if (this.Identifier != null)
                {
                    hashCode = (hashCode * 59) + this.Identifier.GetHashCode();
                }
                if (this.PropertyKey != null)
                {
                    hashCode = (hashCode * 59) + this.PropertyKey.GetHashCode();
                }
                if (this.PartialFormula != null)
                {
                    hashCode = (hashCode * 59) + this.PartialFormula.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // EntityType (string) maxLength
            if (this.EntityType != null && this.EntityType.Length > 128)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EntityType, length must be less than 128.", new [] { "EntityType" });
            }

            // EntityType (string) minLength
            if (this.EntityType != null && this.EntityType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for EntityType, length must be greater than 0.", new [] { "EntityType" });
            }

            // Scope (string) maxLength
            if (this.Scope != null && this.Scope.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Scope, length must be less than 64.", new [] { "Scope" });
            }

            // Scope (string) minLength
            if (this.Scope != null && this.Scope.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Scope, length must be greater than 1.", new [] { "Scope" });
            }

            // Scope (string) pattern
            Regex regexScope = new Regex(@"^[a-zA-Z0-9\-_]+$", RegexOptions.CultureInvariant);
            if (false == regexScope.Match(this.Scope).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Scope, must match a pattern of " + regexScope, new [] { "Scope" });
            }

            // Code (string) maxLength
            if (this.Code != null && this.Code.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Code, length must be less than 64.", new [] { "Code" });
            }

            // Code (string) minLength
            if (this.Code != null && this.Code.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Code, length must be greater than 1.", new [] { "Code" });
            }

            // Code (string) pattern
            Regex regexCode = new Regex(@"^[a-zA-Z0-9\-_]+$", RegexOptions.CultureInvariant);
            if (false == regexCode.Match(this.Code).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Code, must match a pattern of " + regexCode, new [] { "Code" });
            }

            // PartialFormula (string) maxLength
            if (this.PartialFormula != null && this.PartialFormula.Length > 8000)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PartialFormula, length must be less than 8000.", new [] { "PartialFormula" });
            }

            // PartialFormula (string) minLength
            if (this.PartialFormula != null && this.PartialFormula.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PartialFormula, length must be greater than 0.", new [] { "PartialFormula" });
            }

            yield break;
        }
    }
}
