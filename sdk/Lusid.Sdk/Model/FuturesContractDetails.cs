/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Most, if not all, information about contracts is standardized. See, e.g. https://www.cmegroup.com/ for  common codes and similar data. This appears to be in common use by well known market information providers, e.g. Bloomberg and Refinitiv.
    /// </summary>
    [DataContract(Name = "FuturesContractDetails")]
    public partial class FuturesContractDetails : IEquatable<FuturesContractDetails>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesContractDetails" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FuturesContractDetails() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesContractDetails" /> class.
        /// </summary>
        /// <param name="domCcy">Currency in which the contract is paid. (required).</param>
        /// <param name="fgnCcy">Currency of the underlying, for use with FX Futures.</param>
        /// <param name="assetClass">The asset class of the underlying. Optional and will default to Unknown if not set.    Supported string (enumeration) values are: [InterestRates, FX, Inflation, Equities, Credit, Commodities, Money]..</param>
        /// <param name="contractCode">The contract code used by the exchange, e.g. “CL” for Crude Oil, “ES” for E-mini SP 500, “FGBL” for Bund Futures, etc. (required).</param>
        /// <param name="contractMonth">Which month does the contract trade for.    Supported string (enumeration) values are: [F, G, H, J, K, M, N, Q, U, V, X, Z]..</param>
        /// <param name="contractSize">Size of a single contract. (required).</param>
        /// <param name="convention">If appropriate, the day count convention method used in pricing (rates futures).  For more information on day counts, see [knowledge base article KA-01798](https://support.lusid.com/knowledgebase/article/KA-01798)                Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM]..</param>
        /// <param name="country">Country (code) for the exchange..</param>
        /// <param name="description">Description of contract..</param>
        /// <param name="exchangeCode">Exchange code for contract. This can be any string to uniquely identify the exchange (e.g. Exchange Name, MIC, BBG code). (required).</param>
        /// <param name="exchangeName">Exchange name (for when code is not automatically recognised)..</param>
        /// <param name="tickerStep">Minimal step size change in ticker..</param>
        /// <param name="unitValue">The value in the currency of a 1 unit change in the contract price..</param>
        /// <param name="calendars">Holiday calendars that apply to yield-to-price conversions (i.e. for BRL futures)..</param>
        /// <param name="deliveryType">Delivery type to be used on settling the contract.  Optional: Defaults to DeliveryType.Physical if not provided.    Supported string (enumeration) values are: [Cash, Physical]..</param>
        public FuturesContractDetails(string domCcy = default(string), string fgnCcy = default(string), string assetClass = default(string), string contractCode = default(string), string contractMonth = default(string), decimal contractSize = default(decimal), string convention = default(string), string country = default(string), string description = default(string), string exchangeCode = default(string), string exchangeName = default(string), decimal tickerStep = default(decimal), decimal unitValue = default(decimal), List<string> calendars = default(List<string>), string deliveryType = default(string))
        {
            // to ensure "domCcy" is required (not null)
            if (domCcy == null)
            {
                throw new ArgumentNullException("domCcy is a required property for FuturesContractDetails and cannot be null");
            }
            this.DomCcy = domCcy;
            // to ensure "contractCode" is required (not null)
            if (contractCode == null)
            {
                throw new ArgumentNullException("contractCode is a required property for FuturesContractDetails and cannot be null");
            }
            this.ContractCode = contractCode;
            this.ContractSize = contractSize;
            // to ensure "exchangeCode" is required (not null)
            if (exchangeCode == null)
            {
                throw new ArgumentNullException("exchangeCode is a required property for FuturesContractDetails and cannot be null");
            }
            this.ExchangeCode = exchangeCode;
            this.FgnCcy = fgnCcy;
            this.AssetClass = assetClass;
            this.ContractMonth = contractMonth;
            this.Convention = convention;
            this.Country = country;
            this.Description = description;
            this.ExchangeName = exchangeName;
            this.TickerStep = tickerStep;
            this.UnitValue = unitValue;
            this.Calendars = calendars;
            this.DeliveryType = deliveryType;
        }

        /// <summary>
        /// Currency in which the contract is paid.
        /// </summary>
        /// <value>Currency in which the contract is paid.</value>
        [DataMember(Name = "domCcy", IsRequired = true, EmitDefaultValue = true)]
        public string DomCcy { get; set; }

        /// <summary>
        /// Currency of the underlying, for use with FX Futures
        /// </summary>
        /// <value>Currency of the underlying, for use with FX Futures</value>
        [DataMember(Name = "fgnCcy", EmitDefaultValue = true)]
        public string FgnCcy { get; set; }

        /// <summary>
        /// The asset class of the underlying. Optional and will default to Unknown if not set.    Supported string (enumeration) values are: [InterestRates, FX, Inflation, Equities, Credit, Commodities, Money].
        /// </summary>
        /// <value>The asset class of the underlying. Optional and will default to Unknown if not set.    Supported string (enumeration) values are: [InterestRates, FX, Inflation, Equities, Credit, Commodities, Money].</value>
        [DataMember(Name = "assetClass", EmitDefaultValue = true)]
        public string AssetClass { get; set; }

        /// <summary>
        /// The contract code used by the exchange, e.g. “CL” for Crude Oil, “ES” for E-mini SP 500, “FGBL” for Bund Futures, etc.
        /// </summary>
        /// <value>The contract code used by the exchange, e.g. “CL” for Crude Oil, “ES” for E-mini SP 500, “FGBL” for Bund Futures, etc.</value>
        [DataMember(Name = "contractCode", IsRequired = true, EmitDefaultValue = true)]
        public string ContractCode { get; set; }

        /// <summary>
        /// Which month does the contract trade for.    Supported string (enumeration) values are: [F, G, H, J, K, M, N, Q, U, V, X, Z].
        /// </summary>
        /// <value>Which month does the contract trade for.    Supported string (enumeration) values are: [F, G, H, J, K, M, N, Q, U, V, X, Z].</value>
        [DataMember(Name = "contractMonth", EmitDefaultValue = true)]
        public string ContractMonth { get; set; }

        /// <summary>
        /// Size of a single contract.
        /// </summary>
        /// <value>Size of a single contract.</value>
        [DataMember(Name = "contractSize", IsRequired = true, EmitDefaultValue = true)]
        public decimal ContractSize { get; set; }

        /// <summary>
        /// If appropriate, the day count convention method used in pricing (rates futures).  For more information on day counts, see [knowledge base article KA-01798](https://support.lusid.com/knowledgebase/article/KA-01798)                Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].
        /// </summary>
        /// <value>If appropriate, the day count convention method used in pricing (rates futures).  For more information on day counts, see [knowledge base article KA-01798](https://support.lusid.com/knowledgebase/article/KA-01798)                Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].</value>
        [DataMember(Name = "convention", EmitDefaultValue = true)]
        public string Convention { get; set; }

        /// <summary>
        /// Country (code) for the exchange.
        /// </summary>
        /// <value>Country (code) for the exchange.</value>
        [DataMember(Name = "country", EmitDefaultValue = true)]
        public string Country { get; set; }

        /// <summary>
        /// Description of contract.
        /// </summary>
        /// <value>Description of contract.</value>
        [DataMember(Name = "description", EmitDefaultValue = true)]
        public string Description { get; set; }

        /// <summary>
        /// Exchange code for contract. This can be any string to uniquely identify the exchange (e.g. Exchange Name, MIC, BBG code).
        /// </summary>
        /// <value>Exchange code for contract. This can be any string to uniquely identify the exchange (e.g. Exchange Name, MIC, BBG code).</value>
        [DataMember(Name = "exchangeCode", IsRequired = true, EmitDefaultValue = true)]
        public string ExchangeCode { get; set; }

        /// <summary>
        /// Exchange name (for when code is not automatically recognised).
        /// </summary>
        /// <value>Exchange name (for when code is not automatically recognised).</value>
        [DataMember(Name = "exchangeName", EmitDefaultValue = true)]
        public string ExchangeName { get; set; }

        /// <summary>
        /// Minimal step size change in ticker.
        /// </summary>
        /// <value>Minimal step size change in ticker.</value>
        [DataMember(Name = "tickerStep", EmitDefaultValue = true)]
        public decimal TickerStep { get; set; }

        /// <summary>
        /// The value in the currency of a 1 unit change in the contract price.
        /// </summary>
        /// <value>The value in the currency of a 1 unit change in the contract price.</value>
        [DataMember(Name = "unitValue", EmitDefaultValue = true)]
        public decimal UnitValue { get; set; }

        /// <summary>
        /// Holiday calendars that apply to yield-to-price conversions (i.e. for BRL futures).
        /// </summary>
        /// <value>Holiday calendars that apply to yield-to-price conversions (i.e. for BRL futures).</value>
        [DataMember(Name = "calendars", EmitDefaultValue = true)]
        public List<string> Calendars { get; set; }

        /// <summary>
        /// Delivery type to be used on settling the contract.  Optional: Defaults to DeliveryType.Physical if not provided.    Supported string (enumeration) values are: [Cash, Physical].
        /// </summary>
        /// <value>Delivery type to be used on settling the contract.  Optional: Defaults to DeliveryType.Physical if not provided.    Supported string (enumeration) values are: [Cash, Physical].</value>
        [DataMember(Name = "deliveryType", EmitDefaultValue = true)]
        public string DeliveryType { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FuturesContractDetails {\n");
            sb.Append("  DomCcy: ").Append(DomCcy).Append("\n");
            sb.Append("  FgnCcy: ").Append(FgnCcy).Append("\n");
            sb.Append("  AssetClass: ").Append(AssetClass).Append("\n");
            sb.Append("  ContractCode: ").Append(ContractCode).Append("\n");
            sb.Append("  ContractMonth: ").Append(ContractMonth).Append("\n");
            sb.Append("  ContractSize: ").Append(ContractSize).Append("\n");
            sb.Append("  Convention: ").Append(Convention).Append("\n");
            sb.Append("  Country: ").Append(Country).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ExchangeCode: ").Append(ExchangeCode).Append("\n");
            sb.Append("  ExchangeName: ").Append(ExchangeName).Append("\n");
            sb.Append("  TickerStep: ").Append(TickerStep).Append("\n");
            sb.Append("  UnitValue: ").Append(UnitValue).Append("\n");
            sb.Append("  Calendars: ").Append(Calendars).Append("\n");
            sb.Append("  DeliveryType: ").Append(DeliveryType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FuturesContractDetails);
        }

        /// <summary>
        /// Returns true if FuturesContractDetails instances are equal
        /// </summary>
        /// <param name="input">Instance of FuturesContractDetails to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FuturesContractDetails input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.DomCcy == input.DomCcy ||
                    (this.DomCcy != null &&
                    this.DomCcy.Equals(input.DomCcy))
                ) && 
                (
                    this.FgnCcy == input.FgnCcy ||
                    (this.FgnCcy != null &&
                    this.FgnCcy.Equals(input.FgnCcy))
                ) && 
                (
                    this.AssetClass == input.AssetClass ||
                    (this.AssetClass != null &&
                    this.AssetClass.Equals(input.AssetClass))
                ) && 
                (
                    this.ContractCode == input.ContractCode ||
                    (this.ContractCode != null &&
                    this.ContractCode.Equals(input.ContractCode))
                ) && 
                (
                    this.ContractMonth == input.ContractMonth ||
                    (this.ContractMonth != null &&
                    this.ContractMonth.Equals(input.ContractMonth))
                ) && 
                (
                    this.ContractSize == input.ContractSize ||
                    this.ContractSize.Equals(input.ContractSize)
                ) && 
                (
                    this.Convention == input.Convention ||
                    (this.Convention != null &&
                    this.Convention.Equals(input.Convention))
                ) && 
                (
                    this.Country == input.Country ||
                    (this.Country != null &&
                    this.Country.Equals(input.Country))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.ExchangeCode == input.ExchangeCode ||
                    (this.ExchangeCode != null &&
                    this.ExchangeCode.Equals(input.ExchangeCode))
                ) && 
                (
                    this.ExchangeName == input.ExchangeName ||
                    (this.ExchangeName != null &&
                    this.ExchangeName.Equals(input.ExchangeName))
                ) && 
                (
                    this.TickerStep == input.TickerStep ||
                    this.TickerStep.Equals(input.TickerStep)
                ) && 
                (
                    this.UnitValue == input.UnitValue ||
                    this.UnitValue.Equals(input.UnitValue)
                ) && 
                (
                    this.Calendars == input.Calendars ||
                    this.Calendars != null &&
                    input.Calendars != null &&
                    this.Calendars.SequenceEqual(input.Calendars)
                ) && 
                (
                    this.DeliveryType == input.DeliveryType ||
                    (this.DeliveryType != null &&
                    this.DeliveryType.Equals(input.DeliveryType))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.DomCcy != null)
                {
                    hashCode = (hashCode * 59) + this.DomCcy.GetHashCode();
                }
                if (this.FgnCcy != null)
                {
                    hashCode = (hashCode * 59) + this.FgnCcy.GetHashCode();
                }
                if (this.AssetClass != null)
                {
                    hashCode = (hashCode * 59) + this.AssetClass.GetHashCode();
                }
                if (this.ContractCode != null)
                {
                    hashCode = (hashCode * 59) + this.ContractCode.GetHashCode();
                }
                if (this.ContractMonth != null)
                {
                    hashCode = (hashCode * 59) + this.ContractMonth.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.ContractSize.GetHashCode();
                if (this.Convention != null)
                {
                    hashCode = (hashCode * 59) + this.Convention.GetHashCode();
                }
                if (this.Country != null)
                {
                    hashCode = (hashCode * 59) + this.Country.GetHashCode();
                }
                if (this.Description != null)
                {
                    hashCode = (hashCode * 59) + this.Description.GetHashCode();
                }
                if (this.ExchangeCode != null)
                {
                    hashCode = (hashCode * 59) + this.ExchangeCode.GetHashCode();
                }
                if (this.ExchangeName != null)
                {
                    hashCode = (hashCode * 59) + this.ExchangeName.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.TickerStep.GetHashCode();
                hashCode = (hashCode * 59) + this.UnitValue.GetHashCode();
                if (this.Calendars != null)
                {
                    hashCode = (hashCode * 59) + this.Calendars.GetHashCode();
                }
                if (this.DeliveryType != null)
                {
                    hashCode = (hashCode * 59) + this.DeliveryType.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // ContractCode (string) minLength
            if (this.ContractCode != null && this.ContractCode.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ContractCode, length must be greater than 1.", new [] { "ContractCode" });
            }

            // ExchangeCode (string) minLength
            if (this.ExchangeCode != null && this.ExchangeCode.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExchangeCode, length must be greater than 1.", new [] { "ExchangeCode" });
            }

            yield break;
        }
    }
}
