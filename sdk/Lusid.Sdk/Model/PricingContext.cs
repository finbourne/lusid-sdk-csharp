/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Pricing context node. In order to price an instrument a number of configuration parameters are required to determine which (a) pricing model (ranging from a simple lookup of a market quote/price through to a Monte-Carlo simulation for the behaviour of its cashflows) (b) vendor library (Lusid internal models or those provided through an external Vendor such as Refinitiv (proprietary) or QuantLib (open source) are used in the pricing.  In conjunction with these there are a number of parameters that govern the behaviour of these models. For example, in pricing an Fx volatility dependent product such as an Fx option, there are various parameters that affect model behaviour for the smile. In Lusid a distinction is made between those which are understood natively and those which are only held for use with a given vendor-model combination. The problem is that, unlike market quote data, there are few standards around model descriptions. Hence, apparently similar terminology can be mis-leading; for example in SABR models where the basic parameters are agreed upon but most practical models have used an approximation with adjustments where the parameters can have wildly different meanings. To avoid confusion or mis-behaviour in this area, where parameters are not understood to be interchangeable, they are only settable on a per-library per-model basis, essentially as opaque data that will be given to the Vendor library \&quot;verbatim\&quot; but not used with any other.
    /// </summary>
    [DataContract(Name = "PricingContext")]
    public partial class PricingContext : IEquatable<PricingContext>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PricingContext" /> class.
        /// </summary>
        /// <param name="modelRules">The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair. Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification in the options..</param>
        /// <param name="modelChoice">The choice of which model selection (vendor library, pricing model) to use in evaluation of a given instrument type..</param>
        /// <param name="options">options.</param>
        /// <param name="resultDataRules">Set of rules that control querying of unit results either for direct queries into aggregation or for overriding intermediate calculations. For example, a dirty price is made up from a clean price and the accrued interest. One might consider overriding the accrued interest calculated by a model (perhaps one wants to match an external value or simply disagrees with the calculated result) and use that in calculation of the dirty price..</param>
        /// <param name="holdingPricingInfo">holdingPricingInfo.</param>
        /// <param name="accrualDefinition">Determines which method to use for the calculation of accrued interest. Defaults to SOD..</param>
        public PricingContext(List<VendorModelRule> modelRules = default(List<VendorModelRule>), Dictionary<string, ModelSelection> modelChoice = default(Dictionary<string, ModelSelection>), PricingOptions options = default(PricingOptions), List<ResultKeyRule> resultDataRules = default(List<ResultKeyRule>), HoldingPricingInfo holdingPricingInfo = default(HoldingPricingInfo), string accrualDefinition = default(string))
        {
            this.ModelRules = modelRules;
            this.ModelChoice = modelChoice;
            this.Options = options;
            this.ResultDataRules = resultDataRules;
            this.HoldingPricingInfo = holdingPricingInfo;
            this.AccrualDefinition = accrualDefinition;
        }

        /// <summary>
        /// The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair. Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification in the options.
        /// </summary>
        /// <value>The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair. Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification in the options.</value>
        [DataMember(Name = "modelRules", EmitDefaultValue = true)]
        public List<VendorModelRule> ModelRules { get; set; }

        /// <summary>
        /// The choice of which model selection (vendor library, pricing model) to use in evaluation of a given instrument type.
        /// </summary>
        /// <value>The choice of which model selection (vendor library, pricing model) to use in evaluation of a given instrument type.</value>
        [DataMember(Name = "modelChoice", EmitDefaultValue = true)]
        public Dictionary<string, ModelSelection> ModelChoice { get; set; }

        /// <summary>
        /// Gets or Sets Options
        /// </summary>
        [DataMember(Name = "options", EmitDefaultValue = false)]
        public PricingOptions Options { get; set; }

        /// <summary>
        /// Set of rules that control querying of unit results either for direct queries into aggregation or for overriding intermediate calculations. For example, a dirty price is made up from a clean price and the accrued interest. One might consider overriding the accrued interest calculated by a model (perhaps one wants to match an external value or simply disagrees with the calculated result) and use that in calculation of the dirty price.
        /// </summary>
        /// <value>Set of rules that control querying of unit results either for direct queries into aggregation or for overriding intermediate calculations. For example, a dirty price is made up from a clean price and the accrued interest. One might consider overriding the accrued interest calculated by a model (perhaps one wants to match an external value or simply disagrees with the calculated result) and use that in calculation of the dirty price.</value>
        [DataMember(Name = "resultDataRules", EmitDefaultValue = true)]
        public List<ResultKeyRule> ResultDataRules { get; set; }

        /// <summary>
        /// Gets or Sets HoldingPricingInfo
        /// </summary>
        [DataMember(Name = "holdingPricingInfo", EmitDefaultValue = false)]
        public HoldingPricingInfo HoldingPricingInfo { get; set; }

        /// <summary>
        /// Determines which method to use for the calculation of accrued interest. Defaults to SOD.
        /// </summary>
        /// <value>Determines which method to use for the calculation of accrued interest. Defaults to SOD.</value>
        [DataMember(Name = "accrualDefinition", EmitDefaultValue = true)]
        public string AccrualDefinition { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PricingContext {\n");
            sb.Append("  ModelRules: ").Append(ModelRules).Append("\n");
            sb.Append("  ModelChoice: ").Append(ModelChoice).Append("\n");
            sb.Append("  Options: ").Append(Options).Append("\n");
            sb.Append("  ResultDataRules: ").Append(ResultDataRules).Append("\n");
            sb.Append("  HoldingPricingInfo: ").Append(HoldingPricingInfo).Append("\n");
            sb.Append("  AccrualDefinition: ").Append(AccrualDefinition).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PricingContext);
        }

        /// <summary>
        /// Returns true if PricingContext instances are equal
        /// </summary>
        /// <param name="input">Instance of PricingContext to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PricingContext input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ModelRules == input.ModelRules ||
                    this.ModelRules != null &&
                    input.ModelRules != null &&
                    this.ModelRules.SequenceEqual(input.ModelRules)
                ) && 
                (
                    this.ModelChoice == input.ModelChoice ||
                    this.ModelChoice != null &&
                    input.ModelChoice != null &&
                    this.ModelChoice.SequenceEqual(input.ModelChoice)
                ) && 
                (
                    this.Options == input.Options ||
                    (this.Options != null &&
                    this.Options.Equals(input.Options))
                ) && 
                (
                    this.ResultDataRules == input.ResultDataRules ||
                    this.ResultDataRules != null &&
                    input.ResultDataRules != null &&
                    this.ResultDataRules.SequenceEqual(input.ResultDataRules)
                ) && 
                (
                    this.HoldingPricingInfo == input.HoldingPricingInfo ||
                    (this.HoldingPricingInfo != null &&
                    this.HoldingPricingInfo.Equals(input.HoldingPricingInfo))
                ) && 
                (
                    this.AccrualDefinition == input.AccrualDefinition ||
                    (this.AccrualDefinition != null &&
                    this.AccrualDefinition.Equals(input.AccrualDefinition))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ModelRules != null)
                {
                    hashCode = (hashCode * 59) + this.ModelRules.GetHashCode();
                }
                if (this.ModelChoice != null)
                {
                    hashCode = (hashCode * 59) + this.ModelChoice.GetHashCode();
                }
                if (this.Options != null)
                {
                    hashCode = (hashCode * 59) + this.Options.GetHashCode();
                }
                if (this.ResultDataRules != null)
                {
                    hashCode = (hashCode * 59) + this.ResultDataRules.GetHashCode();
                }
                if (this.HoldingPricingInfo != null)
                {
                    hashCode = (hashCode * 59) + this.HoldingPricingInfo.GetHashCode();
                }
                if (this.AccrualDefinition != null)
                {
                    hashCode = (hashCode * 59) + this.AccrualDefinition.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // AccrualDefinition (string) maxLength
            if (this.AccrualDefinition != null && this.AccrualDefinition.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AccrualDefinition, length must be less than 50.", new [] { "AccrualDefinition" });
            }

            // AccrualDefinition (string) minLength
            if (this.AccrualDefinition != null && this.AccrualDefinition.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AccrualDefinition, length must be greater than 0.", new [] { "AccrualDefinition" });
            }

            yield break;
        }
    }
}
