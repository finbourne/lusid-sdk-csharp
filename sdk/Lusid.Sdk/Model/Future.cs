/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// LUSID representation of a Future.  Including, but not limited to, Equity Futures, Bond Futures, Index Futures, Currency Futures, and Interest Rate Futures.
    /// </summary>
    [DataContract(Name = "Future")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentType")]
    public partial class Future : LusidInstrument, IEquatable<Future>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Future" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Future() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Future" /> class.
        /// </summary>
        /// <param name="startDate">The start date of the instrument. This is normally synonymous with the trade-date. (required).</param>
        /// <param name="maturityDate">The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it. (required).</param>
        /// <param name="identifiers">External market codes and identifiers for the bond, e.g. ISIN. (required).</param>
        /// <param name="contractDetails">contractDetails (required).</param>
        /// <param name="contracts">The number of contracts held. This is optional and will default to 1 if not set.  Instrument events will only work when this field is 1.  We recommend not using this field and instead relying on the number of holdings to   represent the number of futures contracts. (default to 1D).</param>
        /// <param name="markToMarketConventions">markToMarketConventions.</param>
        /// <param name="refSpotPrice">The reference spot price for the future at which the contract was entered into..</param>
        /// <param name="underlying">underlying.</param>
        /// <param name="calculationType">Calculation type for some Future instruments which have non-standard methodology.  Optional, if not set defaults as follows:  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;IR\&quot; or \&quot;BB\&quot; set to ASX_BankBills  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;YT\&quot; set to ASX_3Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;VT\&quot; set to ASX_5Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;XT\&quot; set to ASX_10Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;LT\&quot; set to ASX_20Year  - otherwise set to Standard                Specific calculation types for bond and interest rate futures are:  - [Standard] The default calculation type, which does not fit into any of the categories below.  - [ASX_BankBills] Used for AUD and NZD futures “IR” and “BB” on ASX. 90D Bank Bills.  - [ASX_3Year] Used for “YT” on ASX. 3YR semi-annual bond (6 coupons) @ 6%.  - [ASX_5Year] Used for “VT” on ASX. 5yr semi-annual bond (10 coupons) @ 2%.  - [ASX_10Year] Used for “XT” on ASX. 10yr semi-annual bond (20 coupons) @ 6%.  - [ASX_20Year] Used for “LT” on ASX. 20yr semi-annual bond (40 coupons) @ 4%.  - [B3_DI1] Used for “DI1” on B3. Average of 1D interbank deposit rates.    - For futures with this calculation type, quote values are expected to be specified as a percentage.      For example, a quoted rate of 13.205% should be specified as a quote of 13.205 with a face value of 100.                Supported string (enumeration) values are: [Standard, ASX_BankBills, ASX_3Year, ASX_5Year, ASX_10Year, ASX_20Year, B3_DI1]..</param>
        /// <param name="tradingConventions">tradingConventions.</param>
        /// <param name="timeZoneConventions">timeZoneConventions.</param>
        /// <param name="instrumentType">The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap, InflationLeg, FundShareClass, FlexibleLoan, UnsettledCash, Cash, MasteredInstrument, LoanFacility, FlexibleDeposit, FlexibleRepo (required) (default to &quot;Future&quot;).</param>
        public Future(DateTimeOffset startDate = default(DateTimeOffset), DateTimeOffset maturityDate = default(DateTimeOffset), Dictionary<string, string> identifiers = default(Dictionary<string, string>), FuturesContractDetails contractDetails = default(FuturesContractDetails), decimal contracts = (decimal)1D, MarkToMarketConventions markToMarketConventions = default(MarkToMarketConventions), decimal refSpotPrice = default(decimal), LusidInstrument underlying = default(LusidInstrument), string calculationType = default(string), TradingConventions tradingConventions = default(TradingConventions), TimeZoneConventions timeZoneConventions = default(TimeZoneConventions), InstrumentTypeEnum instrumentType = default(InstrumentTypeEnum)) : base(instrumentType)
        {
            this.StartDate = startDate;
            this.MaturityDate = maturityDate;
            // to ensure "identifiers" is required (not null)
            if (identifiers == null)
            {
                throw new ArgumentNullException("identifiers is a required property for Future and cannot be null");
            }
            this.Identifiers = identifiers;
            // to ensure "contractDetails" is required (not null)
            if (contractDetails == null)
            {
                throw new ArgumentNullException("contractDetails is a required property for Future and cannot be null");
            }
            this.ContractDetails = contractDetails;
            this.Contracts = contracts;
            this.MarkToMarketConventions = markToMarketConventions;
            this.RefSpotPrice = refSpotPrice;
            this.Underlying = underlying;
            this.CalculationType = calculationType;
            this.TradingConventions = tradingConventions;
            this.TimeZoneConventions = timeZoneConventions;
        }

        /// <summary>
        /// The start date of the instrument. This is normally synonymous with the trade-date.
        /// </summary>
        /// <value>The start date of the instrument. This is normally synonymous with the trade-date.</value>
        [DataMember(Name = "startDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.
        /// </summary>
        /// <value>The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.</value>
        [DataMember(Name = "maturityDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset MaturityDate { get; set; }

        /// <summary>
        /// External market codes and identifiers for the bond, e.g. ISIN.
        /// </summary>
        /// <value>External market codes and identifiers for the bond, e.g. ISIN.</value>
        [DataMember(Name = "identifiers", IsRequired = true, EmitDefaultValue = true)]
        public Dictionary<string, string> Identifiers { get; set; }

        /// <summary>
        /// Gets or Sets ContractDetails
        /// </summary>
        [DataMember(Name = "contractDetails", IsRequired = true, EmitDefaultValue = true)]
        public FuturesContractDetails ContractDetails { get; set; }

        /// <summary>
        /// The number of contracts held. This is optional and will default to 1 if not set.  Instrument events will only work when this field is 1.  We recommend not using this field and instead relying on the number of holdings to   represent the number of futures contracts.
        /// </summary>
        /// <value>The number of contracts held. This is optional and will default to 1 if not set.  Instrument events will only work when this field is 1.  We recommend not using this field and instead relying on the number of holdings to   represent the number of futures contracts.</value>
        [DataMember(Name = "contracts", EmitDefaultValue = true)]
        public decimal Contracts { get; set; }

        /// <summary>
        /// Gets or Sets MarkToMarketConventions
        /// </summary>
        [DataMember(Name = "markToMarketConventions", EmitDefaultValue = false)]
        public MarkToMarketConventions MarkToMarketConventions { get; set; }

        /// <summary>
        /// The reference spot price for the future at which the contract was entered into.
        /// </summary>
        /// <value>The reference spot price for the future at which the contract was entered into.</value>
        [DataMember(Name = "refSpotPrice", EmitDefaultValue = true)]
        public decimal RefSpotPrice { get; set; }

        /// <summary>
        /// Gets or Sets Underlying
        /// </summary>
        [DataMember(Name = "underlying", EmitDefaultValue = false)]
        public LusidInstrument Underlying { get; set; }

        /// <summary>
        /// Calculation type for some Future instruments which have non-standard methodology.  Optional, if not set defaults as follows:  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;IR\&quot; or \&quot;BB\&quot; set to ASX_BankBills  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;YT\&quot; set to ASX_3Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;VT\&quot; set to ASX_5Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;XT\&quot; set to ASX_10Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;LT\&quot; set to ASX_20Year  - otherwise set to Standard                Specific calculation types for bond and interest rate futures are:  - [Standard] The default calculation type, which does not fit into any of the categories below.  - [ASX_BankBills] Used for AUD and NZD futures “IR” and “BB” on ASX. 90D Bank Bills.  - [ASX_3Year] Used for “YT” on ASX. 3YR semi-annual bond (6 coupons) @ 6%.  - [ASX_5Year] Used for “VT” on ASX. 5yr semi-annual bond (10 coupons) @ 2%.  - [ASX_10Year] Used for “XT” on ASX. 10yr semi-annual bond (20 coupons) @ 6%.  - [ASX_20Year] Used for “LT” on ASX. 20yr semi-annual bond (40 coupons) @ 4%.  - [B3_DI1] Used for “DI1” on B3. Average of 1D interbank deposit rates.    - For futures with this calculation type, quote values are expected to be specified as a percentage.      For example, a quoted rate of 13.205% should be specified as a quote of 13.205 with a face value of 100.                Supported string (enumeration) values are: [Standard, ASX_BankBills, ASX_3Year, ASX_5Year, ASX_10Year, ASX_20Year, B3_DI1].
        /// </summary>
        /// <value>Calculation type for some Future instruments which have non-standard methodology.  Optional, if not set defaults as follows:  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;IR\&quot; or \&quot;BB\&quot; set to ASX_BankBills  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;YT\&quot; set to ASX_3Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;VT\&quot; set to ASX_5Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;XT\&quot; set to ASX_10Year  - If ExchangeCode is \&quot;ASX\&quot; and ContractCode is \&quot;LT\&quot; set to ASX_20Year  - otherwise set to Standard                Specific calculation types for bond and interest rate futures are:  - [Standard] The default calculation type, which does not fit into any of the categories below.  - [ASX_BankBills] Used for AUD and NZD futures “IR” and “BB” on ASX. 90D Bank Bills.  - [ASX_3Year] Used for “YT” on ASX. 3YR semi-annual bond (6 coupons) @ 6%.  - [ASX_5Year] Used for “VT” on ASX. 5yr semi-annual bond (10 coupons) @ 2%.  - [ASX_10Year] Used for “XT” on ASX. 10yr semi-annual bond (20 coupons) @ 6%.  - [ASX_20Year] Used for “LT” on ASX. 20yr semi-annual bond (40 coupons) @ 4%.  - [B3_DI1] Used for “DI1” on B3. Average of 1D interbank deposit rates.    - For futures with this calculation type, quote values are expected to be specified as a percentage.      For example, a quoted rate of 13.205% should be specified as a quote of 13.205 with a face value of 100.                Supported string (enumeration) values are: [Standard, ASX_BankBills, ASX_3Year, ASX_5Year, ASX_10Year, ASX_20Year, B3_DI1].</value>
        [DataMember(Name = "calculationType", EmitDefaultValue = true)]
        public string CalculationType { get; set; }

        /// <summary>
        /// Gets or Sets TradingConventions
        /// </summary>
        [DataMember(Name = "tradingConventions", EmitDefaultValue = false)]
        public TradingConventions TradingConventions { get; set; }

        /// <summary>
        /// Gets or Sets TimeZoneConventions
        /// </summary>
        [DataMember(Name = "timeZoneConventions", EmitDefaultValue = false)]
        public TimeZoneConventions TimeZoneConventions { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Future {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  MaturityDate: ").Append(MaturityDate).Append("\n");
            sb.Append("  Identifiers: ").Append(Identifiers).Append("\n");
            sb.Append("  ContractDetails: ").Append(ContractDetails).Append("\n");
            sb.Append("  Contracts: ").Append(Contracts).Append("\n");
            sb.Append("  MarkToMarketConventions: ").Append(MarkToMarketConventions).Append("\n");
            sb.Append("  RefSpotPrice: ").Append(RefSpotPrice).Append("\n");
            sb.Append("  Underlying: ").Append(Underlying).Append("\n");
            sb.Append("  CalculationType: ").Append(CalculationType).Append("\n");
            sb.Append("  TradingConventions: ").Append(TradingConventions).Append("\n");
            sb.Append("  TimeZoneConventions: ").Append(TimeZoneConventions).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Future);
        }

        /// <summary>
        /// Returns true if Future instances are equal
        /// </summary>
        /// <param name="input">Instance of Future to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Future input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && base.Equals(input) && 
                (
                    this.MaturityDate == input.MaturityDate ||
                    (this.MaturityDate != null &&
                    this.MaturityDate.Equals(input.MaturityDate))
                ) && base.Equals(input) && 
                (
                    this.Identifiers == input.Identifiers ||
                    this.Identifiers != null &&
                    input.Identifiers != null &&
                    this.Identifiers.SequenceEqual(input.Identifiers)
                ) && base.Equals(input) && 
                (
                    this.ContractDetails == input.ContractDetails ||
                    (this.ContractDetails != null &&
                    this.ContractDetails.Equals(input.ContractDetails))
                ) && base.Equals(input) && 
                (
                    this.Contracts == input.Contracts ||
                    this.Contracts.Equals(input.Contracts)
                ) && base.Equals(input) && 
                (
                    this.MarkToMarketConventions == input.MarkToMarketConventions ||
                    (this.MarkToMarketConventions != null &&
                    this.MarkToMarketConventions.Equals(input.MarkToMarketConventions))
                ) && base.Equals(input) && 
                (
                    this.RefSpotPrice == input.RefSpotPrice ||
                    this.RefSpotPrice.Equals(input.RefSpotPrice)
                ) && base.Equals(input) && 
                (
                    this.Underlying == input.Underlying ||
                    (this.Underlying != null &&
                    this.Underlying.Equals(input.Underlying))
                ) && base.Equals(input) && 
                (
                    this.CalculationType == input.CalculationType ||
                    (this.CalculationType != null &&
                    this.CalculationType.Equals(input.CalculationType))
                ) && base.Equals(input) && 
                (
                    this.TradingConventions == input.TradingConventions ||
                    (this.TradingConventions != null &&
                    this.TradingConventions.Equals(input.TradingConventions))
                ) && base.Equals(input) && 
                (
                    this.TimeZoneConventions == input.TimeZoneConventions ||
                    (this.TimeZoneConventions != null &&
                    this.TimeZoneConventions.Equals(input.TimeZoneConventions))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.StartDate != null)
                {
                    hashCode = (hashCode * 59) + this.StartDate.GetHashCode();
                }
                if (this.MaturityDate != null)
                {
                    hashCode = (hashCode * 59) + this.MaturityDate.GetHashCode();
                }
                if (this.Identifiers != null)
                {
                    hashCode = (hashCode * 59) + this.Identifiers.GetHashCode();
                }
                if (this.ContractDetails != null)
                {
                    hashCode = (hashCode * 59) + this.ContractDetails.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Contracts.GetHashCode();
                if (this.MarkToMarketConventions != null)
                {
                    hashCode = (hashCode * 59) + this.MarkToMarketConventions.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RefSpotPrice.GetHashCode();
                if (this.Underlying != null)
                {
                    hashCode = (hashCode * 59) + this.Underlying.GetHashCode();
                }
                if (this.CalculationType != null)
                {
                    hashCode = (hashCode * 59) + this.CalculationType.GetHashCode();
                }
                if (this.TradingConventions != null)
                {
                    hashCode = (hashCode * 59) + this.TradingConventions.GetHashCode();
                }
                if (this.TimeZoneConventions != null)
                {
                    hashCode = (hashCode * 59) + this.TimeZoneConventions.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // CalculationType (string) maxLength
            if (this.CalculationType != null && this.CalculationType.Length > 32)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculationType, length must be less than 32.", new [] { "CalculationType" });
            }

            // CalculationType (string) minLength
            if (this.CalculationType != null && this.CalculationType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculationType, length must be greater than 0.", new [] { "CalculationType" });
            }

            yield break;
        }
    }
}
