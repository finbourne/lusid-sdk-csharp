/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// ReconcileNumericRule
    /// </summary>
    [DataContract(Name = "ReconcileNumericRule")]
    [JsonConverter(typeof(JsonSubtypes), "RuleType")]
    public partial class ReconcileNumericRule : ReconciliationRule, IEquatable<ReconcileNumericRule>, IValidatableObject
    {
        /// <summary>
        /// The available values are: Exact, AbsoluteDifference, RelativeDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference, RelativeDifference</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ComparisonTypeEnum
        {
            /// <summary>
            /// Enum Exact for value: Exact
            /// </summary>
            [EnumMember(Value = "Exact")]
            Exact = 1,

            /// <summary>
            /// Enum AbsoluteDifference for value: AbsoluteDifference
            /// </summary>
            [EnumMember(Value = "AbsoluteDifference")]
            AbsoluteDifference = 2,

            /// <summary>
            /// Enum RelativeDifference for value: RelativeDifference
            /// </summary>
            [EnumMember(Value = "RelativeDifference")]
            RelativeDifference = 3

        }


        /// <summary>
        /// The available values are: Exact, AbsoluteDifference, RelativeDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference, RelativeDifference</value>
        [DataMember(Name = "comparisonType", IsRequired = true, EmitDefaultValue = true)]
        public ComparisonTypeEnum ComparisonType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileNumericRule" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReconcileNumericRule() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileNumericRule" /> class.
        /// </summary>
        /// <param name="comparisonType">The available values are: Exact, AbsoluteDifference, RelativeDifference (required).</param>
        /// <param name="tolerance">For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction..</param>
        /// <param name="appliesTo">appliesTo (required).</param>
        /// <param name="ruleType">The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact (required) (default to &quot;ReconcileNumericRule&quot;).</param>
        public ReconcileNumericRule(ComparisonTypeEnum comparisonType = default(ComparisonTypeEnum), decimal tolerance = default(decimal), AggregateSpec appliesTo = default(AggregateSpec), RuleTypeEnum ruleType = default(RuleTypeEnum)) : base(ruleType)
        {
            this.ComparisonType = comparisonType;
            // to ensure "appliesTo" is required (not null)
            if (appliesTo == null)
            {
                throw new ArgumentNullException("appliesTo is a required property for ReconcileNumericRule and cannot be null");
            }
            this.AppliesTo = appliesTo;
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction.
        /// </summary>
        /// <value>For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction.</value>
        [DataMember(Name = "tolerance", EmitDefaultValue = true)]
        public decimal Tolerance { get; set; }

        /// <summary>
        /// Gets or Sets AppliesTo
        /// </summary>
        [DataMember(Name = "appliesTo", IsRequired = true, EmitDefaultValue = true)]
        public AggregateSpec AppliesTo { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReconcileNumericRule {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  ComparisonType: ").Append(ComparisonType).Append("\n");
            sb.Append("  Tolerance: ").Append(Tolerance).Append("\n");
            sb.Append("  AppliesTo: ").Append(AppliesTo).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReconcileNumericRule);
        }

        /// <summary>
        /// Returns true if ReconcileNumericRule instances are equal
        /// </summary>
        /// <param name="input">Instance of ReconcileNumericRule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReconcileNumericRule input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.ComparisonType == input.ComparisonType ||
                    this.ComparisonType.Equals(input.ComparisonType)
                ) && base.Equals(input) && 
                (
                    this.Tolerance == input.Tolerance ||
                    this.Tolerance.Equals(input.Tolerance)
                ) && base.Equals(input) && 
                (
                    this.AppliesTo == input.AppliesTo ||
                    (this.AppliesTo != null &&
                    this.AppliesTo.Equals(input.AppliesTo))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                hashCode = (hashCode * 59) + this.ComparisonType.GetHashCode();
                hashCode = (hashCode * 59) + this.Tolerance.GetHashCode();
                if (this.AppliesTo != null)
                {
                    hashCode = (hashCode * 59) + this.AppliesTo.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            yield break;
        }
    }
}
