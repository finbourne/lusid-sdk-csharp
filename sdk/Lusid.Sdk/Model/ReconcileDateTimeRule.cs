/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Comparison of date time values
    /// </summary>
    [DataContract(Name = "ReconcileDateTimeRule")]
    [JsonConverter(typeof(JsonSubtypes), "RuleType")]
    public partial class ReconcileDateTimeRule : ReconciliationRule, IEquatable<ReconcileDateTimeRule>, IValidatableObject
    {
        /// <summary>
        /// The available values are: Exact, AbsoluteDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ComparisonTypeEnum
        {
            /// <summary>
            /// Enum Exact for value: Exact
            /// </summary>
            [EnumMember(Value = "Exact")]
            Exact = 1,

            /// <summary>
            /// Enum AbsoluteDifference for value: AbsoluteDifference
            /// </summary>
            [EnumMember(Value = "AbsoluteDifference")]
            AbsoluteDifference = 2
        }


        /// <summary>
        /// The available values are: Exact, AbsoluteDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference</value>
        [DataMember(Name = "comparisonType", IsRequired = true, EmitDefaultValue = true)]
        public ComparisonTypeEnum ComparisonType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileDateTimeRule" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReconcileDateTimeRule() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileDateTimeRule" /> class.
        /// </summary>
        /// <param name="comparisonType">The available values are: Exact, AbsoluteDifference (required).</param>
        /// <param name="tolerance">For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison. The units of the tolerance must be set appropriately for the item being compared. For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be passed as a fraction..</param>
        /// <param name="appliesTo">appliesTo (required).</param>
        /// <param name="ruleType">The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact (required) (default to &quot;ReconcileDateTimeRule&quot;).</param>
        public ReconcileDateTimeRule(ComparisonTypeEnum comparisonType = default(ComparisonTypeEnum), decimal tolerance = default(decimal), AggregateSpec appliesTo = default(AggregateSpec), RuleTypeEnum ruleType = default(RuleTypeEnum)) : base(ruleType)
        {
            this.ComparisonType = comparisonType;
            // to ensure "appliesTo" is required (not null)
            if (appliesTo == null)
            {
                throw new ArgumentNullException("appliesTo is a required property for ReconcileDateTimeRule and cannot be null");
            }
            this.AppliesTo = appliesTo;
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison. The units of the tolerance must be set appropriately for the item being compared. For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be passed as a fraction.
        /// </summary>
        /// <value>For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison. The units of the tolerance must be set appropriately for the item being compared. For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be passed as a fraction.</value>
        [DataMember(Name = "tolerance", EmitDefaultValue = true)]
        public decimal Tolerance { get; set; }

        /// <summary>
        /// Gets or Sets AppliesTo
        /// </summary>
        [DataMember(Name = "appliesTo", IsRequired = true, EmitDefaultValue = true)]
        public AggregateSpec AppliesTo { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReconcileDateTimeRule {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  ComparisonType: ").Append(ComparisonType).Append("\n");
            sb.Append("  Tolerance: ").Append(Tolerance).Append("\n");
            sb.Append("  AppliesTo: ").Append(AppliesTo).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReconcileDateTimeRule);
        }

        /// <summary>
        /// Returns true if ReconcileDateTimeRule instances are equal
        /// </summary>
        /// <param name="input">Instance of ReconcileDateTimeRule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReconcileDateTimeRule input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.ComparisonType == input.ComparisonType ||
                    this.ComparisonType.Equals(input.ComparisonType)
                ) && base.Equals(input) && 
                (
                    this.Tolerance == input.Tolerance ||
                    this.Tolerance.Equals(input.Tolerance)
                ) && base.Equals(input) && 
                (
                    this.AppliesTo == input.AppliesTo ||
                    (this.AppliesTo != null &&
                    this.AppliesTo.Equals(input.AppliesTo))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                hashCode = (hashCode * 59) + this.ComparisonType.GetHashCode();
                hashCode = (hashCode * 59) + this.Tolerance.GetHashCode();
                if (this.AppliesTo != null)
                {
                    hashCode = (hashCode * 59) + this.AppliesTo.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            yield break;
        }
    }
}
