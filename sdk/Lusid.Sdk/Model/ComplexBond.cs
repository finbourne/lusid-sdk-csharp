/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// LUSID representation of a Complex Bond.  Including Floating, Fixed-to-float, Sinkable, Callable, Puttable, and Mortgage Backed Securities.
    /// </summary>
    [DataContract(Name = "ComplexBond")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentType")]
    public partial class ComplexBond : LusidInstrument, IEquatable<ComplexBond>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ComplexBond" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ComplexBond() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ComplexBond" /> class.
        /// </summary>
        /// <param name="identifiers">External market codes and identifiers for the bond, e.g. ISIN..</param>
        /// <param name="calculationType">The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal * Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon, StandardWithCappedAccruedInterest]..</param>
        /// <param name="schedules">schedules..</param>
        /// <param name="originalIssuePrice">The price the complex bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%..</param>
        /// <param name="roundingConventions">Rounding conventions for analytics, if any..</param>
        /// <param name="assetBacked">If this flag is set to true, then the outstanding notional and principal repayments will be calculated based  on pool factors in the quote store. Usually AssetBacked bonds also require a RollConvention setting of   within the FlowConventions any given rates schedule (to ensure payment dates always happen on the same day  of the month) and US Agency MBSs with Pay Delay features also require their rates schedules to include an  ExDividendConfiguration to drive the lag between interest accrual and payment..</param>
        /// <param name="assetPoolIdentifier">Identifier used to retrieve pool factor information about this bond from the quote store. This is typically  the bond&#39;s ISIN, but can also be ClientInternal. Please ensure you align the MarketDataKeyRule with the  correct Quote (Quote.ClientInternal.* or Quote.Isin.*).</param>
        /// <param name="tradingConventions">tradingConventions.</param>
        /// <param name="timeZoneConventions">timeZoneConventions.</param>
        /// <param name="instrumentType">The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap, InflationLeg, FundShareClass, FlexibleLoan, UnsettledCash, Cash, MasteredInstrument, LoanFacility, FlexibleDeposit, FlexibleRepo (required) (default to &quot;ComplexBond&quot;).</param>
        public ComplexBond(Dictionary<string, string> identifiers = default(Dictionary<string, string>), string calculationType = default(string), List<Schedule> schedules = default(List<Schedule>), decimal? originalIssuePrice = default(decimal?), List<RoundingConvention> roundingConventions = default(List<RoundingConvention>), bool? assetBacked = default(bool?), string assetPoolIdentifier = default(string), TradingConventions tradingConventions = default(TradingConventions), TimeZoneConventions timeZoneConventions = default(TimeZoneConventions), InstrumentTypeEnum instrumentType = default(InstrumentTypeEnum)) : base(instrumentType)
        {
            this.Identifiers = identifiers;
            this.CalculationType = calculationType;
            this.Schedules = schedules;
            this.OriginalIssuePrice = originalIssuePrice;
            this.RoundingConventions = roundingConventions;
            this.AssetBacked = assetBacked;
            this.AssetPoolIdentifier = assetPoolIdentifier;
            this.TradingConventions = tradingConventions;
            this.TimeZoneConventions = timeZoneConventions;
        }

        /// <summary>
        /// External market codes and identifiers for the bond, e.g. ISIN.
        /// </summary>
        /// <value>External market codes and identifiers for the bond, e.g. ISIN.</value>
        [DataMember(Name = "identifiers", EmitDefaultValue = true)]
        public Dictionary<string, string> Identifiers { get; set; }

        /// <summary>
        /// The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal * Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon, StandardWithCappedAccruedInterest].
        /// </summary>
        /// <value>The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal * Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon, StandardWithCappedAccruedInterest].</value>
        [DataMember(Name = "calculationType", EmitDefaultValue = true)]
        public string CalculationType { get; set; }

        /// <summary>
        /// schedules.
        /// </summary>
        /// <value>schedules.</value>
        [DataMember(Name = "schedules", EmitDefaultValue = true)]
        public List<Schedule> Schedules { get; set; }

        /// <summary>
        /// The price the complex bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%.
        /// </summary>
        /// <value>The price the complex bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%.</value>
        [DataMember(Name = "originalIssuePrice", EmitDefaultValue = true)]
        public decimal? OriginalIssuePrice { get; set; }

        /// <summary>
        /// Rounding conventions for analytics, if any.
        /// </summary>
        /// <value>Rounding conventions for analytics, if any.</value>
        [DataMember(Name = "roundingConventions", EmitDefaultValue = true)]
        public List<RoundingConvention> RoundingConventions { get; set; }

        /// <summary>
        /// If this flag is set to true, then the outstanding notional and principal repayments will be calculated based  on pool factors in the quote store. Usually AssetBacked bonds also require a RollConvention setting of   within the FlowConventions any given rates schedule (to ensure payment dates always happen on the same day  of the month) and US Agency MBSs with Pay Delay features also require their rates schedules to include an  ExDividendConfiguration to drive the lag between interest accrual and payment.
        /// </summary>
        /// <value>If this flag is set to true, then the outstanding notional and principal repayments will be calculated based  on pool factors in the quote store. Usually AssetBacked bonds also require a RollConvention setting of   within the FlowConventions any given rates schedule (to ensure payment dates always happen on the same day  of the month) and US Agency MBSs with Pay Delay features also require their rates schedules to include an  ExDividendConfiguration to drive the lag between interest accrual and payment.</value>
        [DataMember(Name = "assetBacked", EmitDefaultValue = true)]
        public bool? AssetBacked { get; set; }

        /// <summary>
        /// Identifier used to retrieve pool factor information about this bond from the quote store. This is typically  the bond&#39;s ISIN, but can also be ClientInternal. Please ensure you align the MarketDataKeyRule with the  correct Quote (Quote.ClientInternal.* or Quote.Isin.*)
        /// </summary>
        /// <value>Identifier used to retrieve pool factor information about this bond from the quote store. This is typically  the bond&#39;s ISIN, but can also be ClientInternal. Please ensure you align the MarketDataKeyRule with the  correct Quote (Quote.ClientInternal.* or Quote.Isin.*)</value>
        [DataMember(Name = "assetPoolIdentifier", EmitDefaultValue = true)]
        public string AssetPoolIdentifier { get; set; }

        /// <summary>
        /// Gets or Sets TradingConventions
        /// </summary>
        [DataMember(Name = "tradingConventions", EmitDefaultValue = false)]
        public TradingConventions TradingConventions { get; set; }

        /// <summary>
        /// Gets or Sets TimeZoneConventions
        /// </summary>
        [DataMember(Name = "timeZoneConventions", EmitDefaultValue = false)]
        public TimeZoneConventions TimeZoneConventions { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ComplexBond {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  Identifiers: ").Append(Identifiers).Append("\n");
            sb.Append("  CalculationType: ").Append(CalculationType).Append("\n");
            sb.Append("  Schedules: ").Append(Schedules).Append("\n");
            sb.Append("  OriginalIssuePrice: ").Append(OriginalIssuePrice).Append("\n");
            sb.Append("  RoundingConventions: ").Append(RoundingConventions).Append("\n");
            sb.Append("  AssetBacked: ").Append(AssetBacked).Append("\n");
            sb.Append("  AssetPoolIdentifier: ").Append(AssetPoolIdentifier).Append("\n");
            sb.Append("  TradingConventions: ").Append(TradingConventions).Append("\n");
            sb.Append("  TimeZoneConventions: ").Append(TimeZoneConventions).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ComplexBond);
        }

        /// <summary>
        /// Returns true if ComplexBond instances are equal
        /// </summary>
        /// <param name="input">Instance of ComplexBond to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ComplexBond input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.Identifiers == input.Identifiers ||
                    this.Identifiers != null &&
                    input.Identifiers != null &&
                    this.Identifiers.SequenceEqual(input.Identifiers)
                ) && base.Equals(input) && 
                (
                    this.CalculationType == input.CalculationType ||
                    (this.CalculationType != null &&
                    this.CalculationType.Equals(input.CalculationType))
                ) && base.Equals(input) && 
                (
                    this.Schedules == input.Schedules ||
                    this.Schedules != null &&
                    input.Schedules != null &&
                    this.Schedules.SequenceEqual(input.Schedules)
                ) && base.Equals(input) && 
                (
                    this.OriginalIssuePrice == input.OriginalIssuePrice ||
                    (this.OriginalIssuePrice != null &&
                    this.OriginalIssuePrice.Equals(input.OriginalIssuePrice))
                ) && base.Equals(input) && 
                (
                    this.RoundingConventions == input.RoundingConventions ||
                    this.RoundingConventions != null &&
                    input.RoundingConventions != null &&
                    this.RoundingConventions.SequenceEqual(input.RoundingConventions)
                ) && base.Equals(input) && 
                (
                    this.AssetBacked == input.AssetBacked ||
                    (this.AssetBacked != null &&
                    this.AssetBacked.Equals(input.AssetBacked))
                ) && base.Equals(input) && 
                (
                    this.AssetPoolIdentifier == input.AssetPoolIdentifier ||
                    (this.AssetPoolIdentifier != null &&
                    this.AssetPoolIdentifier.Equals(input.AssetPoolIdentifier))
                ) && base.Equals(input) && 
                (
                    this.TradingConventions == input.TradingConventions ||
                    (this.TradingConventions != null &&
                    this.TradingConventions.Equals(input.TradingConventions))
                ) && base.Equals(input) && 
                (
                    this.TimeZoneConventions == input.TimeZoneConventions ||
                    (this.TimeZoneConventions != null &&
                    this.TimeZoneConventions.Equals(input.TimeZoneConventions))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.Identifiers != null)
                {
                    hashCode = (hashCode * 59) + this.Identifiers.GetHashCode();
                }
                if (this.CalculationType != null)
                {
                    hashCode = (hashCode * 59) + this.CalculationType.GetHashCode();
                }
                if (this.Schedules != null)
                {
                    hashCode = (hashCode * 59) + this.Schedules.GetHashCode();
                }
                if (this.OriginalIssuePrice != null)
                {
                    hashCode = (hashCode * 59) + this.OriginalIssuePrice.GetHashCode();
                }
                if (this.RoundingConventions != null)
                {
                    hashCode = (hashCode * 59) + this.RoundingConventions.GetHashCode();
                }
                if (this.AssetBacked != null)
                {
                    hashCode = (hashCode * 59) + this.AssetBacked.GetHashCode();
                }
                if (this.AssetPoolIdentifier != null)
                {
                    hashCode = (hashCode * 59) + this.AssetPoolIdentifier.GetHashCode();
                }
                if (this.TradingConventions != null)
                {
                    hashCode = (hashCode * 59) + this.TradingConventions.GetHashCode();
                }
                if (this.TimeZoneConventions != null)
                {
                    hashCode = (hashCode * 59) + this.TimeZoneConventions.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // CalculationType (string) maxLength
            if (this.CalculationType != null && this.CalculationType.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculationType, length must be less than 50.", new [] { "CalculationType" });
            }

            // CalculationType (string) minLength
            if (this.CalculationType != null && this.CalculationType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CalculationType, length must be greater than 0.", new [] { "CalculationType" });
            }

            // AssetPoolIdentifier (string) maxLength
            if (this.AssetPoolIdentifier != null && this.AssetPoolIdentifier.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AssetPoolIdentifier, length must be less than 50.", new [] { "AssetPoolIdentifier" });
            }

            // AssetPoolIdentifier (string) minLength
            if (this.AssetPoolIdentifier != null && this.AssetPoolIdentifier.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AssetPoolIdentifier, length must be greater than 0.", new [] { "AssetPoolIdentifier" });
            }

            yield break;
        }
    }
}
