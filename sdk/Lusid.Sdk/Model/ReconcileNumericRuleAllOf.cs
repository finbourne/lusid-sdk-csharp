/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// ReconcileNumericRuleAllOf
    /// </summary>
    [DataContract(Name = "ReconcileNumericRule_allOf")]
    public partial class ReconcileNumericRuleAllOf : IEquatable<ReconcileNumericRuleAllOf>, IValidatableObject
    {
        /// <summary>
        /// The available values are: Exact, AbsoluteDifference, RelativeDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference, RelativeDifference</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ComparisonTypeEnum
        {
            /// <summary>
            /// Enum Exact for value: Exact
            /// </summary>
            [EnumMember(Value = "Exact")]
            Exact = 1,

            /// <summary>
            /// Enum AbsoluteDifference for value: AbsoluteDifference
            /// </summary>
            [EnumMember(Value = "AbsoluteDifference")]
            AbsoluteDifference = 2,

            /// <summary>
            /// Enum RelativeDifference for value: RelativeDifference
            /// </summary>
            [EnumMember(Value = "RelativeDifference")]
            RelativeDifference = 3

        }


        /// <summary>
        /// The available values are: Exact, AbsoluteDifference, RelativeDifference
        /// </summary>
        /// <value>The available values are: Exact, AbsoluteDifference, RelativeDifference</value>
        [DataMember(Name = "comparisonType", IsRequired = true, EmitDefaultValue = true)]
        public ComparisonTypeEnum ComparisonType { get; set; }
        /// <summary>
        /// The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact
        /// </summary>
        /// <value>The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RuleTypeEnum
        {
            /// <summary>
            /// Enum ReconcileNumericRule for value: ReconcileNumericRule
            /// </summary>
            [EnumMember(Value = "ReconcileNumericRule")]
            ReconcileNumericRule = 1,

            /// <summary>
            /// Enum ReconcileDateTimeRule for value: ReconcileDateTimeRule
            /// </summary>
            [EnumMember(Value = "ReconcileDateTimeRule")]
            ReconcileDateTimeRule = 2,

            /// <summary>
            /// Enum ReconcileStringRule for value: ReconcileStringRule
            /// </summary>
            [EnumMember(Value = "ReconcileStringRule")]
            ReconcileStringRule = 3,

            /// <summary>
            /// Enum ReconcileExact for value: ReconcileExact
            /// </summary>
            [EnumMember(Value = "ReconcileExact")]
            ReconcileExact = 4

        }


        /// <summary>
        /// The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact
        /// </summary>
        /// <value>The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact</value>
        [DataMember(Name = "ruleType", IsRequired = true, EmitDefaultValue = true)]
        public RuleTypeEnum RuleType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileNumericRuleAllOf" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ReconcileNumericRuleAllOf() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReconcileNumericRuleAllOf" /> class.
        /// </summary>
        /// <param name="comparisonType">The available values are: Exact, AbsoluteDifference, RelativeDifference (required).</param>
        /// <param name="tolerance">For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction..</param>
        /// <param name="appliesTo">appliesTo (required).</param>
        /// <param name="ruleType">The available values are: ReconcileNumericRule, ReconcileDateTimeRule, ReconcileStringRule, ReconcileExact (required).</param>
        public ReconcileNumericRuleAllOf(ComparisonTypeEnum comparisonType = default(ComparisonTypeEnum), decimal tolerance = default(decimal), AggregateSpec appliesTo = default(AggregateSpec), RuleTypeEnum ruleType = default(RuleTypeEnum))
        {
            this.ComparisonType = comparisonType;
            // to ensure "appliesTo" is required (not null)
            if (appliesTo == null)
            {
                throw new ArgumentNullException("appliesTo is a required property for ReconcileNumericRuleAllOf and cannot be null");
            }
            this.AppliesTo = appliesTo;
            this.RuleType = ruleType;
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction.
        /// </summary>
        /// <value>For a numeric type only (i.e. decimal, integer, date or datetime offset possibly controversially), this is the quantity used in the comparison.  The units of the tolerance must be set appropriately for the item being compared.  For a number such as a currency or amount that will be a simple quantity, for a DateTime or DateTimeOffset it should be days. If fewer than a single day then this should be  passed as a fraction.</value>
        [DataMember(Name = "tolerance", EmitDefaultValue = false)]
        public decimal Tolerance { get; set; }

        /// <summary>
        /// Gets or Sets AppliesTo
        /// </summary>
        [DataMember(Name = "appliesTo", IsRequired = true, EmitDefaultValue = true)]
        public AggregateSpec AppliesTo { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ReconcileNumericRuleAllOf {\n");
            sb.Append("  ComparisonType: ").Append(ComparisonType).Append("\n");
            sb.Append("  Tolerance: ").Append(Tolerance).Append("\n");
            sb.Append("  AppliesTo: ").Append(AppliesTo).Append("\n");
            sb.Append("  RuleType: ").Append(RuleType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ReconcileNumericRuleAllOf);
        }

        /// <summary>
        /// Returns true if ReconcileNumericRuleAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of ReconcileNumericRuleAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReconcileNumericRuleAllOf input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ComparisonType == input.ComparisonType ||
                    this.ComparisonType.Equals(input.ComparisonType)
                ) && 
                (
                    this.Tolerance == input.Tolerance ||
                    this.Tolerance.Equals(input.Tolerance)
                ) && 
                (
                    this.AppliesTo == input.AppliesTo ||
                    (this.AppliesTo != null &&
                    this.AppliesTo.Equals(input.AppliesTo))
                ) && 
                (
                    this.RuleType == input.RuleType ||
                    this.RuleType.Equals(input.RuleType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.ComparisonType.GetHashCode();
                hashCode = (hashCode * 59) + this.Tolerance.GetHashCode();
                if (this.AppliesTo != null)
                {
                    hashCode = (hashCode * 59) + this.AppliesTo.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RuleType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
