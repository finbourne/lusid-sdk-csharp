/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// A BondConversionSchedule object represents a class containing the  information required for the creation of convertible features in a ComplexBond
    /// </summary>
    [DataContract(Name = "BondConversionSchedule")]
    [JsonConverter(typeof(JsonSubtypes), "ScheduleType")]
    public partial class BondConversionSchedule : Schedule, IEquatable<BondConversionSchedule>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BondConversionSchedule" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected BondConversionSchedule() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BondConversionSchedule" /> class.
        /// </summary>
        /// <param name="identifiers">The market identifier(s) of the share that the bond converts to. The instrument  will not fail validation if no identifier is supplied..</param>
        /// <param name="bondConversionEntries">The dates at which the bond may be converted and associated information required about the conversion..</param>
        /// <param name="conversionTrigger">Corporate event that triggers a conversion    Supported string (enumeration) values are: [NextEquityFinancing, IpoConversion, KnownDates, SoftCall]. (required).</param>
        /// <param name="deliveryType">Is a conversion made into cash or into shares?    Supported string (enumeration) values are: [Cash, Physical]..</param>
        /// <param name="exerciseType">The exercise type of the conversion schedule (American or European).  For American type, the bond is convertible from a given exercise date until the next date in the schedule, or until it matures.  For European type, the bond is only convertible on the given exercise date.    Supported string (enumeration) values are: [European, Bermudan, American]. (required).</param>
        /// <param name="includesAccrued">Set this to true if a accrued interest is included in the conversion. Defaults to true..</param>
        /// <param name="mandatoryConversion">Set this to true if a conversion is mandatory if the trigger occurs. Defaults to false..</param>
        /// <param name="notificationPeriodEnd">The last day in the notification period for the conversion of the bond.</param>
        /// <param name="notificationPeriodStart">The first day in the notification period for the conversion of the bond.</param>
        /// <param name="scheduleType">The available values are: FixedSchedule, FloatSchedule, OptionalitySchedule, StepSchedule, Exercise, FxRateSchedule, FxLinkedNotionalSchedule, BondConversionSchedule, Invalid (required) (default to &quot;BondConversionSchedule&quot;).</param>
        public BondConversionSchedule(Dictionary<string, string> identifiers = default(Dictionary<string, string>), List<BondConversionEntry> bondConversionEntries = default(List<BondConversionEntry>), string conversionTrigger = default(string), string deliveryType = default(string), string exerciseType = default(string), bool includesAccrued = default(bool), bool mandatoryConversion = default(bool), DateTimeOffset notificationPeriodEnd = default(DateTimeOffset), DateTimeOffset notificationPeriodStart = default(DateTimeOffset), ScheduleTypeEnum scheduleType = default(ScheduleTypeEnum)) : base(scheduleType)
        {
            // to ensure "conversionTrigger" is required (not null)
            if (conversionTrigger == null)
            {
                throw new ArgumentNullException("conversionTrigger is a required property for BondConversionSchedule and cannot be null");
            }
            this.ConversionTrigger = conversionTrigger;
            // to ensure "exerciseType" is required (not null)
            if (exerciseType == null)
            {
                throw new ArgumentNullException("exerciseType is a required property for BondConversionSchedule and cannot be null");
            }
            this.ExerciseType = exerciseType;
            this.Identifiers = identifiers;
            this.BondConversionEntries = bondConversionEntries;
            this.DeliveryType = deliveryType;
            this.IncludesAccrued = includesAccrued;
            this.MandatoryConversion = mandatoryConversion;
            this.NotificationPeriodEnd = notificationPeriodEnd;
            this.NotificationPeriodStart = notificationPeriodStart;
        }

        /// <summary>
        /// The market identifier(s) of the share that the bond converts to. The instrument  will not fail validation if no identifier is supplied.
        /// </summary>
        /// <value>The market identifier(s) of the share that the bond converts to. The instrument  will not fail validation if no identifier is supplied.</value>
        [DataMember(Name = "identifiers", EmitDefaultValue = true)]
        public Dictionary<string, string> Identifiers { get; set; }

        /// <summary>
        /// The dates at which the bond may be converted and associated information required about the conversion.
        /// </summary>
        /// <value>The dates at which the bond may be converted and associated information required about the conversion.</value>
        [DataMember(Name = "bondConversionEntries", EmitDefaultValue = true)]
        public List<BondConversionEntry> BondConversionEntries { get; set; }

        /// <summary>
        /// Corporate event that triggers a conversion    Supported string (enumeration) values are: [NextEquityFinancing, IpoConversion, KnownDates, SoftCall].
        /// </summary>
        /// <value>Corporate event that triggers a conversion    Supported string (enumeration) values are: [NextEquityFinancing, IpoConversion, KnownDates, SoftCall].</value>
        [DataMember(Name = "conversionTrigger", IsRequired = true, EmitDefaultValue = true)]
        public string ConversionTrigger { get; set; }

        /// <summary>
        /// Is a conversion made into cash or into shares?    Supported string (enumeration) values are: [Cash, Physical].
        /// </summary>
        /// <value>Is a conversion made into cash or into shares?    Supported string (enumeration) values are: [Cash, Physical].</value>
        [DataMember(Name = "deliveryType", EmitDefaultValue = true)]
        public string DeliveryType { get; set; }

        /// <summary>
        /// The exercise type of the conversion schedule (American or European).  For American type, the bond is convertible from a given exercise date until the next date in the schedule, or until it matures.  For European type, the bond is only convertible on the given exercise date.    Supported string (enumeration) values are: [European, Bermudan, American].
        /// </summary>
        /// <value>The exercise type of the conversion schedule (American or European).  For American type, the bond is convertible from a given exercise date until the next date in the schedule, or until it matures.  For European type, the bond is only convertible on the given exercise date.    Supported string (enumeration) values are: [European, Bermudan, American].</value>
        [DataMember(Name = "exerciseType", IsRequired = true, EmitDefaultValue = true)]
        public string ExerciseType { get; set; }

        /// <summary>
        /// Set this to true if a accrued interest is included in the conversion. Defaults to true.
        /// </summary>
        /// <value>Set this to true if a accrued interest is included in the conversion. Defaults to true.</value>
        [DataMember(Name = "includesAccrued", EmitDefaultValue = true)]
        public bool IncludesAccrued { get; set; }

        /// <summary>
        /// Set this to true if a conversion is mandatory if the trigger occurs. Defaults to false.
        /// </summary>
        /// <value>Set this to true if a conversion is mandatory if the trigger occurs. Defaults to false.</value>
        [DataMember(Name = "mandatoryConversion", EmitDefaultValue = true)]
        public bool MandatoryConversion { get; set; }

        /// <summary>
        /// The last day in the notification period for the conversion of the bond
        /// </summary>
        /// <value>The last day in the notification period for the conversion of the bond</value>
        [DataMember(Name = "notificationPeriodEnd", EmitDefaultValue = false)]
        public DateTimeOffset NotificationPeriodEnd { get; set; }

        /// <summary>
        /// The first day in the notification period for the conversion of the bond
        /// </summary>
        /// <value>The first day in the notification period for the conversion of the bond</value>
        [DataMember(Name = "notificationPeriodStart", EmitDefaultValue = false)]
        public DateTimeOffset NotificationPeriodStart { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class BondConversionSchedule {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  Identifiers: ").Append(Identifiers).Append("\n");
            sb.Append("  BondConversionEntries: ").Append(BondConversionEntries).Append("\n");
            sb.Append("  ConversionTrigger: ").Append(ConversionTrigger).Append("\n");
            sb.Append("  DeliveryType: ").Append(DeliveryType).Append("\n");
            sb.Append("  ExerciseType: ").Append(ExerciseType).Append("\n");
            sb.Append("  IncludesAccrued: ").Append(IncludesAccrued).Append("\n");
            sb.Append("  MandatoryConversion: ").Append(MandatoryConversion).Append("\n");
            sb.Append("  NotificationPeriodEnd: ").Append(NotificationPeriodEnd).Append("\n");
            sb.Append("  NotificationPeriodStart: ").Append(NotificationPeriodStart).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as BondConversionSchedule);
        }

        /// <summary>
        /// Returns true if BondConversionSchedule instances are equal
        /// </summary>
        /// <param name="input">Instance of BondConversionSchedule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BondConversionSchedule input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.Identifiers == input.Identifiers ||
                    this.Identifiers != null &&
                    input.Identifiers != null &&
                    this.Identifiers.SequenceEqual(input.Identifiers)
                ) && base.Equals(input) && 
                (
                    this.BondConversionEntries == input.BondConversionEntries ||
                    this.BondConversionEntries != null &&
                    input.BondConversionEntries != null &&
                    this.BondConversionEntries.SequenceEqual(input.BondConversionEntries)
                ) && base.Equals(input) && 
                (
                    this.ConversionTrigger == input.ConversionTrigger ||
                    (this.ConversionTrigger != null &&
                    this.ConversionTrigger.Equals(input.ConversionTrigger))
                ) && base.Equals(input) && 
                (
                    this.DeliveryType == input.DeliveryType ||
                    (this.DeliveryType != null &&
                    this.DeliveryType.Equals(input.DeliveryType))
                ) && base.Equals(input) && 
                (
                    this.ExerciseType == input.ExerciseType ||
                    (this.ExerciseType != null &&
                    this.ExerciseType.Equals(input.ExerciseType))
                ) && base.Equals(input) && 
                (
                    this.IncludesAccrued == input.IncludesAccrued ||
                    this.IncludesAccrued.Equals(input.IncludesAccrued)
                ) && base.Equals(input) && 
                (
                    this.MandatoryConversion == input.MandatoryConversion ||
                    this.MandatoryConversion.Equals(input.MandatoryConversion)
                ) && base.Equals(input) && 
                (
                    this.NotificationPeriodEnd == input.NotificationPeriodEnd ||
                    (this.NotificationPeriodEnd != null &&
                    this.NotificationPeriodEnd.Equals(input.NotificationPeriodEnd))
                ) && base.Equals(input) && 
                (
                    this.NotificationPeriodStart == input.NotificationPeriodStart ||
                    (this.NotificationPeriodStart != null &&
                    this.NotificationPeriodStart.Equals(input.NotificationPeriodStart))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.Identifiers != null)
                {
                    hashCode = (hashCode * 59) + this.Identifiers.GetHashCode();
                }
                if (this.BondConversionEntries != null)
                {
                    hashCode = (hashCode * 59) + this.BondConversionEntries.GetHashCode();
                }
                if (this.ConversionTrigger != null)
                {
                    hashCode = (hashCode * 59) + this.ConversionTrigger.GetHashCode();
                }
                if (this.DeliveryType != null)
                {
                    hashCode = (hashCode * 59) + this.DeliveryType.GetHashCode();
                }
                if (this.ExerciseType != null)
                {
                    hashCode = (hashCode * 59) + this.ExerciseType.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.IncludesAccrued.GetHashCode();
                hashCode = (hashCode * 59) + this.MandatoryConversion.GetHashCode();
                if (this.NotificationPeriodEnd != null)
                {
                    hashCode = (hashCode * 59) + this.NotificationPeriodEnd.GetHashCode();
                }
                if (this.NotificationPeriodStart != null)
                {
                    hashCode = (hashCode * 59) + this.NotificationPeriodStart.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // ConversionTrigger (string) maxLength
            if (this.ConversionTrigger != null && this.ConversionTrigger.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ConversionTrigger, length must be less than 50.", new [] { "ConversionTrigger" });
            }

            // ConversionTrigger (string) minLength
            if (this.ConversionTrigger != null && this.ConversionTrigger.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ConversionTrigger, length must be greater than 0.", new [] { "ConversionTrigger" });
            }

            // DeliveryType (string) maxLength
            if (this.DeliveryType != null && this.DeliveryType.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DeliveryType, length must be less than 50.", new [] { "DeliveryType" });
            }

            // DeliveryType (string) minLength
            if (this.DeliveryType != null && this.DeliveryType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DeliveryType, length must be greater than 0.", new [] { "DeliveryType" });
            }

            // ExerciseType (string) maxLength
            if (this.ExerciseType != null && this.ExerciseType.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExerciseType, length must be less than 50.", new [] { "ExerciseType" });
            }

            // ExerciseType (string) minLength
            if (this.ExerciseType != null && this.ExerciseType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExerciseType, length must be greater than 0.", new [] { "ExerciseType" });
            }

            yield break;
        }
    }
}
