/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// The request to create an instruction for an instrument event
    /// </summary>
    [DataContract(Name = "InstrumentEventInstructionRequest")]
    public partial class InstrumentEventInstructionRequest : IEquatable<InstrumentEventInstructionRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentEventInstructionRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected InstrumentEventInstructionRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentEventInstructionRequest" /> class.
        /// </summary>
        /// <param name="instrumentEventInstructionId">The unique identifier for this instruction (required).</param>
        /// <param name="instrumentEventId">The identifier of the instrument event being instructed (required).</param>
        /// <param name="instructionType">The type of instruction (Ignore, ElectForPortfolio, ElectForHolding, ElectForLoanFacilityHolding) (required).</param>
        /// <param name="electionKey">For elected instructions, the key to be chosen.</param>
        /// <param name="holdingId">For holding instructions, the id of the holding for which the instruction will apply.</param>
        /// <param name="entitlementDateInstructed">The instructed entitlement date for the event (where none is set on the event itself).</param>
        /// <param name="quantityInstructed">quantityInstructed.</param>
        /// <param name="taxLotId">For loan facility holding instructions, the tax lot id of the holding for which the instruction will apply.</param>
        /// <param name="ignoreCostImpact">For loan facility holding instructions, set this flag to &#39;true&#39; if you want the event to not impact cost. If you want to use this option, do not add multiple instructions to the same tax lot or you will get undefined behaviour..</param>
        public InstrumentEventInstructionRequest(string instrumentEventInstructionId = default(string), string instrumentEventId = default(string), string instructionType = default(string), string electionKey = default(string), long? holdingId = default(long?), DateTimeOffset? entitlementDateInstructed = default(DateTimeOffset?), QuantityInstructed quantityInstructed = default(QuantityInstructed), string taxLotId = default(string), bool ignoreCostImpact = default(bool))
        {
            // to ensure "instrumentEventInstructionId" is required (not null)
            if (instrumentEventInstructionId == null)
            {
                throw new ArgumentNullException("instrumentEventInstructionId is a required property for InstrumentEventInstructionRequest and cannot be null");
            }
            this.InstrumentEventInstructionId = instrumentEventInstructionId;
            // to ensure "instrumentEventId" is required (not null)
            if (instrumentEventId == null)
            {
                throw new ArgumentNullException("instrumentEventId is a required property for InstrumentEventInstructionRequest and cannot be null");
            }
            this.InstrumentEventId = instrumentEventId;
            // to ensure "instructionType" is required (not null)
            if (instructionType == null)
            {
                throw new ArgumentNullException("instructionType is a required property for InstrumentEventInstructionRequest and cannot be null");
            }
            this.InstructionType = instructionType;
            this.ElectionKey = electionKey;
            this.HoldingId = holdingId;
            this.EntitlementDateInstructed = entitlementDateInstructed;
            this.QuantityInstructed = quantityInstructed;
            this.TaxLotId = taxLotId;
            this.IgnoreCostImpact = ignoreCostImpact;
        }

        /// <summary>
        /// The unique identifier for this instruction
        /// </summary>
        /// <value>The unique identifier for this instruction</value>
        [DataMember(Name = "instrumentEventInstructionId", IsRequired = true, EmitDefaultValue = true)]
        public string InstrumentEventInstructionId { get; set; }

        /// <summary>
        /// The identifier of the instrument event being instructed
        /// </summary>
        /// <value>The identifier of the instrument event being instructed</value>
        [DataMember(Name = "instrumentEventId", IsRequired = true, EmitDefaultValue = true)]
        public string InstrumentEventId { get; set; }

        /// <summary>
        /// The type of instruction (Ignore, ElectForPortfolio, ElectForHolding, ElectForLoanFacilityHolding)
        /// </summary>
        /// <value>The type of instruction (Ignore, ElectForPortfolio, ElectForHolding, ElectForLoanFacilityHolding)</value>
        [DataMember(Name = "instructionType", IsRequired = true, EmitDefaultValue = true)]
        public string InstructionType { get; set; }

        /// <summary>
        /// For elected instructions, the key to be chosen
        /// </summary>
        /// <value>For elected instructions, the key to be chosen</value>
        [DataMember(Name = "electionKey", EmitDefaultValue = true)]
        public string ElectionKey { get; set; }

        /// <summary>
        /// For holding instructions, the id of the holding for which the instruction will apply
        /// </summary>
        /// <value>For holding instructions, the id of the holding for which the instruction will apply</value>
        [DataMember(Name = "holdingId", EmitDefaultValue = true)]
        public long? HoldingId { get; set; }

        /// <summary>
        /// The instructed entitlement date for the event (where none is set on the event itself)
        /// </summary>
        /// <value>The instructed entitlement date for the event (where none is set on the event itself)</value>
        [DataMember(Name = "entitlementDateInstructed", EmitDefaultValue = true)]
        public DateTimeOffset? EntitlementDateInstructed { get; set; }

        /// <summary>
        /// Gets or Sets QuantityInstructed
        /// </summary>
        [DataMember(Name = "quantityInstructed", EmitDefaultValue = false)]
        public QuantityInstructed QuantityInstructed { get; set; }

        /// <summary>
        /// For loan facility holding instructions, the tax lot id of the holding for which the instruction will apply
        /// </summary>
        /// <value>For loan facility holding instructions, the tax lot id of the holding for which the instruction will apply</value>
        [DataMember(Name = "taxLotId", EmitDefaultValue = true)]
        public string TaxLotId { get; set; }

        /// <summary>
        /// For loan facility holding instructions, set this flag to &#39;true&#39; if you want the event to not impact cost. If you want to use this option, do not add multiple instructions to the same tax lot or you will get undefined behaviour.
        /// </summary>
        /// <value>For loan facility holding instructions, set this flag to &#39;true&#39; if you want the event to not impact cost. If you want to use this option, do not add multiple instructions to the same tax lot or you will get undefined behaviour.</value>
        [DataMember(Name = "ignoreCostImpact", EmitDefaultValue = true)]
        public bool IgnoreCostImpact { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class InstrumentEventInstructionRequest {\n");
            sb.Append("  InstrumentEventInstructionId: ").Append(InstrumentEventInstructionId).Append("\n");
            sb.Append("  InstrumentEventId: ").Append(InstrumentEventId).Append("\n");
            sb.Append("  InstructionType: ").Append(InstructionType).Append("\n");
            sb.Append("  ElectionKey: ").Append(ElectionKey).Append("\n");
            sb.Append("  HoldingId: ").Append(HoldingId).Append("\n");
            sb.Append("  EntitlementDateInstructed: ").Append(EntitlementDateInstructed).Append("\n");
            sb.Append("  QuantityInstructed: ").Append(QuantityInstructed).Append("\n");
            sb.Append("  TaxLotId: ").Append(TaxLotId).Append("\n");
            sb.Append("  IgnoreCostImpact: ").Append(IgnoreCostImpact).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as InstrumentEventInstructionRequest);
        }

        /// <summary>
        /// Returns true if InstrumentEventInstructionRequest instances are equal
        /// </summary>
        /// <param name="input">Instance of InstrumentEventInstructionRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InstrumentEventInstructionRequest input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.InstrumentEventInstructionId == input.InstrumentEventInstructionId ||
                    (this.InstrumentEventInstructionId != null &&
                    this.InstrumentEventInstructionId.Equals(input.InstrumentEventInstructionId))
                ) && 
                (
                    this.InstrumentEventId == input.InstrumentEventId ||
                    (this.InstrumentEventId != null &&
                    this.InstrumentEventId.Equals(input.InstrumentEventId))
                ) && 
                (
                    this.InstructionType == input.InstructionType ||
                    (this.InstructionType != null &&
                    this.InstructionType.Equals(input.InstructionType))
                ) && 
                (
                    this.ElectionKey == input.ElectionKey ||
                    (this.ElectionKey != null &&
                    this.ElectionKey.Equals(input.ElectionKey))
                ) && 
                (
                    this.HoldingId == input.HoldingId ||
                    (this.HoldingId != null &&
                    this.HoldingId.Equals(input.HoldingId))
                ) && 
                (
                    this.EntitlementDateInstructed == input.EntitlementDateInstructed ||
                    (this.EntitlementDateInstructed != null &&
                    this.EntitlementDateInstructed.Equals(input.EntitlementDateInstructed))
                ) && 
                (
                    this.QuantityInstructed == input.QuantityInstructed ||
                    (this.QuantityInstructed != null &&
                    this.QuantityInstructed.Equals(input.QuantityInstructed))
                ) && 
                (
                    this.TaxLotId == input.TaxLotId ||
                    (this.TaxLotId != null &&
                    this.TaxLotId.Equals(input.TaxLotId))
                ) && 
                (
                    this.IgnoreCostImpact == input.IgnoreCostImpact ||
                    this.IgnoreCostImpact.Equals(input.IgnoreCostImpact)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.InstrumentEventInstructionId != null)
                {
                    hashCode = (hashCode * 59) + this.InstrumentEventInstructionId.GetHashCode();
                }
                if (this.InstrumentEventId != null)
                {
                    hashCode = (hashCode * 59) + this.InstrumentEventId.GetHashCode();
                }
                if (this.InstructionType != null)
                {
                    hashCode = (hashCode * 59) + this.InstructionType.GetHashCode();
                }
                if (this.ElectionKey != null)
                {
                    hashCode = (hashCode * 59) + this.ElectionKey.GetHashCode();
                }
                if (this.HoldingId != null)
                {
                    hashCode = (hashCode * 59) + this.HoldingId.GetHashCode();
                }
                if (this.EntitlementDateInstructed != null)
                {
                    hashCode = (hashCode * 59) + this.EntitlementDateInstructed.GetHashCode();
                }
                if (this.QuantityInstructed != null)
                {
                    hashCode = (hashCode * 59) + this.QuantityInstructed.GetHashCode();
                }
                if (this.TaxLotId != null)
                {
                    hashCode = (hashCode * 59) + this.TaxLotId.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.IgnoreCostImpact.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // InstrumentEventInstructionId (string) minLength
            if (this.InstrumentEventInstructionId != null && this.InstrumentEventInstructionId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for InstrumentEventInstructionId, length must be greater than 1.", new [] { "InstrumentEventInstructionId" });
            }

            // InstrumentEventId (string) minLength
            if (this.InstrumentEventId != null && this.InstrumentEventId.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for InstrumentEventId, length must be greater than 1.", new [] { "InstrumentEventId" });
            }

            // InstructionType (string) minLength
            if (this.InstructionType != null && this.InstructionType.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for InstructionType, length must be greater than 1.", new [] { "InstructionType" });
            }

            // TaxLotId (string) maxLength
            if (this.TaxLotId != null && this.TaxLotId.Length > 50)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TaxLotId, length must be less than 50.", new [] { "TaxLotId" });
            }

            // TaxLotId (string) minLength
            if (this.TaxLotId != null && this.TaxLotId.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TaxLotId, length must be greater than 0.", new [] { "TaxLotId" });
            }

            yield break;
        }
    }
}
