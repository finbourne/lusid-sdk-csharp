/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Schedule for floating rate coupon payments.
    /// </summary>
    [DataContract(Name = "FloatSchedule")]
    [JsonConverter(typeof(JsonSubtypes), "ScheduleType")]
    public partial class FloatSchedule : Schedule, IEquatable<FloatSchedule>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FloatSchedule" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FloatSchedule() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FloatSchedule" /> class.
        /// </summary>
        /// <param name="startDate">Date from which LUSID starts generating the payment schedule..</param>
        /// <param name="maturityDate">Last date of the payment generation schedule. May not necessarily be the maturity date  of the underlying instrument (e.g. in case the instrument has multiple payment schedules)..</param>
        /// <param name="flowConventions">flowConventions.</param>
        /// <param name="conventionName">conventionName.</param>
        /// <param name="exDividendDays">Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration..</param>
        /// <param name="indexConventionName">indexConventionName.</param>
        /// <param name="indexConventions">indexConventions.</param>
        /// <param name="notional">Scaling factor, the quantity outstanding on which the rate will be paid..</param>
        /// <param name="paymentCurrency">Payment currency. This does not have to be the same as the nominal bond or observation/reset currency. (required).</param>
        /// <param name="spread">Spread over floating rate given as a fraction..</param>
        /// <param name="stubType">When a payment schedule doesn&#39;t have regular payment intervals just because of the  first and/or last coupons of the schedule, we call those irregular coupons stubs.  This configuration specifies what type of stub is used when building the schedule  Supported values are:  None &#x3D; this is a regular payment schedule with no stubs. DO NOT use it with irregular schedules or you will get incorrect and unexpected behaviour.  ShortFront &#x3D; this is an irregular payment schedule where only the first coupon is irregular, and covers a payment period that is shorter than the regular payment period.  ShortBack &#x3D; this is an irregular payment schedule where only the last coupon is irregular, and covers a payment period that is shorter than the regular payment period.  LongFront &#x3D; this is an irregular payment schedule where only the first coupon is irregular, and covers a payment period that is longer than the regular payment period.  LongBack &#x3D; this is an irregular payment schedule where only the last coupon is irregular, and covers a payment period that is longer than the regular payment period.  Both &#x3D; this is an irregular payment schedule where both the first and the last coupons are irregular, and the length of these periods is calculated based on the first coupon payment date that should have been explicitly set..</param>
        /// <param name="exDividendConfiguration">exDividendConfiguration.</param>
        /// <param name="compounding">compounding.</param>
        /// <param name="resetConvention">Control how resets are generated relative to payment convention(s).    Supported string (enumeration) values are: [InAdvance, InArrears].  Defaults to \&quot;InAdvance\&quot; if not set..</param>
        /// <param name="useAnnualisedDirectRates">Flag indicating whether to use daily updated annualised interest  rates for calculating the accrued interest. Defaults to false..</param>
        /// <param name="capRate">The maximum floating rate which a cashflow can accrue..</param>
        /// <param name="floorRate">The minimum floating rate which a cashflow can accrue..</param>
        /// <param name="scheduleType">The available values are: FixedSchedule, FloatSchedule, OptionalitySchedule, StepSchedule, Exercise, FxRateSchedule, FxLinkedNotionalSchedule, BondConversionSchedule, Invalid (required) (default to &quot;FloatSchedule&quot;).</param>
        public FloatSchedule(DateTimeOffset startDate = default(DateTimeOffset), DateTimeOffset maturityDate = default(DateTimeOffset), FlowConventions flowConventions = default(FlowConventions), FlowConventionName conventionName = default(FlowConventionName), int? exDividendDays = default(int?), FlowConventionName indexConventionName = default(FlowConventionName), IndexConvention indexConventions = default(IndexConvention), decimal notional = default(decimal), string paymentCurrency = default(string), decimal spread = default(decimal), string stubType = default(string), ExDividendConfiguration exDividendConfiguration = default(ExDividendConfiguration), Compounding compounding = default(Compounding), string resetConvention = default(string), bool useAnnualisedDirectRates = default(bool), decimal? capRate = default(decimal?), decimal? floorRate = default(decimal?), ScheduleTypeEnum scheduleType = default(ScheduleTypeEnum)) : base(scheduleType)
        {
            // to ensure "paymentCurrency" is required (not null)
            if (paymentCurrency == null)
            {
                throw new ArgumentNullException("paymentCurrency is a required property for FloatSchedule and cannot be null");
            }
            this.PaymentCurrency = paymentCurrency;
            this.StartDate = startDate;
            this.MaturityDate = maturityDate;
            this.FlowConventions = flowConventions;
            this.ConventionName = conventionName;
            this.ExDividendDays = exDividendDays;
            this.IndexConventionName = indexConventionName;
            this.IndexConventions = indexConventions;
            this.Notional = notional;
            this.Spread = spread;
            this.StubType = stubType;
            this.ExDividendConfiguration = exDividendConfiguration;
            this.Compounding = compounding;
            this.ResetConvention = resetConvention;
            this.UseAnnualisedDirectRates = useAnnualisedDirectRates;
            this.CapRate = capRate;
            this.FloorRate = floorRate;
        }

        /// <summary>
        /// Date from which LUSID starts generating the payment schedule.
        /// </summary>
        /// <value>Date from which LUSID starts generating the payment schedule.</value>
        [DataMember(Name = "startDate", EmitDefaultValue = false)]
        public DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// Last date of the payment generation schedule. May not necessarily be the maturity date  of the underlying instrument (e.g. in case the instrument has multiple payment schedules).
        /// </summary>
        /// <value>Last date of the payment generation schedule. May not necessarily be the maturity date  of the underlying instrument (e.g. in case the instrument has multiple payment schedules).</value>
        [DataMember(Name = "maturityDate", EmitDefaultValue = false)]
        public DateTimeOffset MaturityDate { get; set; }

        /// <summary>
        /// Gets or Sets FlowConventions
        /// </summary>
        [DataMember(Name = "flowConventions", EmitDefaultValue = false)]
        public FlowConventions FlowConventions { get; set; }

        /// <summary>
        /// Gets or Sets ConventionName
        /// </summary>
        [DataMember(Name = "conventionName", EmitDefaultValue = false)]
        public FlowConventionName ConventionName { get; set; }

        /// <summary>
        /// Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration.
        /// </summary>
        /// <value>Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration.</value>
        [DataMember(Name = "exDividendDays", EmitDefaultValue = true)]
        public int? ExDividendDays { get; set; }

        /// <summary>
        /// Gets or Sets IndexConventionName
        /// </summary>
        [DataMember(Name = "indexConventionName", EmitDefaultValue = false)]
        public FlowConventionName IndexConventionName { get; set; }

        /// <summary>
        /// Gets or Sets IndexConventions
        /// </summary>
        [DataMember(Name = "indexConventions", EmitDefaultValue = false)]
        public IndexConvention IndexConventions { get; set; }

        /// <summary>
        /// Scaling factor, the quantity outstanding on which the rate will be paid.
        /// </summary>
        /// <value>Scaling factor, the quantity outstanding on which the rate will be paid.</value>
        [DataMember(Name = "notional", EmitDefaultValue = true)]
        public decimal Notional { get; set; }

        /// <summary>
        /// Payment currency. This does not have to be the same as the nominal bond or observation/reset currency.
        /// </summary>
        /// <value>Payment currency. This does not have to be the same as the nominal bond or observation/reset currency.</value>
        [DataMember(Name = "paymentCurrency", IsRequired = true, EmitDefaultValue = true)]
        public string PaymentCurrency { get; set; }

        /// <summary>
        /// Spread over floating rate given as a fraction.
        /// </summary>
        /// <value>Spread over floating rate given as a fraction.</value>
        [DataMember(Name = "spread", EmitDefaultValue = true)]
        public decimal Spread { get; set; }

        /// <summary>
        /// When a payment schedule doesn&#39;t have regular payment intervals just because of the  first and/or last coupons of the schedule, we call those irregular coupons stubs.  This configuration specifies what type of stub is used when building the schedule  Supported values are:  None &#x3D; this is a regular payment schedule with no stubs. DO NOT use it with irregular schedules or you will get incorrect and unexpected behaviour.  ShortFront &#x3D; this is an irregular payment schedule where only the first coupon is irregular, and covers a payment period that is shorter than the regular payment period.  ShortBack &#x3D; this is an irregular payment schedule where only the last coupon is irregular, and covers a payment period that is shorter than the regular payment period.  LongFront &#x3D; this is an irregular payment schedule where only the first coupon is irregular, and covers a payment period that is longer than the regular payment period.  LongBack &#x3D; this is an irregular payment schedule where only the last coupon is irregular, and covers a payment period that is longer than the regular payment period.  Both &#x3D; this is an irregular payment schedule where both the first and the last coupons are irregular, and the length of these periods is calculated based on the first coupon payment date that should have been explicitly set.
        /// </summary>
        /// <value>When a payment schedule doesn&#39;t have regular payment intervals just because of the  first and/or last coupons of the schedule, we call those irregular coupons stubs.  This configuration specifies what type of stub is used when building the schedule  Supported values are:  None &#x3D; this is a regular payment schedule with no stubs. DO NOT use it with irregular schedules or you will get incorrect and unexpected behaviour.  ShortFront &#x3D; this is an irregular payment schedule where only the first coupon is irregular, and covers a payment period that is shorter than the regular payment period.  ShortBack &#x3D; this is an irregular payment schedule where only the last coupon is irregular, and covers a payment period that is shorter than the regular payment period.  LongFront &#x3D; this is an irregular payment schedule where only the first coupon is irregular, and covers a payment period that is longer than the regular payment period.  LongBack &#x3D; this is an irregular payment schedule where only the last coupon is irregular, and covers a payment period that is longer than the regular payment period.  Both &#x3D; this is an irregular payment schedule where both the first and the last coupons are irregular, and the length of these periods is calculated based on the first coupon payment date that should have been explicitly set.</value>
        [DataMember(Name = "stubType", EmitDefaultValue = true)]
        public string StubType { get; set; }

        /// <summary>
        /// Gets or Sets ExDividendConfiguration
        /// </summary>
        [DataMember(Name = "exDividendConfiguration", EmitDefaultValue = false)]
        public ExDividendConfiguration ExDividendConfiguration { get; set; }

        /// <summary>
        /// Gets or Sets Compounding
        /// </summary>
        [DataMember(Name = "compounding", EmitDefaultValue = false)]
        public Compounding Compounding { get; set; }

        /// <summary>
        /// Control how resets are generated relative to payment convention(s).    Supported string (enumeration) values are: [InAdvance, InArrears].  Defaults to \&quot;InAdvance\&quot; if not set.
        /// </summary>
        /// <value>Control how resets are generated relative to payment convention(s).    Supported string (enumeration) values are: [InAdvance, InArrears].  Defaults to \&quot;InAdvance\&quot; if not set.</value>
        [DataMember(Name = "resetConvention", EmitDefaultValue = true)]
        public string ResetConvention { get; set; }

        /// <summary>
        /// Flag indicating whether to use daily updated annualised interest  rates for calculating the accrued interest. Defaults to false.
        /// </summary>
        /// <value>Flag indicating whether to use daily updated annualised interest  rates for calculating the accrued interest. Defaults to false.</value>
        [DataMember(Name = "useAnnualisedDirectRates", EmitDefaultValue = true)]
        public bool UseAnnualisedDirectRates { get; set; }

        /// <summary>
        /// The maximum floating rate which a cashflow can accrue.
        /// </summary>
        /// <value>The maximum floating rate which a cashflow can accrue.</value>
        [DataMember(Name = "capRate", EmitDefaultValue = true)]
        public decimal? CapRate { get; set; }

        /// <summary>
        /// The minimum floating rate which a cashflow can accrue.
        /// </summary>
        /// <value>The minimum floating rate which a cashflow can accrue.</value>
        [DataMember(Name = "floorRate", EmitDefaultValue = true)]
        public decimal? FloorRate { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FloatSchedule {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  MaturityDate: ").Append(MaturityDate).Append("\n");
            sb.Append("  FlowConventions: ").Append(FlowConventions).Append("\n");
            sb.Append("  ConventionName: ").Append(ConventionName).Append("\n");
            sb.Append("  ExDividendDays: ").Append(ExDividendDays).Append("\n");
            sb.Append("  IndexConventionName: ").Append(IndexConventionName).Append("\n");
            sb.Append("  IndexConventions: ").Append(IndexConventions).Append("\n");
            sb.Append("  Notional: ").Append(Notional).Append("\n");
            sb.Append("  PaymentCurrency: ").Append(PaymentCurrency).Append("\n");
            sb.Append("  Spread: ").Append(Spread).Append("\n");
            sb.Append("  StubType: ").Append(StubType).Append("\n");
            sb.Append("  ExDividendConfiguration: ").Append(ExDividendConfiguration).Append("\n");
            sb.Append("  Compounding: ").Append(Compounding).Append("\n");
            sb.Append("  ResetConvention: ").Append(ResetConvention).Append("\n");
            sb.Append("  UseAnnualisedDirectRates: ").Append(UseAnnualisedDirectRates).Append("\n");
            sb.Append("  CapRate: ").Append(CapRate).Append("\n");
            sb.Append("  FloorRate: ").Append(FloorRate).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FloatSchedule);
        }

        /// <summary>
        /// Returns true if FloatSchedule instances are equal
        /// </summary>
        /// <param name="input">Instance of FloatSchedule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FloatSchedule input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && base.Equals(input) && 
                (
                    this.MaturityDate == input.MaturityDate ||
                    (this.MaturityDate != null &&
                    this.MaturityDate.Equals(input.MaturityDate))
                ) && base.Equals(input) && 
                (
                    this.FlowConventions == input.FlowConventions ||
                    (this.FlowConventions != null &&
                    this.FlowConventions.Equals(input.FlowConventions))
                ) && base.Equals(input) && 
                (
                    this.ConventionName == input.ConventionName ||
                    (this.ConventionName != null &&
                    this.ConventionName.Equals(input.ConventionName))
                ) && base.Equals(input) && 
                (
                    this.ExDividendDays == input.ExDividendDays ||
                    (this.ExDividendDays != null &&
                    this.ExDividendDays.Equals(input.ExDividendDays))
                ) && base.Equals(input) && 
                (
                    this.IndexConventionName == input.IndexConventionName ||
                    (this.IndexConventionName != null &&
                    this.IndexConventionName.Equals(input.IndexConventionName))
                ) && base.Equals(input) && 
                (
                    this.IndexConventions == input.IndexConventions ||
                    (this.IndexConventions != null &&
                    this.IndexConventions.Equals(input.IndexConventions))
                ) && base.Equals(input) && 
                (
                    this.Notional == input.Notional ||
                    this.Notional.Equals(input.Notional)
                ) && base.Equals(input) && 
                (
                    this.PaymentCurrency == input.PaymentCurrency ||
                    (this.PaymentCurrency != null &&
                    this.PaymentCurrency.Equals(input.PaymentCurrency))
                ) && base.Equals(input) && 
                (
                    this.Spread == input.Spread ||
                    this.Spread.Equals(input.Spread)
                ) && base.Equals(input) && 
                (
                    this.StubType == input.StubType ||
                    (this.StubType != null &&
                    this.StubType.Equals(input.StubType))
                ) && base.Equals(input) && 
                (
                    this.ExDividendConfiguration == input.ExDividendConfiguration ||
                    (this.ExDividendConfiguration != null &&
                    this.ExDividendConfiguration.Equals(input.ExDividendConfiguration))
                ) && base.Equals(input) && 
                (
                    this.Compounding == input.Compounding ||
                    (this.Compounding != null &&
                    this.Compounding.Equals(input.Compounding))
                ) && base.Equals(input) && 
                (
                    this.ResetConvention == input.ResetConvention ||
                    (this.ResetConvention != null &&
                    this.ResetConvention.Equals(input.ResetConvention))
                ) && base.Equals(input) && 
                (
                    this.UseAnnualisedDirectRates == input.UseAnnualisedDirectRates ||
                    this.UseAnnualisedDirectRates.Equals(input.UseAnnualisedDirectRates)
                ) && base.Equals(input) && 
                (
                    this.CapRate == input.CapRate ||
                    (this.CapRate != null &&
                    this.CapRate.Equals(input.CapRate))
                ) && base.Equals(input) && 
                (
                    this.FloorRate == input.FloorRate ||
                    (this.FloorRate != null &&
                    this.FloorRate.Equals(input.FloorRate))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.StartDate != null)
                {
                    hashCode = (hashCode * 59) + this.StartDate.GetHashCode();
                }
                if (this.MaturityDate != null)
                {
                    hashCode = (hashCode * 59) + this.MaturityDate.GetHashCode();
                }
                if (this.FlowConventions != null)
                {
                    hashCode = (hashCode * 59) + this.FlowConventions.GetHashCode();
                }
                if (this.ConventionName != null)
                {
                    hashCode = (hashCode * 59) + this.ConventionName.GetHashCode();
                }
                if (this.ExDividendDays != null)
                {
                    hashCode = (hashCode * 59) + this.ExDividendDays.GetHashCode();
                }
                if (this.IndexConventionName != null)
                {
                    hashCode = (hashCode * 59) + this.IndexConventionName.GetHashCode();
                }
                if (this.IndexConventions != null)
                {
                    hashCode = (hashCode * 59) + this.IndexConventions.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Notional.GetHashCode();
                if (this.PaymentCurrency != null)
                {
                    hashCode = (hashCode * 59) + this.PaymentCurrency.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Spread.GetHashCode();
                if (this.StubType != null)
                {
                    hashCode = (hashCode * 59) + this.StubType.GetHashCode();
                }
                if (this.ExDividendConfiguration != null)
                {
                    hashCode = (hashCode * 59) + this.ExDividendConfiguration.GetHashCode();
                }
                if (this.Compounding != null)
                {
                    hashCode = (hashCode * 59) + this.Compounding.GetHashCode();
                }
                if (this.ResetConvention != null)
                {
                    hashCode = (hashCode * 59) + this.ResetConvention.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.UseAnnualisedDirectRates.GetHashCode();
                if (this.CapRate != null)
                {
                    hashCode = (hashCode * 59) + this.CapRate.GetHashCode();
                }
                if (this.FloorRate != null)
                {
                    hashCode = (hashCode * 59) + this.FloorRate.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // ResetConvention (string) maxLength
            if (this.ResetConvention != null && this.ResetConvention.Length > 16)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ResetConvention, length must be less than 16.", new [] { "ResetConvention" });
            }

            // ResetConvention (string) minLength
            if (this.ResetConvention != null && this.ResetConvention.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ResetConvention, length must be greater than 0.", new [] { "ResetConvention" });
            }

            yield break;
        }
    }
}
