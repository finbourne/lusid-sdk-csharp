/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Schedule to define fx conversion of cashflows on complex bonds. If an fx schedule is defined then  on payment schedule generation the coupon and principal payoffs will be wrapped in an fx rate payoff method.  Either the fx rate is predefined (fixed) or relies on fx resets (floating).  Used in representation of dual currency bond.
    /// </summary>
    [DataContract(Name = "FxRateSchedule")]
    [JsonConverter(typeof(JsonSubtypes), "ScheduleType")]
    public partial class FxRateSchedule : Schedule, IEquatable<FxRateSchedule>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FxRateSchedule" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FxRateSchedule() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FxRateSchedule" /> class.
        /// </summary>
        /// <param name="flowConventions">flowConventions.</param>
        /// <param name="fxConversionTypes">List of flags to indicate if coupon payments, principal payments or both are converted.</param>
        /// <param name="rate">FxRate used to convert payments. Assumed to be in units of the ToCurrency so conversion is paymentAmount x fxRate.</param>
        /// <param name="toCurrency">Currency that payments are converted to.</param>
        /// <param name="scheduleType">The available values are: FixedSchedule, FloatSchedule, OptionalitySchedule, StepSchedule, Exercise, FxRateSchedule, FxLinkedNotionalSchedule, Invalid (required) (default to &quot;FxRateSchedule&quot;).</param>
        public FxRateSchedule(FlowConventions flowConventions = default(FlowConventions), List<string> fxConversionTypes = default(List<string>), decimal rate = default(decimal), string toCurrency = default(string), ScheduleTypeEnum scheduleType = default(ScheduleTypeEnum)) : base(scheduleType)
        {
            this.FlowConventions = flowConventions;
            this.FxConversionTypes = fxConversionTypes;
            this.Rate = rate;
            this.ToCurrency = toCurrency;
        }

        /// <summary>
        /// Gets or Sets FlowConventions
        /// </summary>
        [DataMember(Name = "flowConventions", EmitDefaultValue = false)]
        public FlowConventions FlowConventions { get; set; }

        /// <summary>
        /// List of flags to indicate if coupon payments, principal payments or both are converted
        /// </summary>
        /// <value>List of flags to indicate if coupon payments, principal payments or both are converted</value>
        [DataMember(Name = "fxConversionTypes", EmitDefaultValue = true)]
        public List<string> FxConversionTypes { get; set; }

        /// <summary>
        /// FxRate used to convert payments. Assumed to be in units of the ToCurrency so conversion is paymentAmount x fxRate
        /// </summary>
        /// <value>FxRate used to convert payments. Assumed to be in units of the ToCurrency so conversion is paymentAmount x fxRate</value>
        [DataMember(Name = "rate", EmitDefaultValue = true)]
        public decimal Rate { get; set; }

        /// <summary>
        /// Currency that payments are converted to
        /// </summary>
        /// <value>Currency that payments are converted to</value>
        [DataMember(Name = "toCurrency", EmitDefaultValue = true)]
        public string ToCurrency { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FxRateSchedule {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  FlowConventions: ").Append(FlowConventions).Append("\n");
            sb.Append("  FxConversionTypes: ").Append(FxConversionTypes).Append("\n");
            sb.Append("  Rate: ").Append(Rate).Append("\n");
            sb.Append("  ToCurrency: ").Append(ToCurrency).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FxRateSchedule);
        }

        /// <summary>
        /// Returns true if FxRateSchedule instances are equal
        /// </summary>
        /// <param name="input">Instance of FxRateSchedule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FxRateSchedule input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.FlowConventions == input.FlowConventions ||
                    (this.FlowConventions != null &&
                    this.FlowConventions.Equals(input.FlowConventions))
                ) && base.Equals(input) && 
                (
                    this.FxConversionTypes == input.FxConversionTypes ||
                    this.FxConversionTypes != null &&
                    input.FxConversionTypes != null &&
                    this.FxConversionTypes.SequenceEqual(input.FxConversionTypes)
                ) && base.Equals(input) && 
                (
                    this.Rate == input.Rate ||
                    this.Rate.Equals(input.Rate)
                ) && base.Equals(input) && 
                (
                    this.ToCurrency == input.ToCurrency ||
                    (this.ToCurrency != null &&
                    this.ToCurrency.Equals(input.ToCurrency))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.FlowConventions != null)
                {
                    hashCode = (hashCode * 59) + this.FlowConventions.GetHashCode();
                }
                if (this.FxConversionTypes != null)
                {
                    hashCode = (hashCode * 59) + this.FxConversionTypes.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Rate.GetHashCode();
                if (this.ToCurrency != null)
                {
                    hashCode = (hashCode * 59) + this.ToCurrency.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            yield break;
        }
    }
}
