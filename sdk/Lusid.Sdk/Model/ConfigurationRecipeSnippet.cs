/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of &#39;parent&#39; recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.
    /// </summary>
    [DataContract(Name = "ConfigurationRecipeSnippet")]
    public partial class ConfigurationRecipeSnippet : IEquatable<ConfigurationRecipeSnippet>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigurationRecipeSnippet" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected ConfigurationRecipeSnippet() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigurationRecipeSnippet" /> class.
        /// </summary>
        /// <param name="scope">The scope used when updating or inserting the Configuration Recipe snippet (required).</param>
        /// <param name="code">User given string name (code) to identify the recipe. (required).</param>
        /// <param name="aggregationOptions">aggregationOptions.</param>
        /// <param name="modelRules">The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options..</param>
        /// <param name="pricingOptions">pricingOptions.</param>
        /// <param name="marketRules">The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible..</param>
        /// <param name="marketOptions">marketOptions.</param>
        /// <param name="recipe">recipe.</param>
        public ConfigurationRecipeSnippet(string scope = default(string), string code = default(string), AggregationOptions aggregationOptions = default(AggregationOptions), List<VendorModelRule> modelRules = default(List<VendorModelRule>), PricingOptions pricingOptions = default(PricingOptions), List<MarketDataKeyRule> marketRules = default(List<MarketDataKeyRule>), MarketOptions marketOptions = default(MarketOptions), ConfigurationRecipe recipe = default(ConfigurationRecipe))
        {
            // to ensure "scope" is required (not null)
            if (scope == null)
            {
                throw new ArgumentNullException("scope is a required property for ConfigurationRecipeSnippet and cannot be null");
            }
            this.Scope = scope;
            // to ensure "code" is required (not null)
            if (code == null)
            {
                throw new ArgumentNullException("code is a required property for ConfigurationRecipeSnippet and cannot be null");
            }
            this.Code = code;
            this.AggregationOptions = aggregationOptions;
            this.ModelRules = modelRules;
            this.PricingOptions = pricingOptions;
            this.MarketRules = marketRules;
            this.MarketOptions = marketOptions;
            this.Recipe = recipe;
        }

        /// <summary>
        /// The scope used when updating or inserting the Configuration Recipe snippet
        /// </summary>
        /// <value>The scope used when updating or inserting the Configuration Recipe snippet</value>
        [DataMember(Name = "scope", IsRequired = true, EmitDefaultValue = true)]
        public string Scope { get; set; }

        /// <summary>
        /// User given string name (code) to identify the recipe.
        /// </summary>
        /// <value>User given string name (code) to identify the recipe.</value>
        [DataMember(Name = "code", IsRequired = true, EmitDefaultValue = true)]
        public string Code { get; set; }

        /// <summary>
        /// Gets or Sets AggregationOptions
        /// </summary>
        [DataMember(Name = "aggregationOptions", EmitDefaultValue = false)]
        public AggregationOptions AggregationOptions { get; set; }

        /// <summary>
        /// The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.
        /// </summary>
        /// <value>The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.</value>
        [DataMember(Name = "modelRules", EmitDefaultValue = true)]
        public List<VendorModelRule> ModelRules { get; set; }

        /// <summary>
        /// Gets or Sets PricingOptions
        /// </summary>
        [DataMember(Name = "pricingOptions", EmitDefaultValue = false)]
        public PricingOptions PricingOptions { get; set; }

        /// <summary>
        /// The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.
        /// </summary>
        /// <value>The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.</value>
        [DataMember(Name = "marketRules", EmitDefaultValue = true)]
        public List<MarketDataKeyRule> MarketRules { get; set; }

        /// <summary>
        /// Gets or Sets MarketOptions
        /// </summary>
        [DataMember(Name = "marketOptions", EmitDefaultValue = false)]
        public MarketOptions MarketOptions { get; set; }

        /// <summary>
        /// Gets or Sets Recipe
        /// </summary>
        [DataMember(Name = "recipe", EmitDefaultValue = false)]
        public ConfigurationRecipe Recipe { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ConfigurationRecipeSnippet {\n");
            sb.Append("  Scope: ").Append(Scope).Append("\n");
            sb.Append("  Code: ").Append(Code).Append("\n");
            sb.Append("  AggregationOptions: ").Append(AggregationOptions).Append("\n");
            sb.Append("  ModelRules: ").Append(ModelRules).Append("\n");
            sb.Append("  PricingOptions: ").Append(PricingOptions).Append("\n");
            sb.Append("  MarketRules: ").Append(MarketRules).Append("\n");
            sb.Append("  MarketOptions: ").Append(MarketOptions).Append("\n");
            sb.Append("  Recipe: ").Append(Recipe).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ConfigurationRecipeSnippet);
        }

        /// <summary>
        /// Returns true if ConfigurationRecipeSnippet instances are equal
        /// </summary>
        /// <param name="input">Instance of ConfigurationRecipeSnippet to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ConfigurationRecipeSnippet input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Scope == input.Scope ||
                    (this.Scope != null &&
                    this.Scope.Equals(input.Scope))
                ) && 
                (
                    this.Code == input.Code ||
                    (this.Code != null &&
                    this.Code.Equals(input.Code))
                ) && 
                (
                    this.AggregationOptions == input.AggregationOptions ||
                    (this.AggregationOptions != null &&
                    this.AggregationOptions.Equals(input.AggregationOptions))
                ) && 
                (
                    this.ModelRules == input.ModelRules ||
                    this.ModelRules != null &&
                    input.ModelRules != null &&
                    this.ModelRules.SequenceEqual(input.ModelRules)
                ) && 
                (
                    this.PricingOptions == input.PricingOptions ||
                    (this.PricingOptions != null &&
                    this.PricingOptions.Equals(input.PricingOptions))
                ) && 
                (
                    this.MarketRules == input.MarketRules ||
                    this.MarketRules != null &&
                    input.MarketRules != null &&
                    this.MarketRules.SequenceEqual(input.MarketRules)
                ) && 
                (
                    this.MarketOptions == input.MarketOptions ||
                    (this.MarketOptions != null &&
                    this.MarketOptions.Equals(input.MarketOptions))
                ) && 
                (
                    this.Recipe == input.Recipe ||
                    (this.Recipe != null &&
                    this.Recipe.Equals(input.Recipe))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Scope != null)
                {
                    hashCode = (hashCode * 59) + this.Scope.GetHashCode();
                }
                if (this.Code != null)
                {
                    hashCode = (hashCode * 59) + this.Code.GetHashCode();
                }
                if (this.AggregationOptions != null)
                {
                    hashCode = (hashCode * 59) + this.AggregationOptions.GetHashCode();
                }
                if (this.ModelRules != null)
                {
                    hashCode = (hashCode * 59) + this.ModelRules.GetHashCode();
                }
                if (this.PricingOptions != null)
                {
                    hashCode = (hashCode * 59) + this.PricingOptions.GetHashCode();
                }
                if (this.MarketRules != null)
                {
                    hashCode = (hashCode * 59) + this.MarketRules.GetHashCode();
                }
                if (this.MarketOptions != null)
                {
                    hashCode = (hashCode * 59) + this.MarketOptions.GetHashCode();
                }
                if (this.Recipe != null)
                {
                    hashCode = (hashCode * 59) + this.Recipe.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Scope (string) maxLength
            if (this.Scope != null && this.Scope.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Scope, length must be less than 64.", new [] { "Scope" });
            }

            // Scope (string) minLength
            if (this.Scope != null && this.Scope.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Scope, length must be greater than 1.", new [] { "Scope" });
            }

            // Scope (string) pattern
            Regex regexScope = new Regex(@"^[a-zA-Z0-9\-_]+$", RegexOptions.CultureInvariant);
            if (false == regexScope.Match(this.Scope).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Scope, must match a pattern of " + regexScope, new [] { "Scope" });
            }

            // Code (string) maxLength
            if (this.Code != null && this.Code.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Code, length must be less than 64.", new [] { "Code" });
            }

            // Code (string) minLength
            if (this.Code != null && this.Code.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Code, length must be greater than 1.", new [] { "Code" });
            }

            // Code (string) pattern
            Regex regexCode = new Regex(@"^[a-zA-Z0-9\-_]+$", RegexOptions.CultureInvariant);
            if (false == regexCode.Match(this.Code).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Code, must match a pattern of " + regexCode, new [] { "Code" });
            }

            yield break;
        }
    }
}
