/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Lusid representation of a repurchase agreement, where one party sells some collateral and agrees to re-buy it at a later date for some given price.
    /// </summary>
    [DataContract(Name = "FlexibleRepo")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentType")]
    public partial class FlexibleRepo : LusidInstrument, IEquatable<FlexibleRepo>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FlexibleRepo" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FlexibleRepo() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FlexibleRepo" /> class.
        /// </summary>
        /// <param name="startDate">The start date of the instrument. This is normally synonymous with the trade-date. (required).</param>
        /// <param name="maturityDate">The maturity date of the instrument. This is the date at which the repurchase will occur for a TermRepo.  Optional for OpenRepo, but if not provided, defaults to the StartDate plus a long period (e.g. 2099-12-31)..</param>
        /// <param name="buyerOrSeller">Is the user the Buyer or the Seller of this repo?  Every repo agreement has two sides, a buyer and a seller.  The Buyer pays the PurchasePrice to the Seller in exchange for legal ownership of the collateral.  At Maturity, the Buyer then receives the RepurchasePrice in exchange for returning legal ownership of the collateral.  Controls the direction of purchase and repurchase cashflows, as well as the recipient of cashflows from the collateral.    Supported string (enumeration) values are: [Buyer, Seller]. (required).</param>
        /// <param name="repoCcy">Currency of the purchase and repurchase prices. May differ from the currencies on any collateral. (required).</param>
        /// <param name="repoType">The type of the repurchase agreement, Open or Term.  If Term, the repurchase automatically takes place at Maturity.  If Open, the agreement is rolled by the given tenor, and an interest cashflow is paid out with each roll,  unless manually triggered by a FlexibleRepoFullClosureEvent.    Supported string (enumeration) values are: [OpenRepo, TermRepo]. (required).</param>
        /// <param name="accrualBasis">For calculation of interest, the accrual day count to be used.  Required if no RepoRateSchedules are provided.  If both RepoRateSchedules and AccrualBasis are provided,  then AccrualBasis will take precedence.    Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM]..</param>
        /// <param name="collateral">collateral.</param>
        /// <param name="haircut">Haircut on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified..</param>
        /// <param name="margin">Initial margin on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified..</param>
        /// <param name="openRepoRollingPeriod">Required if the RepoType is Open.  The tenor representing the mandatory roll period if the FlexibleRepo is not manually matured.  If a user matures the FlexibleRepo via an instrument event, then the repurchase will delay until the end of this rolling period.  Generally this is set to 1D (one day), i.e. the repurchase will occur on the same day as the instrument event,  though any valid tenor is accepted with TenorUnit set to Day, Week, Month, or Year.  Note that TenorUnit T is not accepted here..</param>
        /// <param name="purchasePrice">The initial purchase price of the collateral.  If provided directly in this field, then Collateral.CollateralValue,  Haircut, and Margin should not be provided..</param>
        /// <param name="repoRateSchedules">Schedules used to calculate the repurchase price and any interest payments on the FlexibleRepo.  Only one schedule may be provided, and must be of type FixedSchedule or FloatSchedule.  If RepoType is OpenRepo, a FixedSchedule or FloatSchedule must be provided to calculate the expected Repo Rate,  and RepurchasePrice must be omitted.  If RepoType is TermRepo, only one of RepurchasePrice and RepoRateSchedules should be provided.  If a RepoRateSchedule is provided on a TermRepo, the PaymentFrequency in the FlowConventions should be 1T.  StubType must be set to None, and no ExDividend configuration should be provided..</param>
        /// <param name="repurchasePrice">The repurchase price of the repo, if known.  Only one of RepurchasePrice and RepoRateSchedules should be provided.  In the case of an OpenRepo, RepurchasePrice should not be provided,  and RepoRateSchedules should be provided instead in order to calculate the RepoRate..</param>
        /// <param name="timeZoneConventions">timeZoneConventions.</param>
        /// <param name="tradingConventions">tradingConventions.</param>
        /// <param name="isCollateralTransferActivated">Indicates whether the FlexibleRepoCollateralTransfer event is activated.  Determines the behavior of manufactured coupons and related boolean parameters.  Defaults to false.  When true:  - Generates the FlexibleRepoCollateralTransfer event  - Processes collateral transfer transactions into holding changes  - Generates manufactured payments when due to be paid                When false:  - Does not generate the event  - Generates manufactured payments when due to be received.</param>
        /// <param name="instrumentType">The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap, InflationLeg, FundShareClass, FlexibleLoan, UnsettledCash, Cash, MasteredInstrument, LoanFacility, FlexibleDeposit, FlexibleRepo (required) (default to &quot;FlexibleRepo&quot;).</param>
        public FlexibleRepo(DateTimeOffset startDate = default(DateTimeOffset), DateTimeOffset? maturityDate = default(DateTimeOffset?), string buyerOrSeller = default(string), string repoCcy = default(string), string repoType = default(string), string accrualBasis = default(string), Collateral collateral = default(Collateral), decimal? haircut = default(decimal?), decimal? margin = default(decimal?), string openRepoRollingPeriod = default(string), decimal? purchasePrice = default(decimal?), List<Schedule> repoRateSchedules = default(List<Schedule>), decimal? repurchasePrice = default(decimal?), TimeZoneConventions timeZoneConventions = default(TimeZoneConventions), TradingConventions tradingConventions = default(TradingConventions), bool isCollateralTransferActivated = default(bool), InstrumentTypeEnum instrumentType = default(InstrumentTypeEnum)) : base(instrumentType)
        {
            this.StartDate = startDate;
            // to ensure "buyerOrSeller" is required (not null)
            if (buyerOrSeller == null)
            {
                throw new ArgumentNullException("buyerOrSeller is a required property for FlexibleRepo and cannot be null");
            }
            this.BuyerOrSeller = buyerOrSeller;
            // to ensure "repoCcy" is required (not null)
            if (repoCcy == null)
            {
                throw new ArgumentNullException("repoCcy is a required property for FlexibleRepo and cannot be null");
            }
            this.RepoCcy = repoCcy;
            // to ensure "repoType" is required (not null)
            if (repoType == null)
            {
                throw new ArgumentNullException("repoType is a required property for FlexibleRepo and cannot be null");
            }
            this.RepoType = repoType;
            this.MaturityDate = maturityDate;
            this.AccrualBasis = accrualBasis;
            this.Collateral = collateral;
            this.Haircut = haircut;
            this.Margin = margin;
            this.OpenRepoRollingPeriod = openRepoRollingPeriod;
            this.PurchasePrice = purchasePrice;
            this.RepoRateSchedules = repoRateSchedules;
            this.RepurchasePrice = repurchasePrice;
            this.TimeZoneConventions = timeZoneConventions;
            this.TradingConventions = tradingConventions;
            this.IsCollateralTransferActivated = isCollateralTransferActivated;
        }

        /// <summary>
        /// The start date of the instrument. This is normally synonymous with the trade-date.
        /// </summary>
        /// <value>The start date of the instrument. This is normally synonymous with the trade-date.</value>
        [DataMember(Name = "startDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// The maturity date of the instrument. This is the date at which the repurchase will occur for a TermRepo.  Optional for OpenRepo, but if not provided, defaults to the StartDate plus a long period (e.g. 2099-12-31).
        /// </summary>
        /// <value>The maturity date of the instrument. This is the date at which the repurchase will occur for a TermRepo.  Optional for OpenRepo, but if not provided, defaults to the StartDate plus a long period (e.g. 2099-12-31).</value>
        [DataMember(Name = "maturityDate", EmitDefaultValue = true)]
        public DateTimeOffset? MaturityDate { get; set; }

        /// <summary>
        /// Is the user the Buyer or the Seller of this repo?  Every repo agreement has two sides, a buyer and a seller.  The Buyer pays the PurchasePrice to the Seller in exchange for legal ownership of the collateral.  At Maturity, the Buyer then receives the RepurchasePrice in exchange for returning legal ownership of the collateral.  Controls the direction of purchase and repurchase cashflows, as well as the recipient of cashflows from the collateral.    Supported string (enumeration) values are: [Buyer, Seller].
        /// </summary>
        /// <value>Is the user the Buyer or the Seller of this repo?  Every repo agreement has two sides, a buyer and a seller.  The Buyer pays the PurchasePrice to the Seller in exchange for legal ownership of the collateral.  At Maturity, the Buyer then receives the RepurchasePrice in exchange for returning legal ownership of the collateral.  Controls the direction of purchase and repurchase cashflows, as well as the recipient of cashflows from the collateral.    Supported string (enumeration) values are: [Buyer, Seller].</value>
        [DataMember(Name = "buyerOrSeller", IsRequired = true, EmitDefaultValue = true)]
        public string BuyerOrSeller { get; set; }

        /// <summary>
        /// Currency of the purchase and repurchase prices. May differ from the currencies on any collateral.
        /// </summary>
        /// <value>Currency of the purchase and repurchase prices. May differ from the currencies on any collateral.</value>
        [DataMember(Name = "repoCcy", IsRequired = true, EmitDefaultValue = true)]
        public string RepoCcy { get; set; }

        /// <summary>
        /// The type of the repurchase agreement, Open or Term.  If Term, the repurchase automatically takes place at Maturity.  If Open, the agreement is rolled by the given tenor, and an interest cashflow is paid out with each roll,  unless manually triggered by a FlexibleRepoFullClosureEvent.    Supported string (enumeration) values are: [OpenRepo, TermRepo].
        /// </summary>
        /// <value>The type of the repurchase agreement, Open or Term.  If Term, the repurchase automatically takes place at Maturity.  If Open, the agreement is rolled by the given tenor, and an interest cashflow is paid out with each roll,  unless manually triggered by a FlexibleRepoFullClosureEvent.    Supported string (enumeration) values are: [OpenRepo, TermRepo].</value>
        [DataMember(Name = "repoType", IsRequired = true, EmitDefaultValue = true)]
        public string RepoType { get; set; }

        /// <summary>
        /// For calculation of interest, the accrual day count to be used.  Required if no RepoRateSchedules are provided.  If both RepoRateSchedules and AccrualBasis are provided,  then AccrualBasis will take precedence.    Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].
        /// </summary>
        /// <value>For calculation of interest, the accrual day count to be used.  Required if no RepoRateSchedules are provided.  If both RepoRateSchedules and AccrualBasis are provided,  then AccrualBasis will take precedence.    Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].</value>
        [DataMember(Name = "accrualBasis", EmitDefaultValue = true)]
        public string AccrualBasis { get; set; }

        /// <summary>
        /// Gets or Sets Collateral
        /// </summary>
        [DataMember(Name = "collateral", EmitDefaultValue = false)]
        public Collateral Collateral { get; set; }

        /// <summary>
        /// Haircut on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified.
        /// </summary>
        /// <value>Haircut on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified.</value>
        [DataMember(Name = "haircut", EmitDefaultValue = true)]
        public decimal? Haircut { get; set; }

        /// <summary>
        /// Initial margin on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified.
        /// </summary>
        /// <value>Initial margin on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified.</value>
        [DataMember(Name = "margin", EmitDefaultValue = true)]
        public decimal? Margin { get; set; }

        /// <summary>
        /// Required if the RepoType is Open.  The tenor representing the mandatory roll period if the FlexibleRepo is not manually matured.  If a user matures the FlexibleRepo via an instrument event, then the repurchase will delay until the end of this rolling period.  Generally this is set to 1D (one day), i.e. the repurchase will occur on the same day as the instrument event,  though any valid tenor is accepted with TenorUnit set to Day, Week, Month, or Year.  Note that TenorUnit T is not accepted here.
        /// </summary>
        /// <value>Required if the RepoType is Open.  The tenor representing the mandatory roll period if the FlexibleRepo is not manually matured.  If a user matures the FlexibleRepo via an instrument event, then the repurchase will delay until the end of this rolling period.  Generally this is set to 1D (one day), i.e. the repurchase will occur on the same day as the instrument event,  though any valid tenor is accepted with TenorUnit set to Day, Week, Month, or Year.  Note that TenorUnit T is not accepted here.</value>
        [DataMember(Name = "openRepoRollingPeriod", EmitDefaultValue = true)]
        public string OpenRepoRollingPeriod { get; set; }

        /// <summary>
        /// The initial purchase price of the collateral.  If provided directly in this field, then Collateral.CollateralValue,  Haircut, and Margin should not be provided.
        /// </summary>
        /// <value>The initial purchase price of the collateral.  If provided directly in this field, then Collateral.CollateralValue,  Haircut, and Margin should not be provided.</value>
        [DataMember(Name = "purchasePrice", EmitDefaultValue = true)]
        public decimal? PurchasePrice { get; set; }

        /// <summary>
        /// Schedules used to calculate the repurchase price and any interest payments on the FlexibleRepo.  Only one schedule may be provided, and must be of type FixedSchedule or FloatSchedule.  If RepoType is OpenRepo, a FixedSchedule or FloatSchedule must be provided to calculate the expected Repo Rate,  and RepurchasePrice must be omitted.  If RepoType is TermRepo, only one of RepurchasePrice and RepoRateSchedules should be provided.  If a RepoRateSchedule is provided on a TermRepo, the PaymentFrequency in the FlowConventions should be 1T.  StubType must be set to None, and no ExDividend configuration should be provided.
        /// </summary>
        /// <value>Schedules used to calculate the repurchase price and any interest payments on the FlexibleRepo.  Only one schedule may be provided, and must be of type FixedSchedule or FloatSchedule.  If RepoType is OpenRepo, a FixedSchedule or FloatSchedule must be provided to calculate the expected Repo Rate,  and RepurchasePrice must be omitted.  If RepoType is TermRepo, only one of RepurchasePrice and RepoRateSchedules should be provided.  If a RepoRateSchedule is provided on a TermRepo, the PaymentFrequency in the FlowConventions should be 1T.  StubType must be set to None, and no ExDividend configuration should be provided.</value>
        [DataMember(Name = "repoRateSchedules", EmitDefaultValue = true)]
        public List<Schedule> RepoRateSchedules { get; set; }

        /// <summary>
        /// The repurchase price of the repo, if known.  Only one of RepurchasePrice and RepoRateSchedules should be provided.  In the case of an OpenRepo, RepurchasePrice should not be provided,  and RepoRateSchedules should be provided instead in order to calculate the RepoRate.
        /// </summary>
        /// <value>The repurchase price of the repo, if known.  Only one of RepurchasePrice and RepoRateSchedules should be provided.  In the case of an OpenRepo, RepurchasePrice should not be provided,  and RepoRateSchedules should be provided instead in order to calculate the RepoRate.</value>
        [DataMember(Name = "repurchasePrice", EmitDefaultValue = true)]
        public decimal? RepurchasePrice { get; set; }

        /// <summary>
        /// Gets or Sets TimeZoneConventions
        /// </summary>
        [DataMember(Name = "timeZoneConventions", EmitDefaultValue = false)]
        public TimeZoneConventions TimeZoneConventions { get; set; }

        /// <summary>
        /// Gets or Sets TradingConventions
        /// </summary>
        [DataMember(Name = "tradingConventions", EmitDefaultValue = false)]
        public TradingConventions TradingConventions { get; set; }

        /// <summary>
        /// Indicates whether the FlexibleRepoCollateralTransfer event is activated.  Determines the behavior of manufactured coupons and related boolean parameters.  Defaults to false.  When true:  - Generates the FlexibleRepoCollateralTransfer event  - Processes collateral transfer transactions into holding changes  - Generates manufactured payments when due to be paid                When false:  - Does not generate the event  - Generates manufactured payments when due to be received
        /// </summary>
        /// <value>Indicates whether the FlexibleRepoCollateralTransfer event is activated.  Determines the behavior of manufactured coupons and related boolean parameters.  Defaults to false.  When true:  - Generates the FlexibleRepoCollateralTransfer event  - Processes collateral transfer transactions into holding changes  - Generates manufactured payments when due to be paid                When false:  - Does not generate the event  - Generates manufactured payments when due to be received</value>
        [DataMember(Name = "isCollateralTransferActivated", EmitDefaultValue = true)]
        public bool IsCollateralTransferActivated { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FlexibleRepo {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  MaturityDate: ").Append(MaturityDate).Append("\n");
            sb.Append("  BuyerOrSeller: ").Append(BuyerOrSeller).Append("\n");
            sb.Append("  RepoCcy: ").Append(RepoCcy).Append("\n");
            sb.Append("  RepoType: ").Append(RepoType).Append("\n");
            sb.Append("  AccrualBasis: ").Append(AccrualBasis).Append("\n");
            sb.Append("  Collateral: ").Append(Collateral).Append("\n");
            sb.Append("  Haircut: ").Append(Haircut).Append("\n");
            sb.Append("  Margin: ").Append(Margin).Append("\n");
            sb.Append("  OpenRepoRollingPeriod: ").Append(OpenRepoRollingPeriod).Append("\n");
            sb.Append("  PurchasePrice: ").Append(PurchasePrice).Append("\n");
            sb.Append("  RepoRateSchedules: ").Append(RepoRateSchedules).Append("\n");
            sb.Append("  RepurchasePrice: ").Append(RepurchasePrice).Append("\n");
            sb.Append("  TimeZoneConventions: ").Append(TimeZoneConventions).Append("\n");
            sb.Append("  TradingConventions: ").Append(TradingConventions).Append("\n");
            sb.Append("  IsCollateralTransferActivated: ").Append(IsCollateralTransferActivated).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FlexibleRepo);
        }

        /// <summary>
        /// Returns true if FlexibleRepo instances are equal
        /// </summary>
        /// <param name="input">Instance of FlexibleRepo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FlexibleRepo input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && base.Equals(input) && 
                (
                    this.MaturityDate == input.MaturityDate ||
                    (this.MaturityDate != null &&
                    this.MaturityDate.Equals(input.MaturityDate))
                ) && base.Equals(input) && 
                (
                    this.BuyerOrSeller == input.BuyerOrSeller ||
                    (this.BuyerOrSeller != null &&
                    this.BuyerOrSeller.Equals(input.BuyerOrSeller))
                ) && base.Equals(input) && 
                (
                    this.RepoCcy == input.RepoCcy ||
                    (this.RepoCcy != null &&
                    this.RepoCcy.Equals(input.RepoCcy))
                ) && base.Equals(input) && 
                (
                    this.RepoType == input.RepoType ||
                    (this.RepoType != null &&
                    this.RepoType.Equals(input.RepoType))
                ) && base.Equals(input) && 
                (
                    this.AccrualBasis == input.AccrualBasis ||
                    (this.AccrualBasis != null &&
                    this.AccrualBasis.Equals(input.AccrualBasis))
                ) && base.Equals(input) && 
                (
                    this.Collateral == input.Collateral ||
                    (this.Collateral != null &&
                    this.Collateral.Equals(input.Collateral))
                ) && base.Equals(input) && 
                (
                    this.Haircut == input.Haircut ||
                    (this.Haircut != null &&
                    this.Haircut.Equals(input.Haircut))
                ) && base.Equals(input) && 
                (
                    this.Margin == input.Margin ||
                    (this.Margin != null &&
                    this.Margin.Equals(input.Margin))
                ) && base.Equals(input) && 
                (
                    this.OpenRepoRollingPeriod == input.OpenRepoRollingPeriod ||
                    (this.OpenRepoRollingPeriod != null &&
                    this.OpenRepoRollingPeriod.Equals(input.OpenRepoRollingPeriod))
                ) && base.Equals(input) && 
                (
                    this.PurchasePrice == input.PurchasePrice ||
                    (this.PurchasePrice != null &&
                    this.PurchasePrice.Equals(input.PurchasePrice))
                ) && base.Equals(input) && 
                (
                    this.RepoRateSchedules == input.RepoRateSchedules ||
                    this.RepoRateSchedules != null &&
                    input.RepoRateSchedules != null &&
                    this.RepoRateSchedules.SequenceEqual(input.RepoRateSchedules)
                ) && base.Equals(input) && 
                (
                    this.RepurchasePrice == input.RepurchasePrice ||
                    (this.RepurchasePrice != null &&
                    this.RepurchasePrice.Equals(input.RepurchasePrice))
                ) && base.Equals(input) && 
                (
                    this.TimeZoneConventions == input.TimeZoneConventions ||
                    (this.TimeZoneConventions != null &&
                    this.TimeZoneConventions.Equals(input.TimeZoneConventions))
                ) && base.Equals(input) && 
                (
                    this.TradingConventions == input.TradingConventions ||
                    (this.TradingConventions != null &&
                    this.TradingConventions.Equals(input.TradingConventions))
                ) && base.Equals(input) && 
                (
                    this.IsCollateralTransferActivated == input.IsCollateralTransferActivated ||
                    this.IsCollateralTransferActivated.Equals(input.IsCollateralTransferActivated)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.StartDate != null)
                {
                    hashCode = (hashCode * 59) + this.StartDate.GetHashCode();
                }
                if (this.MaturityDate != null)
                {
                    hashCode = (hashCode * 59) + this.MaturityDate.GetHashCode();
                }
                if (this.BuyerOrSeller != null)
                {
                    hashCode = (hashCode * 59) + this.BuyerOrSeller.GetHashCode();
                }
                if (this.RepoCcy != null)
                {
                    hashCode = (hashCode * 59) + this.RepoCcy.GetHashCode();
                }
                if (this.RepoType != null)
                {
                    hashCode = (hashCode * 59) + this.RepoType.GetHashCode();
                }
                if (this.AccrualBasis != null)
                {
                    hashCode = (hashCode * 59) + this.AccrualBasis.GetHashCode();
                }
                if (this.Collateral != null)
                {
                    hashCode = (hashCode * 59) + this.Collateral.GetHashCode();
                }
                if (this.Haircut != null)
                {
                    hashCode = (hashCode * 59) + this.Haircut.GetHashCode();
                }
                if (this.Margin != null)
                {
                    hashCode = (hashCode * 59) + this.Margin.GetHashCode();
                }
                if (this.OpenRepoRollingPeriod != null)
                {
                    hashCode = (hashCode * 59) + this.OpenRepoRollingPeriod.GetHashCode();
                }
                if (this.PurchasePrice != null)
                {
                    hashCode = (hashCode * 59) + this.PurchasePrice.GetHashCode();
                }
                if (this.RepoRateSchedules != null)
                {
                    hashCode = (hashCode * 59) + this.RepoRateSchedules.GetHashCode();
                }
                if (this.RepurchasePrice != null)
                {
                    hashCode = (hashCode * 59) + this.RepurchasePrice.GetHashCode();
                }
                if (this.TimeZoneConventions != null)
                {
                    hashCode = (hashCode * 59) + this.TimeZoneConventions.GetHashCode();
                }
                if (this.TradingConventions != null)
                {
                    hashCode = (hashCode * 59) + this.TradingConventions.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.IsCollateralTransferActivated.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // BuyerOrSeller (string) minLength
            if (this.BuyerOrSeller != null && this.BuyerOrSeller.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for BuyerOrSeller, length must be greater than 1.", new [] { "BuyerOrSeller" });
            }

            // RepoType (string) minLength
            if (this.RepoType != null && this.RepoType.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RepoType, length must be greater than 1.", new [] { "RepoType" });
            }

            yield break;
        }
    }
}
