/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Base class for representing market data options in LUSID. Abstractly, these are any options that one should be able to specify for ComplexMarketData entities. For example, CurveOptions allows one to decide how the data provided in a discountFactorCurve is interpolated. This base class should not be directly instantiated; each supported MarketDataOptionsType has a corresponding inherited class.
    /// </summary>
    [DataContract(Name = "MarketDataOptions")]
    [JsonConverter(typeof(JsonSubtypes), "MarketDataOptionsType")]
    [JsonSubtypes.KnownSubType(typeof(CurveOptions), "CurveOptions")]
    public partial class MarketDataOptions : IEquatable<MarketDataOptions>, IValidatableObject
    {
        /// <summary>
        /// The available values are: CurveOptions
        /// </summary>
        /// <value>The available values are: CurveOptions</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum MarketDataOptionsTypeEnum
        {
            /// <summary>
            /// Enum CurveOptions for value: CurveOptions
            /// </summary>
            [EnumMember(Value = "CurveOptions")]
            CurveOptions = 1
        }


        /// <summary>
        /// The available values are: CurveOptions
        /// </summary>
        /// <value>The available values are: CurveOptions</value>
        [DataMember(Name = "marketDataOptionsType", IsRequired = true, EmitDefaultValue = true)]
        public MarketDataOptionsTypeEnum MarketDataOptionsType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="MarketDataOptions" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected MarketDataOptions() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MarketDataOptions" /> class.
        /// </summary>
        /// <param name="marketDataOptionsType">The available values are: CurveOptions (required).</param>
        public MarketDataOptions(MarketDataOptionsTypeEnum marketDataOptionsType = default(MarketDataOptionsTypeEnum))
        {
            this.MarketDataOptionsType = marketDataOptionsType;
        }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MarketDataOptions {\n");
            sb.Append("  MarketDataOptionsType: ").Append(MarketDataOptionsType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MarketDataOptions);
        }

        /// <summary>
        /// Returns true if MarketDataOptions instances are equal
        /// </summary>
        /// <param name="input">Instance of MarketDataOptions to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MarketDataOptions input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.MarketDataOptionsType == input.MarketDataOptionsType ||
                    this.MarketDataOptionsType.Equals(input.MarketDataOptionsType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.MarketDataOptionsType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
