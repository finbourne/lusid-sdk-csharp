/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// A representation of an un-built piece of complex market data, to allow for passing through to the vendor library for building. The market data will usually be in some standard form such as XML or Json, representing a curve or surface.
    /// </summary>
    [DataContract(Name = "OpaqueMarketData")]
    [JsonConverter(typeof(JsonSubtypes), "MarketDataType")]
    public partial class OpaqueMarketData : ComplexMarketData, IEquatable<OpaqueMarketData>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OpaqueMarketData" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected OpaqueMarketData() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OpaqueMarketData" /> class.
        /// </summary>
        /// <param name="document">The document as a string. (required).</param>
        /// <param name="format">What format is the document stored in, e.g. Xml. Supported string (enumeration) values are: [Unknown, Xml, Json, Csv]. (required).</param>
        /// <param name="name">Internal name of document. This is not used for search, it is simply a designator that helps identify the document and could be anything (filename, ftp address or similar) (required).</param>
        /// <param name="lineage">Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;..</param>
        /// <param name="marketDataType">The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData, ConstantVolatilitySurface (required) (default to &quot;OpaqueMarketData&quot;).</param>
        public OpaqueMarketData(string document = default(string), string format = default(string), string name = default(string), string lineage = default(string), MarketDataTypeEnum marketDataType = default(MarketDataTypeEnum)) : base(marketDataType)
        {
            // to ensure "document" is required (not null)
            if (document == null)
            {
                throw new ArgumentNullException("document is a required property for OpaqueMarketData and cannot be null");
            }
            this.Document = document;
            // to ensure "format" is required (not null)
            if (format == null)
            {
                throw new ArgumentNullException("format is a required property for OpaqueMarketData and cannot be null");
            }
            this.Format = format;
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new ArgumentNullException("name is a required property for OpaqueMarketData and cannot be null");
            }
            this.Name = name;
            this.Lineage = lineage;
        }

        /// <summary>
        /// The document as a string.
        /// </summary>
        /// <value>The document as a string.</value>
        [DataMember(Name = "document", IsRequired = true, EmitDefaultValue = true)]
        public string Document { get; set; }

        /// <summary>
        /// What format is the document stored in, e.g. Xml. Supported string (enumeration) values are: [Unknown, Xml, Json, Csv].
        /// </summary>
        /// <value>What format is the document stored in, e.g. Xml. Supported string (enumeration) values are: [Unknown, Xml, Json, Csv].</value>
        [DataMember(Name = "format", IsRequired = true, EmitDefaultValue = true)]
        public string Format { get; set; }

        /// <summary>
        /// Internal name of document. This is not used for search, it is simply a designator that helps identify the document and could be anything (filename, ftp address or similar)
        /// </summary>
        /// <value>Internal name of document. This is not used for search, it is simply a designator that helps identify the document and could be anything (filename, ftp address or similar)</value>
        [DataMember(Name = "name", IsRequired = true, EmitDefaultValue = true)]
        public string Name { get; set; }

        /// <summary>
        /// Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.
        /// </summary>
        /// <value>Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.</value>
        [DataMember(Name = "lineage", EmitDefaultValue = true)]
        public string Lineage { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class OpaqueMarketData {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  Document: ").Append(Document).Append("\n");
            sb.Append("  Format: ").Append(Format).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Lineage: ").Append(Lineage).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OpaqueMarketData);
        }

        /// <summary>
        /// Returns true if OpaqueMarketData instances are equal
        /// </summary>
        /// <param name="input">Instance of OpaqueMarketData to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OpaqueMarketData input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.Document == input.Document ||
                    (this.Document != null &&
                    this.Document.Equals(input.Document))
                ) && base.Equals(input) && 
                (
                    this.Format == input.Format ||
                    (this.Format != null &&
                    this.Format.Equals(input.Format))
                ) && base.Equals(input) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && base.Equals(input) && 
                (
                    this.Lineage == input.Lineage ||
                    (this.Lineage != null &&
                    this.Lineage.Equals(input.Lineage))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.Document != null)
                {
                    hashCode = (hashCode * 59) + this.Document.GetHashCode();
                }
                if (this.Format != null)
                {
                    hashCode = (hashCode * 59) + this.Format.GetHashCode();
                }
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.Lineage != null)
                {
                    hashCode = (hashCode * 59) + this.Lineage.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // Document (string) minLength
            if (this.Document != null && this.Document.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Document, length must be greater than 1.", new [] { "Document" });
            }

            // Format (string) minLength
            if (this.Format != null && this.Format.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Format, length must be greater than 1.", new [] { "Format" });
            }

            // Name (string) minLength
            if (this.Name != null && this.Name.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be greater than 1.", new [] { "Name" });
            }

            // Lineage (string) maxLength
            if (this.Lineage != null && this.Lineage.Length > 1024)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Lineage, length must be less than 1024.", new [] { "Lineage" });
            }

            // Lineage (string) minLength
            if (this.Lineage != null && this.Lineage.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Lineage, length must be greater than 0.", new [] { "Lineage" });
            }

            yield break;
        }
    }
}
