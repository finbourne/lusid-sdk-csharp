/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// A single constituent of a partial closure event for a Flexible Repo. Contains details of the collateral being exchanged in the Instrument field, represented as a NewInstrument object, as well as the amount being exchanged and the type of that amount (Units or Percentage of current units).
    /// </summary>
    [DataContract(Name = "PartialClosureConstituent")]
    public partial class PartialClosureConstituent : IEquatable<PartialClosureConstituent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PartialClosureConstituent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PartialClosureConstituent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PartialClosureConstituent" /> class.
        /// </summary>
        /// <param name="amount">If AmountType is set to Units, this field represents the number of units of the instrument being exchanged. If AmountType is set to Percentage, this field represents the percentage of the total repoed units of the instrument being exchanged. When defining a FlexibleRepoPartialClosureEvent the AmountType can be set to either Units or Percentage, where Units represents the number of units of the instrument being exchanged, and Percentage represents the percentage of the total repoed units of the instrument being exchanged in the context of the FlexibleRepo. (required).</param>
        /// <param name="amountType">The type of amount represented by the Amount field. I.e., does it represent a number of units or a percentage of the total repoed units of the instrument? When defining a FlexibleRepoPartialClosureEvent AmountType can be set to either Units or Percentage.  Supported string (enumeration) values are: [Percentage, Units]. (required).</param>
        /// <param name="instrument">instrument (required).</param>
        public PartialClosureConstituent(decimal amount = default(decimal), string amountType = default(string), NewInstrument instrument = default(NewInstrument))
        {
            this.Amount = amount;
            // to ensure "amountType" is required (not null)
            if (amountType == null)
            {
                throw new ArgumentNullException("amountType is a required property for PartialClosureConstituent and cannot be null");
            }
            this.AmountType = amountType;
            // to ensure "instrument" is required (not null)
            if (instrument == null)
            {
                throw new ArgumentNullException("instrument is a required property for PartialClosureConstituent and cannot be null");
            }
            this.Instrument = instrument;
        }

        /// <summary>
        /// If AmountType is set to Units, this field represents the number of units of the instrument being exchanged. If AmountType is set to Percentage, this field represents the percentage of the total repoed units of the instrument being exchanged. When defining a FlexibleRepoPartialClosureEvent the AmountType can be set to either Units or Percentage, where Units represents the number of units of the instrument being exchanged, and Percentage represents the percentage of the total repoed units of the instrument being exchanged in the context of the FlexibleRepo.
        /// </summary>
        /// <value>If AmountType is set to Units, this field represents the number of units of the instrument being exchanged. If AmountType is set to Percentage, this field represents the percentage of the total repoed units of the instrument being exchanged. When defining a FlexibleRepoPartialClosureEvent the AmountType can be set to either Units or Percentage, where Units represents the number of units of the instrument being exchanged, and Percentage represents the percentage of the total repoed units of the instrument being exchanged in the context of the FlexibleRepo.</value>
        [DataMember(Name = "amount", IsRequired = true, EmitDefaultValue = true)]
        public decimal Amount { get; set; }

        /// <summary>
        /// The type of amount represented by the Amount field. I.e., does it represent a number of units or a percentage of the total repoed units of the instrument? When defining a FlexibleRepoPartialClosureEvent AmountType can be set to either Units or Percentage.  Supported string (enumeration) values are: [Percentage, Units].
        /// </summary>
        /// <value>The type of amount represented by the Amount field. I.e., does it represent a number of units or a percentage of the total repoed units of the instrument? When defining a FlexibleRepoPartialClosureEvent AmountType can be set to either Units or Percentage.  Supported string (enumeration) values are: [Percentage, Units].</value>
        [DataMember(Name = "amountType", IsRequired = true, EmitDefaultValue = true)]
        public string AmountType { get; set; }

        /// <summary>
        /// Gets or Sets Instrument
        /// </summary>
        [DataMember(Name = "instrument", IsRequired = true, EmitDefaultValue = true)]
        public NewInstrument Instrument { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PartialClosureConstituent {\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  AmountType: ").Append(AmountType).Append("\n");
            sb.Append("  Instrument: ").Append(Instrument).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PartialClosureConstituent);
        }

        /// <summary>
        /// Returns true if PartialClosureConstituent instances are equal
        /// </summary>
        /// <param name="input">Instance of PartialClosureConstituent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PartialClosureConstituent input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Amount == input.Amount ||
                    this.Amount.Equals(input.Amount)
                ) && 
                (
                    this.AmountType == input.AmountType ||
                    (this.AmountType != null &&
                    this.AmountType.Equals(input.AmountType))
                ) && 
                (
                    this.Instrument == input.Instrument ||
                    (this.Instrument != null &&
                    this.Instrument.Equals(input.Instrument))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Amount.GetHashCode();
                if (this.AmountType != null)
                {
                    hashCode = (hashCode * 59) + this.AmountType.GetHashCode();
                }
                if (this.Instrument != null)
                {
                    hashCode = (hashCode * 59) + this.Instrument.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // AmountType (string) minLength
            if (this.AmountType != null && this.AmountType.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AmountType, length must be greater than 1.", new [] { "AmountType" });
            }

            yield break;
        }
    }
}
