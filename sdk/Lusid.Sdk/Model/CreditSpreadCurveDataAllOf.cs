/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// CreditSpreadCurveDataAllOf
    /// </summary>
    [DataContract(Name = "CreditSpreadCurveData_allOf")]
    public partial class CreditSpreadCurveDataAllOf : IEquatable<CreditSpreadCurveDataAllOf>, IValidatableObject
    {
        /// <summary>
        /// The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData
        /// </summary>
        /// <value>The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum MarketDataTypeEnum
        {
            /// <summary>
            /// Enum DiscountFactorCurveData for value: DiscountFactorCurveData
            /// </summary>
            [EnumMember(Value = "DiscountFactorCurveData")]
            DiscountFactorCurveData = 1,

            /// <summary>
            /// Enum EquityVolSurfaceData for value: EquityVolSurfaceData
            /// </summary>
            [EnumMember(Value = "EquityVolSurfaceData")]
            EquityVolSurfaceData = 2,

            /// <summary>
            /// Enum FxVolSurfaceData for value: FxVolSurfaceData
            /// </summary>
            [EnumMember(Value = "FxVolSurfaceData")]
            FxVolSurfaceData = 3,

            /// <summary>
            /// Enum IrVolCubeData for value: IrVolCubeData
            /// </summary>
            [EnumMember(Value = "IrVolCubeData")]
            IrVolCubeData = 4,

            /// <summary>
            /// Enum OpaqueMarketData for value: OpaqueMarketData
            /// </summary>
            [EnumMember(Value = "OpaqueMarketData")]
            OpaqueMarketData = 5,

            /// <summary>
            /// Enum YieldCurveData for value: YieldCurveData
            /// </summary>
            [EnumMember(Value = "YieldCurveData")]
            YieldCurveData = 6,

            /// <summary>
            /// Enum FxForwardCurveData for value: FxForwardCurveData
            /// </summary>
            [EnumMember(Value = "FxForwardCurveData")]
            FxForwardCurveData = 7,

            /// <summary>
            /// Enum FxForwardPipsCurveData for value: FxForwardPipsCurveData
            /// </summary>
            [EnumMember(Value = "FxForwardPipsCurveData")]
            FxForwardPipsCurveData = 8,

            /// <summary>
            /// Enum FxForwardTenorCurveData for value: FxForwardTenorCurveData
            /// </summary>
            [EnumMember(Value = "FxForwardTenorCurveData")]
            FxForwardTenorCurveData = 9,

            /// <summary>
            /// Enum FxForwardTenorPipsCurveData for value: FxForwardTenorPipsCurveData
            /// </summary>
            [EnumMember(Value = "FxForwardTenorPipsCurveData")]
            FxForwardTenorPipsCurveData = 10,

            /// <summary>
            /// Enum FxForwardCurveByQuoteReference for value: FxForwardCurveByQuoteReference
            /// </summary>
            [EnumMember(Value = "FxForwardCurveByQuoteReference")]
            FxForwardCurveByQuoteReference = 11,

            /// <summary>
            /// Enum CreditSpreadCurveData for value: CreditSpreadCurveData
            /// </summary>
            [EnumMember(Value = "CreditSpreadCurveData")]
            CreditSpreadCurveData = 12,

            /// <summary>
            /// Enum EquityCurveByPricesData for value: EquityCurveByPricesData
            /// </summary>
            [EnumMember(Value = "EquityCurveByPricesData")]
            EquityCurveByPricesData = 13

        }


        /// <summary>
        /// The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData
        /// </summary>
        /// <value>The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData</value>
        [DataMember(Name = "marketDataType", IsRequired = true, EmitDefaultValue = true)]
        public MarketDataTypeEnum MarketDataType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreditSpreadCurveDataAllOf" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CreditSpreadCurveDataAllOf() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreditSpreadCurveDataAllOf" /> class.
        /// </summary>
        /// <param name="baseDate">EffectiveAt date of the quoted rates (required).</param>
        /// <param name="domCcy">Domestic currency of the curve (required).</param>
        /// <param name="tenors">The tenors for which the rates apply (required).</param>
        /// <param name="spreads">Par spread quotes corresponding to the tenors. (required).</param>
        /// <param name="recoveryRate">The recovery rate in default. (required).</param>
        /// <param name="referenceDate">If tenors are provided, this is the date against which the tenors will be resolved.  This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date.  In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid.  If not provided, this defaults to the BaseDate of the curve..</param>
        /// <param name="maturities">The maturity dates for which the rates apply.  Either tenors or maturities should be provided, not both..</param>
        /// <param name="lineage">Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;..</param>
        /// <param name="marketDataOptions">marketDataOptions.</param>
        /// <param name="marketDataType">The available values are: DiscountFactorCurveData, EquityVolSurfaceData, FxVolSurfaceData, IrVolCubeData, OpaqueMarketData, YieldCurveData, FxForwardCurveData, FxForwardPipsCurveData, FxForwardTenorCurveData, FxForwardTenorPipsCurveData, FxForwardCurveByQuoteReference, CreditSpreadCurveData, EquityCurveByPricesData (required).</param>
        public CreditSpreadCurveDataAllOf(DateTimeOffset baseDate = default(DateTimeOffset), string domCcy = default(string), List<string> tenors = default(List<string>), List<decimal> spreads = default(List<decimal>), decimal recoveryRate = default(decimal), DateTimeOffset? referenceDate = default(DateTimeOffset?), List<DateTimeOffset> maturities = default(List<DateTimeOffset>), string lineage = default(string), MarketDataOptions marketDataOptions = default(MarketDataOptions), MarketDataTypeEnum marketDataType = default(MarketDataTypeEnum))
        {
            this.BaseDate = baseDate;
            // to ensure "domCcy" is required (not null)
            if (domCcy == null)
            {
                throw new ArgumentNullException("domCcy is a required property for CreditSpreadCurveDataAllOf and cannot be null");
            }
            this.DomCcy = domCcy;
            // to ensure "tenors" is required (not null)
            if (tenors == null)
            {
                throw new ArgumentNullException("tenors is a required property for CreditSpreadCurveDataAllOf and cannot be null");
            }
            this.Tenors = tenors;
            // to ensure "spreads" is required (not null)
            if (spreads == null)
            {
                throw new ArgumentNullException("spreads is a required property for CreditSpreadCurveDataAllOf and cannot be null");
            }
            this.Spreads = spreads;
            this.RecoveryRate = recoveryRate;
            this.MarketDataType = marketDataType;
            this.ReferenceDate = referenceDate;
            this.Maturities = maturities;
            this.Lineage = lineage;
            this.MarketDataOptions = marketDataOptions;
        }

        /// <summary>
        /// EffectiveAt date of the quoted rates
        /// </summary>
        /// <value>EffectiveAt date of the quoted rates</value>
        [DataMember(Name = "baseDate", IsRequired = true, EmitDefaultValue = true)]
        public DateTimeOffset BaseDate { get; set; }

        /// <summary>
        /// Domestic currency of the curve
        /// </summary>
        /// <value>Domestic currency of the curve</value>
        [DataMember(Name = "domCcy", IsRequired = true, EmitDefaultValue = true)]
        public string DomCcy { get; set; }

        /// <summary>
        /// The tenors for which the rates apply
        /// </summary>
        /// <value>The tenors for which the rates apply</value>
        [DataMember(Name = "tenors", IsRequired = true, EmitDefaultValue = true)]
        public List<string> Tenors { get; set; }

        /// <summary>
        /// Par spread quotes corresponding to the tenors.
        /// </summary>
        /// <value>Par spread quotes corresponding to the tenors.</value>
        [DataMember(Name = "spreads", IsRequired = true, EmitDefaultValue = true)]
        public List<decimal> Spreads { get; set; }

        /// <summary>
        /// The recovery rate in default.
        /// </summary>
        /// <value>The recovery rate in default.</value>
        [DataMember(Name = "recoveryRate", IsRequired = true, EmitDefaultValue = true)]
        public decimal RecoveryRate { get; set; }

        /// <summary>
        /// If tenors are provided, this is the date against which the tenors will be resolved.  This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date.  In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid.  If not provided, this defaults to the BaseDate of the curve.
        /// </summary>
        /// <value>If tenors are provided, this is the date against which the tenors will be resolved.  This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date.  In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid.  If not provided, this defaults to the BaseDate of the curve.</value>
        [DataMember(Name = "referenceDate", EmitDefaultValue = true)]
        public DateTimeOffset? ReferenceDate { get; set; }

        /// <summary>
        /// The maturity dates for which the rates apply.  Either tenors or maturities should be provided, not both.
        /// </summary>
        /// <value>The maturity dates for which the rates apply.  Either tenors or maturities should be provided, not both.</value>
        [DataMember(Name = "maturities", EmitDefaultValue = true)]
        public List<DateTimeOffset> Maturities { get; set; }

        /// <summary>
        /// Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.
        /// </summary>
        /// <value>Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.</value>
        [DataMember(Name = "lineage", EmitDefaultValue = true)]
        public string Lineage { get; set; }

        /// <summary>
        /// Gets or Sets MarketDataOptions
        /// </summary>
        [DataMember(Name = "marketDataOptions", EmitDefaultValue = false)]
        public MarketDataOptions MarketDataOptions { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CreditSpreadCurveDataAllOf {\n");
            sb.Append("  BaseDate: ").Append(BaseDate).Append("\n");
            sb.Append("  DomCcy: ").Append(DomCcy).Append("\n");
            sb.Append("  Tenors: ").Append(Tenors).Append("\n");
            sb.Append("  Spreads: ").Append(Spreads).Append("\n");
            sb.Append("  RecoveryRate: ").Append(RecoveryRate).Append("\n");
            sb.Append("  ReferenceDate: ").Append(ReferenceDate).Append("\n");
            sb.Append("  Maturities: ").Append(Maturities).Append("\n");
            sb.Append("  Lineage: ").Append(Lineage).Append("\n");
            sb.Append("  MarketDataOptions: ").Append(MarketDataOptions).Append("\n");
            sb.Append("  MarketDataType: ").Append(MarketDataType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CreditSpreadCurveDataAllOf);
        }

        /// <summary>
        /// Returns true if CreditSpreadCurveDataAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of CreditSpreadCurveDataAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CreditSpreadCurveDataAllOf input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.BaseDate == input.BaseDate ||
                    (this.BaseDate != null &&
                    this.BaseDate.Equals(input.BaseDate))
                ) && 
                (
                    this.DomCcy == input.DomCcy ||
                    (this.DomCcy != null &&
                    this.DomCcy.Equals(input.DomCcy))
                ) && 
                (
                    this.Tenors == input.Tenors ||
                    this.Tenors != null &&
                    input.Tenors != null &&
                    this.Tenors.SequenceEqual(input.Tenors)
                ) && 
                (
                    this.Spreads == input.Spreads ||
                    this.Spreads != null &&
                    input.Spreads != null &&
                    this.Spreads.SequenceEqual(input.Spreads)
                ) && 
                (
                    this.RecoveryRate == input.RecoveryRate ||
                    this.RecoveryRate.Equals(input.RecoveryRate)
                ) && 
                (
                    this.ReferenceDate == input.ReferenceDate ||
                    (this.ReferenceDate != null &&
                    this.ReferenceDate.Equals(input.ReferenceDate))
                ) && 
                (
                    this.Maturities == input.Maturities ||
                    this.Maturities != null &&
                    input.Maturities != null &&
                    this.Maturities.SequenceEqual(input.Maturities)
                ) && 
                (
                    this.Lineage == input.Lineage ||
                    (this.Lineage != null &&
                    this.Lineage.Equals(input.Lineage))
                ) && 
                (
                    this.MarketDataOptions == input.MarketDataOptions ||
                    (this.MarketDataOptions != null &&
                    this.MarketDataOptions.Equals(input.MarketDataOptions))
                ) && 
                (
                    this.MarketDataType == input.MarketDataType ||
                    this.MarketDataType.Equals(input.MarketDataType)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.BaseDate != null)
                {
                    hashCode = (hashCode * 59) + this.BaseDate.GetHashCode();
                }
                if (this.DomCcy != null)
                {
                    hashCode = (hashCode * 59) + this.DomCcy.GetHashCode();
                }
                if (this.Tenors != null)
                {
                    hashCode = (hashCode * 59) + this.Tenors.GetHashCode();
                }
                if (this.Spreads != null)
                {
                    hashCode = (hashCode * 59) + this.Spreads.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RecoveryRate.GetHashCode();
                if (this.ReferenceDate != null)
                {
                    hashCode = (hashCode * 59) + this.ReferenceDate.GetHashCode();
                }
                if (this.Maturities != null)
                {
                    hashCode = (hashCode * 59) + this.Maturities.GetHashCode();
                }
                if (this.Lineage != null)
                {
                    hashCode = (hashCode * 59) + this.Lineage.GetHashCode();
                }
                if (this.MarketDataOptions != null)
                {
                    hashCode = (hashCode * 59) + this.MarketDataOptions.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.MarketDataType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Lineage (string) maxLength
            if (this.Lineage != null && this.Lineage.Length > 1024)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Lineage, length must be less than 1024.", new [] { "Lineage" });
            }

            // Lineage (string) minLength
            if (this.Lineage != null && this.Lineage.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Lineage, length must be greater than 0.", new [] { "Lineage" });
            }

            yield break;
        }
    }
}
