/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// LUSID representation of an FX Swap. Composed of two FX Forwards.                This instrument has multiple legs, to see how legs are used in LUSID see [knowledge base article KA-02252](https://support.lusid.com/knowledgebase/article/KA-02252).                | Leg Index | Leg Identifier | Description |  | - -- -- -- -- | - -- -- -- -- -- -- - | - -- -- -- -- -- |  | 1 | FarDomesticLeg | Cash flows in the domestic currency for the far forward. |  | 2 | FarForeignLeg | Cash flows in the foreign currency for the far forward (not present for non-deliverable forwards). |  | 3 | NearDomesticLeg | Cash flows in the domestic currency for the near forward. |  | 4 | NearForeignLeg | Cash flows in the foreign currency for the near forward (not present for non-deliverable forwards). |
    /// </summary>
    [DataContract(Name = "FxSwap")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentType")]
    public partial class FxSwap : LusidInstrument, IEquatable<FxSwap>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FxSwap" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FxSwap() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FxSwap" /> class.
        /// </summary>
        /// <param name="nearFxForward">nearFxForward (required).</param>
        /// <param name="farFxForward">farFxForward (required).</param>
        /// <param name="notionalSymmetry">The NotionalSymmetry allows for even and uneven FxSwaps to be supported.  An even FxSwap is one where the near and far fx forwards have the same notional value on at least one of the  legs. An uneven FxSwap is one where near and far fx forwards don&#39;t have the same notional on both the  domestic and foreign legs.  By default NotionalSymmetry will be set as even.    Supported string (enumeration) values are: [Even, Uneven]..</param>
        /// <param name="instrumentType">The available values are: QuotedSecurity, InterestRateSwap, FxForward, Future, ExoticInstrument, FxOption, CreditDefaultSwap, InterestRateSwaption, Bond, EquityOption, FixedLeg, FloatingLeg, BespokeCashFlowsLeg, Unknown, TermDeposit, ContractForDifference, EquitySwap, CashPerpetual, CapFloor, CashSettled, CdsIndex, Basket, FundingLeg, FxSwap, ForwardRateAgreement, SimpleInstrument, Repo, Equity, ExchangeTradedOption, ReferenceInstrument, ComplexBond, InflationLinkedBond, InflationSwap, SimpleCashFlowLoan, TotalReturnSwap, InflationLeg, FundShareClass, FlexibleLoan, UnsettledCash, Cash (required) (default to &quot;FxSwap&quot;).</param>
        public FxSwap(FxForward nearFxForward = default(FxForward), FxForward farFxForward = default(FxForward), string notionalSymmetry = default(string), InstrumentTypeEnum instrumentType = default(InstrumentTypeEnum)) : base(instrumentType)
        {
            // to ensure "nearFxForward" is required (not null)
            if (nearFxForward == null)
            {
                throw new ArgumentNullException("nearFxForward is a required property for FxSwap and cannot be null");
            }
            this.NearFxForward = nearFxForward;
            // to ensure "farFxForward" is required (not null)
            if (farFxForward == null)
            {
                throw new ArgumentNullException("farFxForward is a required property for FxSwap and cannot be null");
            }
            this.FarFxForward = farFxForward;
            this.NotionalSymmetry = notionalSymmetry;
        }

        /// <summary>
        /// Gets or Sets NearFxForward
        /// </summary>
        [DataMember(Name = "nearFxForward", IsRequired = true, EmitDefaultValue = true)]
        public FxForward NearFxForward { get; set; }

        /// <summary>
        /// Gets or Sets FarFxForward
        /// </summary>
        [DataMember(Name = "farFxForward", IsRequired = true, EmitDefaultValue = true)]
        public FxForward FarFxForward { get; set; }

        /// <summary>
        /// The NotionalSymmetry allows for even and uneven FxSwaps to be supported.  An even FxSwap is one where the near and far fx forwards have the same notional value on at least one of the  legs. An uneven FxSwap is one where near and far fx forwards don&#39;t have the same notional on both the  domestic and foreign legs.  By default NotionalSymmetry will be set as even.    Supported string (enumeration) values are: [Even, Uneven].
        /// </summary>
        /// <value>The NotionalSymmetry allows for even and uneven FxSwaps to be supported.  An even FxSwap is one where the near and far fx forwards have the same notional value on at least one of the  legs. An uneven FxSwap is one where near and far fx forwards don&#39;t have the same notional on both the  domestic and foreign legs.  By default NotionalSymmetry will be set as even.    Supported string (enumeration) values are: [Even, Uneven].</value>
        [DataMember(Name = "notionalSymmetry", EmitDefaultValue = true)]
        public string NotionalSymmetry { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FxSwap {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  NearFxForward: ").Append(NearFxForward).Append("\n");
            sb.Append("  FarFxForward: ").Append(FarFxForward).Append("\n");
            sb.Append("  NotionalSymmetry: ").Append(NotionalSymmetry).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FxSwap);
        }

        /// <summary>
        /// Returns true if FxSwap instances are equal
        /// </summary>
        /// <param name="input">Instance of FxSwap to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FxSwap input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.NearFxForward == input.NearFxForward ||
                    (this.NearFxForward != null &&
                    this.NearFxForward.Equals(input.NearFxForward))
                ) && base.Equals(input) && 
                (
                    this.FarFxForward == input.FarFxForward ||
                    (this.FarFxForward != null &&
                    this.FarFxForward.Equals(input.FarFxForward))
                ) && base.Equals(input) && 
                (
                    this.NotionalSymmetry == input.NotionalSymmetry ||
                    (this.NotionalSymmetry != null &&
                    this.NotionalSymmetry.Equals(input.NotionalSymmetry))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.NearFxForward != null)
                {
                    hashCode = (hashCode * 59) + this.NearFxForward.GetHashCode();
                }
                if (this.FarFxForward != null)
                {
                    hashCode = (hashCode * 59) + this.FarFxForward.GetHashCode();
                }
                if (this.NotionalSymmetry != null)
                {
                    hashCode = (hashCode * 59) + this.NotionalSymmetry.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            yield break;
        }
    }
}
