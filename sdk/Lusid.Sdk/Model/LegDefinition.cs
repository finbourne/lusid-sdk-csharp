/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Definition of the set of flow and index conventions along with other miscellaneous information required to generate an instrument leg.
    /// </summary>
    [DataContract(Name = "LegDefinition")]
    public partial class LegDefinition : IEquatable<LegDefinition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LegDefinition" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LegDefinition() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LegDefinition" /> class.
        /// </summary>
        /// <param name="conventionName">conventionName.</param>
        /// <param name="conventions">conventions.</param>
        /// <param name="indexConvention">indexConvention.</param>
        /// <param name="indexConventionName">indexConventionName.</param>
        /// <param name="notionalExchangeType">what type of notional exchange does the leg have  Supported string (enumeration) values are: [None, Initial, Final, Both]. (required).</param>
        /// <param name="payReceive">Is the leg to be paid or received  Supported string (enumeration) values are: [Pay, Receive]. (required).</param>
        /// <param name="rateOrSpread">Is there either a fixed rate (non-zero) or spread to be paid over the value of the leg. (required).</param>
        /// <param name="resetConvention">Control how resets are generated relative to swap payment convention(s).  Supported string (enumeration) values are: [InAdvance, InArrears]..</param>
        /// <param name="stubType">If a stub is required should it be at the front or back of the leg.  Supported string (enumeration) values are: [None, ShortFront, ShortBack, LongBack, LongFront, Both]. (required).</param>
        /// <param name="compounding">compounding.</param>
        /// <param name="amortisation">amortisation.</param>
        /// <param name="firstRegularPaymentDate">Optional payment date of the first regular coupon. Must be greater than the StartDate. If set, the regular coupon schedule will be built such that the first regular coupon will end on this date. The start date of this coupon will be calculated as normal and a stub coupon will be created from the StartDate to the start of the first regular coupon..</param>
        /// <param name="firstCouponType">Optional coupon type setting for the first coupon, can be used with Stub coupons. If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal, however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined directly from the tenor (i.e. a quarterly leg will be set to 0.25).  Supported string (enumeration) values are: [ProRata, Full]..</param>
        /// <param name="lastRegularPaymentDate">Optional payment date of the last regular coupon. Must be less than the Maturity date. If set, the regular coupon schedule will be built up to this date and the final coupon will be a stub between this date and the Maturity date..</param>
        /// <param name="lastCouponType">Optional coupon type setting for the last coupon, can be used with Stub coupons. If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal, however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined directly from the tenor (i.e. a quarterly leg will be set to 0.25).  Supported string (enumeration) values are: [ProRata, Full]..</param>
        /// <param name="fxLinkedNotionalSchedule">fxLinkedNotionalSchedule.</param>
        /// <param name="intermediateNotionalExchange">Indicates whether there are intermediate notional exchanges..</param>
        public LegDefinition(FlowConventionName conventionName = default(FlowConventionName), FlowConventions conventions = default(FlowConventions), IndexConvention indexConvention = default(IndexConvention), FlowConventionName indexConventionName = default(FlowConventionName), string notionalExchangeType = default(string), string payReceive = default(string), decimal rateOrSpread = default(decimal), string resetConvention = default(string), string stubType = default(string), Compounding compounding = default(Compounding), StepSchedule amortisation = default(StepSchedule), DateTimeOffset? firstRegularPaymentDate = default(DateTimeOffset?), string firstCouponType = default(string), DateTimeOffset? lastRegularPaymentDate = default(DateTimeOffset?), string lastCouponType = default(string), FxLinkedNotionalSchedule fxLinkedNotionalSchedule = default(FxLinkedNotionalSchedule), bool? intermediateNotionalExchange = default(bool?))
        {
            // to ensure "notionalExchangeType" is required (not null)
            if (notionalExchangeType == null)
            {
                throw new ArgumentNullException("notionalExchangeType is a required property for LegDefinition and cannot be null");
            }
            this.NotionalExchangeType = notionalExchangeType;
            // to ensure "payReceive" is required (not null)
            if (payReceive == null)
            {
                throw new ArgumentNullException("payReceive is a required property for LegDefinition and cannot be null");
            }
            this.PayReceive = payReceive;
            this.RateOrSpread = rateOrSpread;
            // to ensure "stubType" is required (not null)
            if (stubType == null)
            {
                throw new ArgumentNullException("stubType is a required property for LegDefinition and cannot be null");
            }
            this.StubType = stubType;
            this.ConventionName = conventionName;
            this.Conventions = conventions;
            this.IndexConvention = indexConvention;
            this.IndexConventionName = indexConventionName;
            this.ResetConvention = resetConvention;
            this.Compounding = compounding;
            this.Amortisation = amortisation;
            this.FirstRegularPaymentDate = firstRegularPaymentDate;
            this.FirstCouponType = firstCouponType;
            this.LastRegularPaymentDate = lastRegularPaymentDate;
            this.LastCouponType = lastCouponType;
            this.FxLinkedNotionalSchedule = fxLinkedNotionalSchedule;
            this.IntermediateNotionalExchange = intermediateNotionalExchange;
        }

        /// <summary>
        /// Gets or Sets ConventionName
        /// </summary>
        [DataMember(Name = "conventionName", EmitDefaultValue = false)]
        public FlowConventionName ConventionName { get; set; }

        /// <summary>
        /// Gets or Sets Conventions
        /// </summary>
        [DataMember(Name = "conventions", EmitDefaultValue = false)]
        public FlowConventions Conventions { get; set; }

        /// <summary>
        /// Gets or Sets IndexConvention
        /// </summary>
        [DataMember(Name = "indexConvention", EmitDefaultValue = false)]
        public IndexConvention IndexConvention { get; set; }

        /// <summary>
        /// Gets or Sets IndexConventionName
        /// </summary>
        [DataMember(Name = "indexConventionName", EmitDefaultValue = false)]
        public FlowConventionName IndexConventionName { get; set; }

        /// <summary>
        /// what type of notional exchange does the leg have  Supported string (enumeration) values are: [None, Initial, Final, Both].
        /// </summary>
        /// <value>what type of notional exchange does the leg have  Supported string (enumeration) values are: [None, Initial, Final, Both].</value>
        [DataMember(Name = "notionalExchangeType", IsRequired = true, EmitDefaultValue = true)]
        public string NotionalExchangeType { get; set; }

        /// <summary>
        /// Is the leg to be paid or received  Supported string (enumeration) values are: [Pay, Receive].
        /// </summary>
        /// <value>Is the leg to be paid or received  Supported string (enumeration) values are: [Pay, Receive].</value>
        [DataMember(Name = "payReceive", IsRequired = true, EmitDefaultValue = true)]
        public string PayReceive { get; set; }

        /// <summary>
        /// Is there either a fixed rate (non-zero) or spread to be paid over the value of the leg.
        /// </summary>
        /// <value>Is there either a fixed rate (non-zero) or spread to be paid over the value of the leg.</value>
        [DataMember(Name = "rateOrSpread", IsRequired = true, EmitDefaultValue = true)]
        public decimal RateOrSpread { get; set; }

        /// <summary>
        /// Control how resets are generated relative to swap payment convention(s).  Supported string (enumeration) values are: [InAdvance, InArrears].
        /// </summary>
        /// <value>Control how resets are generated relative to swap payment convention(s).  Supported string (enumeration) values are: [InAdvance, InArrears].</value>
        [DataMember(Name = "resetConvention", EmitDefaultValue = true)]
        public string ResetConvention { get; set; }

        /// <summary>
        /// If a stub is required should it be at the front or back of the leg.  Supported string (enumeration) values are: [None, ShortFront, ShortBack, LongBack, LongFront, Both].
        /// </summary>
        /// <value>If a stub is required should it be at the front or back of the leg.  Supported string (enumeration) values are: [None, ShortFront, ShortBack, LongBack, LongFront, Both].</value>
        [DataMember(Name = "stubType", IsRequired = true, EmitDefaultValue = true)]
        public string StubType { get; set; }

        /// <summary>
        /// Gets or Sets Compounding
        /// </summary>
        [DataMember(Name = "compounding", EmitDefaultValue = false)]
        public Compounding Compounding { get; set; }

        /// <summary>
        /// Gets or Sets Amortisation
        /// </summary>
        [DataMember(Name = "amortisation", EmitDefaultValue = false)]
        public StepSchedule Amortisation { get; set; }

        /// <summary>
        /// Optional payment date of the first regular coupon. Must be greater than the StartDate. If set, the regular coupon schedule will be built such that the first regular coupon will end on this date. The start date of this coupon will be calculated as normal and a stub coupon will be created from the StartDate to the start of the first regular coupon.
        /// </summary>
        /// <value>Optional payment date of the first regular coupon. Must be greater than the StartDate. If set, the regular coupon schedule will be built such that the first regular coupon will end on this date. The start date of this coupon will be calculated as normal and a stub coupon will be created from the StartDate to the start of the first regular coupon.</value>
        [DataMember(Name = "firstRegularPaymentDate", EmitDefaultValue = true)]
        public DateTimeOffset? FirstRegularPaymentDate { get; set; }

        /// <summary>
        /// Optional coupon type setting for the first coupon, can be used with Stub coupons. If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal, however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined directly from the tenor (i.e. a quarterly leg will be set to 0.25).  Supported string (enumeration) values are: [ProRata, Full].
        /// </summary>
        /// <value>Optional coupon type setting for the first coupon, can be used with Stub coupons. If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal, however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined directly from the tenor (i.e. a quarterly leg will be set to 0.25).  Supported string (enumeration) values are: [ProRata, Full].</value>
        [DataMember(Name = "firstCouponType", EmitDefaultValue = true)]
        public string FirstCouponType { get; set; }

        /// <summary>
        /// Optional payment date of the last regular coupon. Must be less than the Maturity date. If set, the regular coupon schedule will be built up to this date and the final coupon will be a stub between this date and the Maturity date.
        /// </summary>
        /// <value>Optional payment date of the last regular coupon. Must be less than the Maturity date. If set, the regular coupon schedule will be built up to this date and the final coupon will be a stub between this date and the Maturity date.</value>
        [DataMember(Name = "lastRegularPaymentDate", EmitDefaultValue = true)]
        public DateTimeOffset? LastRegularPaymentDate { get; set; }

        /// <summary>
        /// Optional coupon type setting for the last coupon, can be used with Stub coupons. If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal, however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined directly from the tenor (i.e. a quarterly leg will be set to 0.25).  Supported string (enumeration) values are: [ProRata, Full].
        /// </summary>
        /// <value>Optional coupon type setting for the last coupon, can be used with Stub coupons. If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal, however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined directly from the tenor (i.e. a quarterly leg will be set to 0.25).  Supported string (enumeration) values are: [ProRata, Full].</value>
        [DataMember(Name = "lastCouponType", EmitDefaultValue = true)]
        public string LastCouponType { get; set; }

        /// <summary>
        /// Gets or Sets FxLinkedNotionalSchedule
        /// </summary>
        [DataMember(Name = "fxLinkedNotionalSchedule", EmitDefaultValue = false)]
        public FxLinkedNotionalSchedule FxLinkedNotionalSchedule { get; set; }

        /// <summary>
        /// Indicates whether there are intermediate notional exchanges.
        /// </summary>
        /// <value>Indicates whether there are intermediate notional exchanges.</value>
        [DataMember(Name = "intermediateNotionalExchange", EmitDefaultValue = true)]
        public bool? IntermediateNotionalExchange { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class LegDefinition {\n");
            sb.Append("  ConventionName: ").Append(ConventionName).Append("\n");
            sb.Append("  Conventions: ").Append(Conventions).Append("\n");
            sb.Append("  IndexConvention: ").Append(IndexConvention).Append("\n");
            sb.Append("  IndexConventionName: ").Append(IndexConventionName).Append("\n");
            sb.Append("  NotionalExchangeType: ").Append(NotionalExchangeType).Append("\n");
            sb.Append("  PayReceive: ").Append(PayReceive).Append("\n");
            sb.Append("  RateOrSpread: ").Append(RateOrSpread).Append("\n");
            sb.Append("  ResetConvention: ").Append(ResetConvention).Append("\n");
            sb.Append("  StubType: ").Append(StubType).Append("\n");
            sb.Append("  Compounding: ").Append(Compounding).Append("\n");
            sb.Append("  Amortisation: ").Append(Amortisation).Append("\n");
            sb.Append("  FirstRegularPaymentDate: ").Append(FirstRegularPaymentDate).Append("\n");
            sb.Append("  FirstCouponType: ").Append(FirstCouponType).Append("\n");
            sb.Append("  LastRegularPaymentDate: ").Append(LastRegularPaymentDate).Append("\n");
            sb.Append("  LastCouponType: ").Append(LastCouponType).Append("\n");
            sb.Append("  FxLinkedNotionalSchedule: ").Append(FxLinkedNotionalSchedule).Append("\n");
            sb.Append("  IntermediateNotionalExchange: ").Append(IntermediateNotionalExchange).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as LegDefinition);
        }

        /// <summary>
        /// Returns true if LegDefinition instances are equal
        /// </summary>
        /// <param name="input">Instance of LegDefinition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LegDefinition input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.ConventionName == input.ConventionName ||
                    (this.ConventionName != null &&
                    this.ConventionName.Equals(input.ConventionName))
                ) && 
                (
                    this.Conventions == input.Conventions ||
                    (this.Conventions != null &&
                    this.Conventions.Equals(input.Conventions))
                ) && 
                (
                    this.IndexConvention == input.IndexConvention ||
                    (this.IndexConvention != null &&
                    this.IndexConvention.Equals(input.IndexConvention))
                ) && 
                (
                    this.IndexConventionName == input.IndexConventionName ||
                    (this.IndexConventionName != null &&
                    this.IndexConventionName.Equals(input.IndexConventionName))
                ) && 
                (
                    this.NotionalExchangeType == input.NotionalExchangeType ||
                    (this.NotionalExchangeType != null &&
                    this.NotionalExchangeType.Equals(input.NotionalExchangeType))
                ) && 
                (
                    this.PayReceive == input.PayReceive ||
                    (this.PayReceive != null &&
                    this.PayReceive.Equals(input.PayReceive))
                ) && 
                (
                    this.RateOrSpread == input.RateOrSpread ||
                    this.RateOrSpread.Equals(input.RateOrSpread)
                ) && 
                (
                    this.ResetConvention == input.ResetConvention ||
                    (this.ResetConvention != null &&
                    this.ResetConvention.Equals(input.ResetConvention))
                ) && 
                (
                    this.StubType == input.StubType ||
                    (this.StubType != null &&
                    this.StubType.Equals(input.StubType))
                ) && 
                (
                    this.Compounding == input.Compounding ||
                    (this.Compounding != null &&
                    this.Compounding.Equals(input.Compounding))
                ) && 
                (
                    this.Amortisation == input.Amortisation ||
                    (this.Amortisation != null &&
                    this.Amortisation.Equals(input.Amortisation))
                ) && 
                (
                    this.FirstRegularPaymentDate == input.FirstRegularPaymentDate ||
                    (this.FirstRegularPaymentDate != null &&
                    this.FirstRegularPaymentDate.Equals(input.FirstRegularPaymentDate))
                ) && 
                (
                    this.FirstCouponType == input.FirstCouponType ||
                    (this.FirstCouponType != null &&
                    this.FirstCouponType.Equals(input.FirstCouponType))
                ) && 
                (
                    this.LastRegularPaymentDate == input.LastRegularPaymentDate ||
                    (this.LastRegularPaymentDate != null &&
                    this.LastRegularPaymentDate.Equals(input.LastRegularPaymentDate))
                ) && 
                (
                    this.LastCouponType == input.LastCouponType ||
                    (this.LastCouponType != null &&
                    this.LastCouponType.Equals(input.LastCouponType))
                ) && 
                (
                    this.FxLinkedNotionalSchedule == input.FxLinkedNotionalSchedule ||
                    (this.FxLinkedNotionalSchedule != null &&
                    this.FxLinkedNotionalSchedule.Equals(input.FxLinkedNotionalSchedule))
                ) && 
                (
                    this.IntermediateNotionalExchange == input.IntermediateNotionalExchange ||
                    (this.IntermediateNotionalExchange != null &&
                    this.IntermediateNotionalExchange.Equals(input.IntermediateNotionalExchange))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ConventionName != null)
                {
                    hashCode = (hashCode * 59) + this.ConventionName.GetHashCode();
                }
                if (this.Conventions != null)
                {
                    hashCode = (hashCode * 59) + this.Conventions.GetHashCode();
                }
                if (this.IndexConvention != null)
                {
                    hashCode = (hashCode * 59) + this.IndexConvention.GetHashCode();
                }
                if (this.IndexConventionName != null)
                {
                    hashCode = (hashCode * 59) + this.IndexConventionName.GetHashCode();
                }
                if (this.NotionalExchangeType != null)
                {
                    hashCode = (hashCode * 59) + this.NotionalExchangeType.GetHashCode();
                }
                if (this.PayReceive != null)
                {
                    hashCode = (hashCode * 59) + this.PayReceive.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RateOrSpread.GetHashCode();
                if (this.ResetConvention != null)
                {
                    hashCode = (hashCode * 59) + this.ResetConvention.GetHashCode();
                }
                if (this.StubType != null)
                {
                    hashCode = (hashCode * 59) + this.StubType.GetHashCode();
                }
                if (this.Compounding != null)
                {
                    hashCode = (hashCode * 59) + this.Compounding.GetHashCode();
                }
                if (this.Amortisation != null)
                {
                    hashCode = (hashCode * 59) + this.Amortisation.GetHashCode();
                }
                if (this.FirstRegularPaymentDate != null)
                {
                    hashCode = (hashCode * 59) + this.FirstRegularPaymentDate.GetHashCode();
                }
                if (this.FirstCouponType != null)
                {
                    hashCode = (hashCode * 59) + this.FirstCouponType.GetHashCode();
                }
                if (this.LastRegularPaymentDate != null)
                {
                    hashCode = (hashCode * 59) + this.LastRegularPaymentDate.GetHashCode();
                }
                if (this.LastCouponType != null)
                {
                    hashCode = (hashCode * 59) + this.LastCouponType.GetHashCode();
                }
                if (this.FxLinkedNotionalSchedule != null)
                {
                    hashCode = (hashCode * 59) + this.FxLinkedNotionalSchedule.GetHashCode();
                }
                if (this.IntermediateNotionalExchange != null)
                {
                    hashCode = (hashCode * 59) + this.IntermediateNotionalExchange.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // NotionalExchangeType (string) minLength
            if (this.NotionalExchangeType != null && this.NotionalExchangeType.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NotionalExchangeType, length must be greater than 1.", new [] { "NotionalExchangeType" });
            }

            // PayReceive (string) minLength
            if (this.PayReceive != null && this.PayReceive.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PayReceive, length must be greater than 1.", new [] { "PayReceive" });
            }

            // StubType (string) minLength
            if (this.StubType != null && this.StubType.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StubType, length must be greater than 1.", new [] { "StubType" });
            }

            yield break;
        }
    }
}
