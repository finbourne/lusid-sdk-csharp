/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using JsonSubTypes;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Event representing the partial closure of a repurchase   agreement. Each event reduces the outstanding notional   and generates a corresponding receive-leg cashflow. The   final maturity cashflow is adjusted accordingly.  If multiple events are created, their effects compound.   Once the total repaid amount reaches the original purchase   price, no further receive-leg cashflows are generated. Any   event exceeding the remaining notional is marked with a   diagnostic to indicate it is invalid due to excessive repayment.  For example, for a repo with a 5% rate, 1% haircut and   collateral value of 100 (purchase price &#x3D; 99), a partial   closure of cash amount 10 followed by one of 100 results in   only the first event producing a cashflow. The second,   exceeding the remaining balance, is ignored and flagged   with a diagnostic. The remaining balance is settled at   maturity of the repurchase agreement.  Specific to a FlexibleRepo instrument.
    /// </summary>
    [DataContract(Name = "FlexibleRepoPartialClosureEvent")]
    [JsonConverter(typeof(JsonSubtypes), "InstrumentEventType")]
    public partial class FlexibleRepoPartialClosureEvent : InstrumentEvent, IEquatable<FlexibleRepoPartialClosureEvent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FlexibleRepoPartialClosureEvent" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected FlexibleRepoPartialClosureEvent() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FlexibleRepoPartialClosureEvent" /> class.
        /// </summary>
        /// <param name="entitlementDate">Required property.  The date on which the counterparties become entitled   to exchange cash as part of a partial closure of the   repurchase agreement. The date must be before or on   the settlement date, and on or before the maturity   date of the repo.  This is a required field, unless otherwise supplied via \&quot;EventDateStamps\&quot; in  the instrument event upsert request..</param>
        /// <param name="settlementDate">Required property.  The date on which the exchange of cash is settled.   The date must be on or after the entitlement date,  and on or before the maturity date of the repo.  This is a required field, unless otherwise supplied via \&quot;EventDateStamps\&quot; in  the instrument event upsert request..</param>
        /// <param name="amount">The amount of cash to be exchanged as part of a partial closure of the repurchase agreement.  Either the absolute cash amount or a percentage of the remaining amount,  depending on the AmountType. (required).</param>
        /// <param name="amountType">AmountType of the cash amount to be exchanged as part of a partial closure of the repurchase agreement.  Either percentage or absolute cash amount.    Supported string (enumeration) values are: [Percentage, Units]. (required).</param>
        /// <param name="partialClosureConstituents">List of the collateral instruments involved in this partial closure, along with how they are affected. (required).</param>
        /// <param name="instrumentEventType">The Type of Event. The available values are: TransitionEvent, InformationalEvent, OpenEvent, CloseEvent, StockSplitEvent, BondDefaultEvent, CashDividendEvent, AmortisationEvent, CashFlowEvent, ExerciseEvent, ResetEvent, TriggerEvent, RawVendorEvent, InformationalErrorEvent, BondCouponEvent, DividendReinvestmentEvent, AccumulationEvent, BondPrincipalEvent, DividendOptionEvent, MaturityEvent, FxForwardSettlementEvent, ExpiryEvent, ScripDividendEvent, StockDividendEvent, ReverseStockSplitEvent, CapitalDistributionEvent, SpinOffEvent, MergerEvent, FutureExpiryEvent, SwapCashFlowEvent, SwapPrincipalEvent, CreditPremiumCashFlowEvent, CdsCreditEvent, CdxCreditEvent, MbsCouponEvent, MbsPrincipalEvent, BonusIssueEvent, MbsPrincipalWriteOffEvent, MbsInterestDeferralEvent, MbsInterestShortfallEvent, TenderEvent, CallOnIntermediateSecuritiesEvent, IntermediateSecuritiesDistributionEvent, OptionExercisePhysicalEvent, OptionExerciseCashEvent, ProtectionPayoutCashFlowEvent, TermDepositInterestEvent, TermDepositPrincipalEvent, EarlyRedemptionEvent, FutureMarkToMarketEvent, AdjustGlobalCommitmentEvent, ContractInitialisationEvent, DrawdownEvent, LoanInterestRepaymentEvent, UpdateDepositAmountEvent, LoanPrincipalRepaymentEvent, DepositInterestPaymentEvent, DepositCloseEvent, LoanFacilityContractRolloverEvent, RepurchaseOfferEvent, RepoPartialClosureEvent, RepoCashFlowEvent, FlexibleRepoInterestPaymentEvent, FlexibleRepoCashFlowEvent, FlexibleRepoCollateralEvent, ConversionEvent, FlexibleRepoPartialClosureEvent, FlexibleRepoFullClosureEvent, CapletFloorletCashFlowEvent, EarlyCloseOutEvent (required) (default to &quot;FlexibleRepoPartialClosureEvent&quot;).</param>
        public FlexibleRepoPartialClosureEvent(DateTimeOffset entitlementDate = default(DateTimeOffset), DateTimeOffset settlementDate = default(DateTimeOffset), decimal amount = default(decimal), string amountType = default(string), List<PartialClosureConstituent> partialClosureConstituents = default(List<PartialClosureConstituent>), InstrumentEventTypeEnum instrumentEventType = default(InstrumentEventTypeEnum)) : base(instrumentEventType)
        {
            this.Amount = amount;
            // to ensure "amountType" is required (not null)
            if (amountType == null)
            {
                throw new ArgumentNullException("amountType is a required property for FlexibleRepoPartialClosureEvent and cannot be null");
            }
            this.AmountType = amountType;
            // to ensure "partialClosureConstituents" is required (not null)
            if (partialClosureConstituents == null)
            {
                throw new ArgumentNullException("partialClosureConstituents is a required property for FlexibleRepoPartialClosureEvent and cannot be null");
            }
            this.PartialClosureConstituents = partialClosureConstituents;
            this.EntitlementDate = entitlementDate;
            this.SettlementDate = settlementDate;
        }

        /// <summary>
        /// Required property.  The date on which the counterparties become entitled   to exchange cash as part of a partial closure of the   repurchase agreement. The date must be before or on   the settlement date, and on or before the maturity   date of the repo.  This is a required field, unless otherwise supplied via \&quot;EventDateStamps\&quot; in  the instrument event upsert request.
        /// </summary>
        /// <value>Required property.  The date on which the counterparties become entitled   to exchange cash as part of a partial closure of the   repurchase agreement. The date must be before or on   the settlement date, and on or before the maturity   date of the repo.  This is a required field, unless otherwise supplied via \&quot;EventDateStamps\&quot; in  the instrument event upsert request.</value>
        [DataMember(Name = "entitlementDate", EmitDefaultValue = false)]
        public DateTimeOffset EntitlementDate { get; set; }

        /// <summary>
        /// Required property.  The date on which the exchange of cash is settled.   The date must be on or after the entitlement date,  and on or before the maturity date of the repo.  This is a required field, unless otherwise supplied via \&quot;EventDateStamps\&quot; in  the instrument event upsert request.
        /// </summary>
        /// <value>Required property.  The date on which the exchange of cash is settled.   The date must be on or after the entitlement date,  and on or before the maturity date of the repo.  This is a required field, unless otherwise supplied via \&quot;EventDateStamps\&quot; in  the instrument event upsert request.</value>
        [DataMember(Name = "settlementDate", EmitDefaultValue = false)]
        public DateTimeOffset SettlementDate { get; set; }

        /// <summary>
        /// The amount of cash to be exchanged as part of a partial closure of the repurchase agreement.  Either the absolute cash amount or a percentage of the remaining amount,  depending on the AmountType.
        /// </summary>
        /// <value>The amount of cash to be exchanged as part of a partial closure of the repurchase agreement.  Either the absolute cash amount or a percentage of the remaining amount,  depending on the AmountType.</value>
        [DataMember(Name = "amount", IsRequired = true, EmitDefaultValue = true)]
        public decimal Amount { get; set; }

        /// <summary>
        /// AmountType of the cash amount to be exchanged as part of a partial closure of the repurchase agreement.  Either percentage or absolute cash amount.    Supported string (enumeration) values are: [Percentage, Units].
        /// </summary>
        /// <value>AmountType of the cash amount to be exchanged as part of a partial closure of the repurchase agreement.  Either percentage or absolute cash amount.    Supported string (enumeration) values are: [Percentage, Units].</value>
        [DataMember(Name = "amountType", IsRequired = true, EmitDefaultValue = true)]
        public string AmountType { get; set; }

        /// <summary>
        /// List of the collateral instruments involved in this partial closure, along with how they are affected.
        /// </summary>
        /// <value>List of the collateral instruments involved in this partial closure, along with how they are affected.</value>
        [DataMember(Name = "partialClosureConstituents", IsRequired = true, EmitDefaultValue = true)]
        public List<PartialClosureConstituent> PartialClosureConstituents { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FlexibleRepoPartialClosureEvent {\n");
            sb.Append("  ").Append(base.ToString().Replace("\n", "\n  ")).Append("\n");
            sb.Append("  EntitlementDate: ").Append(EntitlementDate).Append("\n");
            sb.Append("  SettlementDate: ").Append(SettlementDate).Append("\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  AmountType: ").Append(AmountType).Append("\n");
            sb.Append("  PartialClosureConstituents: ").Append(PartialClosureConstituents).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public override string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FlexibleRepoPartialClosureEvent);
        }

        /// <summary>
        /// Returns true if FlexibleRepoPartialClosureEvent instances are equal
        /// </summary>
        /// <param name="input">Instance of FlexibleRepoPartialClosureEvent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FlexibleRepoPartialClosureEvent input)
        {
            if (input == null)
            {
                return false;
            }
            return base.Equals(input) && 
                (
                    this.EntitlementDate == input.EntitlementDate ||
                    (this.EntitlementDate != null &&
                    this.EntitlementDate.Equals(input.EntitlementDate))
                ) && base.Equals(input) && 
                (
                    this.SettlementDate == input.SettlementDate ||
                    (this.SettlementDate != null &&
                    this.SettlementDate.Equals(input.SettlementDate))
                ) && base.Equals(input) && 
                (
                    this.Amount == input.Amount ||
                    this.Amount.Equals(input.Amount)
                ) && base.Equals(input) && 
                (
                    this.AmountType == input.AmountType ||
                    (this.AmountType != null &&
                    this.AmountType.Equals(input.AmountType))
                ) && base.Equals(input) && 
                (
                    this.PartialClosureConstituents == input.PartialClosureConstituents ||
                    this.PartialClosureConstituents != null &&
                    input.PartialClosureConstituents != null &&
                    this.PartialClosureConstituents.SequenceEqual(input.PartialClosureConstituents)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.EntitlementDate != null)
                {
                    hashCode = (hashCode * 59) + this.EntitlementDate.GetHashCode();
                }
                if (this.SettlementDate != null)
                {
                    hashCode = (hashCode * 59) + this.SettlementDate.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Amount.GetHashCode();
                if (this.AmountType != null)
                {
                    hashCode = (hashCode * 59) + this.AmountType.GetHashCode();
                }
                if (this.PartialClosureConstituents != null)
                {
                    hashCode = (hashCode * 59) + this.PartialClosureConstituents.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            return this.BaseValidate(validationContext);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        protected IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> BaseValidate(ValidationContext validationContext)
        {
            foreach (var x in base.BaseValidate(validationContext))
            {
                yield return x;
            }
            // AmountType (string) minLength
            if (this.AmountType != null && this.AmountType.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AmountType, length must be greater than 1.", new [] { "AmountType" });
            }

            yield break;
        }
    }
}
