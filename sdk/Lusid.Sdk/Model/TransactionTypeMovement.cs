/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// TransactionTypeMovement
    /// </summary>
    [DataContract(Name = "TransactionTypeMovement")]
    public partial class TransactionTypeMovement : IEquatable<TransactionTypeMovement>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionTypeMovement" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TransactionTypeMovement() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionTypeMovement" /> class.
        /// </summary>
        /// <param name="movementTypes">Movement types determine the impact of the movement on the holdings. The available values are: Settlement, Traded, StockMovement, FutureCash,  Commitment, Receivable, CashSettlement, CashForward, CashCommitment, CashReceivable, Accrual, CashAccrual, ForwardFx, CashFxForward, Carry, CarryAsPnl, VariationMargin, Capital, Fee, Deferred, CashDeferred. (required).</param>
        /// <param name="side">The Side determines which of the fields from our transaction are used to generate the Movement. Side1 means the &#39;security&#39; side of the transaction, ie the Instrument and Units; Side2 means the &#39;cash&#39; side, ie the Total Consideration (required).</param>
        /// <param name="direction"> A multiplier to apply to Transaction amounts; the values are -1 to indicate to reverse the signs and 1 to indicate to use the signed values from the Transaction directly. For a typical Transaction with unsigned values, 1 means increase, -1 means decrease (required).</param>
        /// <param name="properties">The properties associated with the underlying Movement.</param>
        /// <param name="mappings">This allows you to map a transaction property to a property on the underlying holding.</param>
        /// <param name="name">The movement name (optional).</param>
        /// <param name="movementOptions">Allows extra specifications for the movement. The options currently available are &#39;DirectAdjustment&#39;, &#39;IncludesTradedInterest&#39;, &#39;Virtual&#39; and &#39;Income&#39; (works only with the movement type &#39;StockMovement&#39;). A movement type of &#39;StockMovement&#39; with an option of &#39;DirectAdjusment&#39; will allow you to adjust the units of a holding without affecting its cost base. You will, therefore, be able to reflect the impact of a stock split by loading a Transaction..</param>
        /// <param name="settlementDateOverride">Optional property key that must be in the Transaction domain when specified. When the movement is processed and the transaction has this property set to a valid date, then the property value will override the SettlementDate of the transaction..</param>
        /// <param name="condition">The condition that the transaction must satisfy to generate the movement, such as: Portfolio.BaseCurrency eq &#39;GBP&#39;. The condition can contain fields and properties from transactions and portfolios. If no condition is provided, the movement will apply for all transactions of this type..</param>
        /// <param name="settlementMode">Configures how movements should settle. Allowed values: &#39;Internal&#39; and &#39;External&#39;. A movement with &#39;Internal&#39; settlement mode will settle automatically on the contractual settlement date regardlesss of portfolio configuration or settlement instruction. An &#39;External&#39; movement can be settled automatically or by a settlement instruction..</param>
        /// <param name="calculateTradeDateToSettlementFxPnL">Configures whether Trade To Settlement Date Realised Gain Loss should be calculated. This overrides the value set at the Portfolio level.If null, then the Portfolio Settlement Configuration TradeToSettlementDateRealisedFxPnl setting will be used.If false, then no TradeToSettlementDateRealisedFxPnl will apply for this movement and if true, then TradeToSettlementDateRealisedFxPnlwill be calculated for this movement..</param>
        public TransactionTypeMovement(string movementTypes = default(string), string side = default(string), int direction = default(int), Dictionary<string, PerpetualProperty> properties = default(Dictionary<string, PerpetualProperty>), List<TransactionTypePropertyMapping> mappings = default(List<TransactionTypePropertyMapping>), string name = default(string), List<string> movementOptions = default(List<string>), string settlementDateOverride = default(string), string condition = default(string), string settlementMode = default(string), bool? calculateTradeDateToSettlementFxPnL = default(bool?))
        {
            // to ensure "movementTypes" is required (not null)
            if (movementTypes == null)
            {
                throw new ArgumentNullException("movementTypes is a required property for TransactionTypeMovement and cannot be null");
            }
            this.MovementTypes = movementTypes;
            // to ensure "side" is required (not null)
            if (side == null)
            {
                throw new ArgumentNullException("side is a required property for TransactionTypeMovement and cannot be null");
            }
            this.Side = side;
            this.Direction = direction;
            this.Properties = properties;
            this.Mappings = mappings;
            this.Name = name;
            this.MovementOptions = movementOptions;
            this.SettlementDateOverride = settlementDateOverride;
            this.Condition = condition;
            this.SettlementMode = settlementMode;
            this.CalculateTradeDateToSettlementFxPnL = calculateTradeDateToSettlementFxPnL;
        }

        /// <summary>
        /// Movement types determine the impact of the movement on the holdings. The available values are: Settlement, Traded, StockMovement, FutureCash,  Commitment, Receivable, CashSettlement, CashForward, CashCommitment, CashReceivable, Accrual, CashAccrual, ForwardFx, CashFxForward, Carry, CarryAsPnl, VariationMargin, Capital, Fee, Deferred, CashDeferred.
        /// </summary>
        /// <value>Movement types determine the impact of the movement on the holdings. The available values are: Settlement, Traded, StockMovement, FutureCash,  Commitment, Receivable, CashSettlement, CashForward, CashCommitment, CashReceivable, Accrual, CashAccrual, ForwardFx, CashFxForward, Carry, CarryAsPnl, VariationMargin, Capital, Fee, Deferred, CashDeferred.</value>
        [DataMember(Name = "movementTypes", IsRequired = true, EmitDefaultValue = true)]
        public string MovementTypes { get; set; }

        /// <summary>
        /// The Side determines which of the fields from our transaction are used to generate the Movement. Side1 means the &#39;security&#39; side of the transaction, ie the Instrument and Units; Side2 means the &#39;cash&#39; side, ie the Total Consideration
        /// </summary>
        /// <value>The Side determines which of the fields from our transaction are used to generate the Movement. Side1 means the &#39;security&#39; side of the transaction, ie the Instrument and Units; Side2 means the &#39;cash&#39; side, ie the Total Consideration</value>
        [DataMember(Name = "side", IsRequired = true, EmitDefaultValue = true)]
        public string Side { get; set; }

        /// <summary>
        ///  A multiplier to apply to Transaction amounts; the values are -1 to indicate to reverse the signs and 1 to indicate to use the signed values from the Transaction directly. For a typical Transaction with unsigned values, 1 means increase, -1 means decrease
        /// </summary>
        /// <value> A multiplier to apply to Transaction amounts; the values are -1 to indicate to reverse the signs and 1 to indicate to use the signed values from the Transaction directly. For a typical Transaction with unsigned values, 1 means increase, -1 means decrease</value>
        [DataMember(Name = "direction", IsRequired = true, EmitDefaultValue = true)]
        public int Direction { get; set; }

        /// <summary>
        /// The properties associated with the underlying Movement
        /// </summary>
        /// <value>The properties associated with the underlying Movement</value>
        [DataMember(Name = "properties", EmitDefaultValue = true)]
        public Dictionary<string, PerpetualProperty> Properties { get; set; }

        /// <summary>
        /// This allows you to map a transaction property to a property on the underlying holding
        /// </summary>
        /// <value>This allows you to map a transaction property to a property on the underlying holding</value>
        [DataMember(Name = "mappings", EmitDefaultValue = true)]
        public List<TransactionTypePropertyMapping> Mappings { get; set; }

        /// <summary>
        /// The movement name (optional)
        /// </summary>
        /// <value>The movement name (optional)</value>
        [DataMember(Name = "name", EmitDefaultValue = true)]
        public string Name { get; set; }

        /// <summary>
        /// Allows extra specifications for the movement. The options currently available are &#39;DirectAdjustment&#39;, &#39;IncludesTradedInterest&#39;, &#39;Virtual&#39; and &#39;Income&#39; (works only with the movement type &#39;StockMovement&#39;). A movement type of &#39;StockMovement&#39; with an option of &#39;DirectAdjusment&#39; will allow you to adjust the units of a holding without affecting its cost base. You will, therefore, be able to reflect the impact of a stock split by loading a Transaction.
        /// </summary>
        /// <value>Allows extra specifications for the movement. The options currently available are &#39;DirectAdjustment&#39;, &#39;IncludesTradedInterest&#39;, &#39;Virtual&#39; and &#39;Income&#39; (works only with the movement type &#39;StockMovement&#39;). A movement type of &#39;StockMovement&#39; with an option of &#39;DirectAdjusment&#39; will allow you to adjust the units of a holding without affecting its cost base. You will, therefore, be able to reflect the impact of a stock split by loading a Transaction.</value>
        [DataMember(Name = "movementOptions", EmitDefaultValue = true)]
        public List<string> MovementOptions { get; set; }

        /// <summary>
        /// Optional property key that must be in the Transaction domain when specified. When the movement is processed and the transaction has this property set to a valid date, then the property value will override the SettlementDate of the transaction.
        /// </summary>
        /// <value>Optional property key that must be in the Transaction domain when specified. When the movement is processed and the transaction has this property set to a valid date, then the property value will override the SettlementDate of the transaction.</value>
        [DataMember(Name = "settlementDateOverride", EmitDefaultValue = true)]
        public string SettlementDateOverride { get; set; }

        /// <summary>
        /// The condition that the transaction must satisfy to generate the movement, such as: Portfolio.BaseCurrency eq &#39;GBP&#39;. The condition can contain fields and properties from transactions and portfolios. If no condition is provided, the movement will apply for all transactions of this type.
        /// </summary>
        /// <value>The condition that the transaction must satisfy to generate the movement, such as: Portfolio.BaseCurrency eq &#39;GBP&#39;. The condition can contain fields and properties from transactions and portfolios. If no condition is provided, the movement will apply for all transactions of this type.</value>
        [DataMember(Name = "condition", EmitDefaultValue = true)]
        public string Condition { get; set; }

        /// <summary>
        /// Configures how movements should settle. Allowed values: &#39;Internal&#39; and &#39;External&#39;. A movement with &#39;Internal&#39; settlement mode will settle automatically on the contractual settlement date regardlesss of portfolio configuration or settlement instruction. An &#39;External&#39; movement can be settled automatically or by a settlement instruction.
        /// </summary>
        /// <value>Configures how movements should settle. Allowed values: &#39;Internal&#39; and &#39;External&#39;. A movement with &#39;Internal&#39; settlement mode will settle automatically on the contractual settlement date regardlesss of portfolio configuration or settlement instruction. An &#39;External&#39; movement can be settled automatically or by a settlement instruction.</value>
        [DataMember(Name = "settlementMode", EmitDefaultValue = true)]
        public string SettlementMode { get; set; }

        /// <summary>
        /// Configures whether Trade To Settlement Date Realised Gain Loss should be calculated. This overrides the value set at the Portfolio level.If null, then the Portfolio Settlement Configuration TradeToSettlementDateRealisedFxPnl setting will be used.If false, then no TradeToSettlementDateRealisedFxPnl will apply for this movement and if true, then TradeToSettlementDateRealisedFxPnlwill be calculated for this movement.
        /// </summary>
        /// <value>Configures whether Trade To Settlement Date Realised Gain Loss should be calculated. This overrides the value set at the Portfolio level.If null, then the Portfolio Settlement Configuration TradeToSettlementDateRealisedFxPnl setting will be used.If false, then no TradeToSettlementDateRealisedFxPnl will apply for this movement and if true, then TradeToSettlementDateRealisedFxPnlwill be calculated for this movement.</value>
        [DataMember(Name = "calculateTradeDateToSettlementFxPnL", EmitDefaultValue = true)]
        public bool? CalculateTradeDateToSettlementFxPnL { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TransactionTypeMovement {\n");
            sb.Append("  MovementTypes: ").Append(MovementTypes).Append("\n");
            sb.Append("  Side: ").Append(Side).Append("\n");
            sb.Append("  Direction: ").Append(Direction).Append("\n");
            sb.Append("  Properties: ").Append(Properties).Append("\n");
            sb.Append("  Mappings: ").Append(Mappings).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  MovementOptions: ").Append(MovementOptions).Append("\n");
            sb.Append("  SettlementDateOverride: ").Append(SettlementDateOverride).Append("\n");
            sb.Append("  Condition: ").Append(Condition).Append("\n");
            sb.Append("  SettlementMode: ").Append(SettlementMode).Append("\n");
            sb.Append("  CalculateTradeDateToSettlementFxPnL: ").Append(CalculateTradeDateToSettlementFxPnL).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TransactionTypeMovement);
        }

        /// <summary>
        /// Returns true if TransactionTypeMovement instances are equal
        /// </summary>
        /// <param name="input">Instance of TransactionTypeMovement to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TransactionTypeMovement input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.MovementTypes == input.MovementTypes ||
                    (this.MovementTypes != null &&
                    this.MovementTypes.Equals(input.MovementTypes))
                ) && 
                (
                    this.Side == input.Side ||
                    (this.Side != null &&
                    this.Side.Equals(input.Side))
                ) && 
                (
                    this.Direction == input.Direction ||
                    this.Direction.Equals(input.Direction)
                ) && 
                (
                    this.Properties == input.Properties ||
                    this.Properties != null &&
                    input.Properties != null &&
                    this.Properties.SequenceEqual(input.Properties)
                ) && 
                (
                    this.Mappings == input.Mappings ||
                    this.Mappings != null &&
                    input.Mappings != null &&
                    this.Mappings.SequenceEqual(input.Mappings)
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.MovementOptions == input.MovementOptions ||
                    this.MovementOptions != null &&
                    input.MovementOptions != null &&
                    this.MovementOptions.SequenceEqual(input.MovementOptions)
                ) && 
                (
                    this.SettlementDateOverride == input.SettlementDateOverride ||
                    (this.SettlementDateOverride != null &&
                    this.SettlementDateOverride.Equals(input.SettlementDateOverride))
                ) && 
                (
                    this.Condition == input.Condition ||
                    (this.Condition != null &&
                    this.Condition.Equals(input.Condition))
                ) && 
                (
                    this.SettlementMode == input.SettlementMode ||
                    (this.SettlementMode != null &&
                    this.SettlementMode.Equals(input.SettlementMode))
                ) && 
                (
                    this.CalculateTradeDateToSettlementFxPnL == input.CalculateTradeDateToSettlementFxPnL ||
                    (this.CalculateTradeDateToSettlementFxPnL != null &&
                    this.CalculateTradeDateToSettlementFxPnL.Equals(input.CalculateTradeDateToSettlementFxPnL))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.MovementTypes != null)
                {
                    hashCode = (hashCode * 59) + this.MovementTypes.GetHashCode();
                }
                if (this.Side != null)
                {
                    hashCode = (hashCode * 59) + this.Side.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Direction.GetHashCode();
                if (this.Properties != null)
                {
                    hashCode = (hashCode * 59) + this.Properties.GetHashCode();
                }
                if (this.Mappings != null)
                {
                    hashCode = (hashCode * 59) + this.Mappings.GetHashCode();
                }
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                if (this.MovementOptions != null)
                {
                    hashCode = (hashCode * 59) + this.MovementOptions.GetHashCode();
                }
                if (this.SettlementDateOverride != null)
                {
                    hashCode = (hashCode * 59) + this.SettlementDateOverride.GetHashCode();
                }
                if (this.Condition != null)
                {
                    hashCode = (hashCode * 59) + this.Condition.GetHashCode();
                }
                if (this.SettlementMode != null)
                {
                    hashCode = (hashCode * 59) + this.SettlementMode.GetHashCode();
                }
                if (this.CalculateTradeDateToSettlementFxPnL != null)
                {
                    hashCode = (hashCode * 59) + this.CalculateTradeDateToSettlementFxPnL.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // MovementTypes (string) minLength
            if (this.MovementTypes != null && this.MovementTypes.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MovementTypes, length must be greater than 1.", new [] { "MovementTypes" });
            }

            // Side (string) maxLength
            if (this.Side != null && this.Side.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Side, length must be less than 64.", new [] { "Side" });
            }

            // Side (string) minLength
            if (this.Side != null && this.Side.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Side, length must be greater than 1.", new [] { "Side" });
            }

            // Side (string) pattern
            Regex regexSide = new Regex(@"^[a-zA-Z0-9\-_]+$", RegexOptions.CultureInvariant);
            if (false == regexSide.Match(this.Side).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Side, must match a pattern of " + regexSide, new [] { "Side" });
            }

            // Name (string) maxLength
            if (this.Name != null && this.Name.Length > 512)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be less than 512.", new [] { "Name" });
            }

            // Name (string) minLength
            if (this.Name != null && this.Name.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be greater than 1.", new [] { "Name" });
            }

            // Name (string) pattern
            Regex regexName = new Regex(@"^[\s\S]*$", RegexOptions.CultureInvariant);
            if (false == regexName.Match(this.Name).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, must match a pattern of " + regexName, new [] { "Name" });
            }

            // Condition (string) maxLength
            if (this.Condition != null && this.Condition.Length > 16384)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Condition, length must be less than 16384.", new [] { "Condition" });
            }

            // Condition (string) minLength
            if (this.Condition != null && this.Condition.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Condition, length must be greater than 0.", new [] { "Condition" });
            }

            // Condition (string) pattern
            Regex regexCondition = new Regex(@"^[\s\S]*$", RegexOptions.CultureInvariant);
            if (false == regexCondition.Match(this.Condition).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Condition, must match a pattern of " + regexCondition, new [] { "Condition" });
            }

            yield break;
        }
    }
}
