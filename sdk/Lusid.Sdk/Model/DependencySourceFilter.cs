/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Lusid.Sdk.Client.OpenAPIDateConverter;

namespace Lusid.Sdk.Model
{
    /// <summary>
    /// Encapsulates parts of a market data rule relating not to the nature of the market data requested, but rather the nature of the thing (instrument/model) that is requesting it.  In the first instance, this includes the instrument type, asset class, and the currency of the underlying instrument.  This can be used to differentiate requests for market data according to the source of the request. See MarketDataSpecificRule.
    /// </summary>
    [DataContract(Name = "DependencySourceFilter")]
    public partial class DependencySourceFilter : IEquatable<DependencySourceFilter>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DependencySourceFilter" /> class.
        /// </summary>
        /// <param name="instrumentType">Specify that a rule should only apply if the market data is requested by an instrument of a given instrument type.  If null, then no filtering on instrument type is applied..</param>
        /// <param name="assetClass">Specify that a rule should only apply if the market data is requested by an instrument of a given asset class.  If null, then no filtering on asset class is applied..</param>
        /// <param name="domCcy">Specify that a rule should only apply if the market data is requested by an instrument with a given domestic currency.  If null, then no filtering on currency is applied..</param>
        /// <param name="longOrShortIndicator">Specify that a rule should apply if the market data is requested by a model with a given long or short indicator.  If none, then no filtering on LongOrShortIndicator is applied..</param>
        public DependencySourceFilter(string instrumentType = default(string), string assetClass = default(string), string domCcy = default(string), string longOrShortIndicator = default(string))
        {
            this.InstrumentType = instrumentType;
            this.AssetClass = assetClass;
            this.DomCcy = domCcy;
            this.LongOrShortIndicator = longOrShortIndicator;
        }

        /// <summary>
        /// Specify that a rule should only apply if the market data is requested by an instrument of a given instrument type.  If null, then no filtering on instrument type is applied.
        /// </summary>
        /// <value>Specify that a rule should only apply if the market data is requested by an instrument of a given instrument type.  If null, then no filtering on instrument type is applied.</value>
        [DataMember(Name = "instrumentType", EmitDefaultValue = true)]
        public string InstrumentType { get; set; }

        /// <summary>
        /// Specify that a rule should only apply if the market data is requested by an instrument of a given asset class.  If null, then no filtering on asset class is applied.
        /// </summary>
        /// <value>Specify that a rule should only apply if the market data is requested by an instrument of a given asset class.  If null, then no filtering on asset class is applied.</value>
        [DataMember(Name = "assetClass", EmitDefaultValue = true)]
        public string AssetClass { get; set; }

        /// <summary>
        /// Specify that a rule should only apply if the market data is requested by an instrument with a given domestic currency.  If null, then no filtering on currency is applied.
        /// </summary>
        /// <value>Specify that a rule should only apply if the market data is requested by an instrument with a given domestic currency.  If null, then no filtering on currency is applied.</value>
        [DataMember(Name = "domCcy", EmitDefaultValue = true)]
        public string DomCcy { get; set; }

        /// <summary>
        /// Specify that a rule should apply if the market data is requested by a model with a given long or short indicator.  If none, then no filtering on LongOrShortIndicator is applied.
        /// </summary>
        /// <value>Specify that a rule should apply if the market data is requested by a model with a given long or short indicator.  If none, then no filtering on LongOrShortIndicator is applied.</value>
        [DataMember(Name = "longOrShortIndicator", EmitDefaultValue = true)]
        public string LongOrShortIndicator { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DependencySourceFilter {\n");
            sb.Append("  InstrumentType: ").Append(InstrumentType).Append("\n");
            sb.Append("  AssetClass: ").Append(AssetClass).Append("\n");
            sb.Append("  DomCcy: ").Append(DomCcy).Append("\n");
            sb.Append("  LongOrShortIndicator: ").Append(LongOrShortIndicator).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DependencySourceFilter);
        }

        /// <summary>
        /// Returns true if DependencySourceFilter instances are equal
        /// </summary>
        /// <param name="input">Instance of DependencySourceFilter to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DependencySourceFilter input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.InstrumentType == input.InstrumentType ||
                    (this.InstrumentType != null &&
                    this.InstrumentType.Equals(input.InstrumentType))
                ) && 
                (
                    this.AssetClass == input.AssetClass ||
                    (this.AssetClass != null &&
                    this.AssetClass.Equals(input.AssetClass))
                ) && 
                (
                    this.DomCcy == input.DomCcy ||
                    (this.DomCcy != null &&
                    this.DomCcy.Equals(input.DomCcy))
                ) && 
                (
                    this.LongOrShortIndicator == input.LongOrShortIndicator ||
                    (this.LongOrShortIndicator != null &&
                    this.LongOrShortIndicator.Equals(input.LongOrShortIndicator))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.InstrumentType != null)
                {
                    hashCode = (hashCode * 59) + this.InstrumentType.GetHashCode();
                }
                if (this.AssetClass != null)
                {
                    hashCode = (hashCode * 59) + this.AssetClass.GetHashCode();
                }
                if (this.DomCcy != null)
                {
                    hashCode = (hashCode * 59) + this.DomCcy.GetHashCode();
                }
                if (this.LongOrShortIndicator != null)
                {
                    hashCode = (hashCode * 59) + this.LongOrShortIndicator.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // InstrumentType (string) maxLength
            if (this.InstrumentType != null && this.InstrumentType.Length > 32)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for InstrumentType, length must be less than 32.", new [] { "InstrumentType" });
            }

            // InstrumentType (string) minLength
            if (this.InstrumentType != null && this.InstrumentType.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for InstrumentType, length must be greater than 0.", new [] { "InstrumentType" });
            }

            // AssetClass (string) maxLength
            if (this.AssetClass != null && this.AssetClass.Length > 32)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AssetClass, length must be less than 32.", new [] { "AssetClass" });
            }

            // AssetClass (string) minLength
            if (this.AssetClass != null && this.AssetClass.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AssetClass, length must be greater than 0.", new [] { "AssetClass" });
            }

            yield break;
        }
    }
}
