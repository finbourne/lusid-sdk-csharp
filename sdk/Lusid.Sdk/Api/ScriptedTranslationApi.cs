/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using Object = System.Object;
using InvalidOperationException = System.InvalidOperationException;
using Exception = System.Exception;
using ArgumentNullException = System.ArgumentNullException;
using SystemEventHandler = System.EventHandler;
using DateTimeOffset = System.DateTimeOffset;
using Guid = System.Guid;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Lusid.Sdk.Client;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IScriptedTranslationApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect.
        /// </summary>
        /// <remarks>
        /// Get the dialect with the given identifier at the specific asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Dialect</returns>
        Dialect GetTranslationDialect(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect.
        /// </summary>
        /// <remarks>
        /// Get the dialect with the given identifier at the specific asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Dialect</returns>
        ApiResponse<Dialect> GetTranslationDialectWithHttpInfo(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier.
        /// </summary>
        /// <remarks>
        /// Retrieves a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslationScript</returns>
        TranslationScript GetTranslationScript(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier.
        /// </summary>
        /// <remarks>
        /// Retrieves a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslationScript</returns>
        ApiResponse<TranslationScript> GetTranslationScriptWithHttpInfo(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter.
        /// </summary>
        /// <remarks>
        /// List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfDialectId</returns>
        PagedResourceListOfDialectId ListDialectIds(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter.
        /// </summary>
        /// <remarks>
        /// List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfDialectId</returns>
        ApiResponse<PagedResourceListOfDialectId> ListDialectIdsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers.
        /// </summary>
        /// <remarks>
        /// List translation script ids.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfTranslationScriptId</returns>
        PagedResourceListOfTranslationScriptId ListTranslationScriptIds(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers.
        /// </summary>
        /// <remarks>
        /// List translation script ids.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfTranslationScriptId</returns>
        ApiResponse<PagedResourceListOfTranslationScriptId> ListTranslationScriptIdsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslateEntitiesResponse</returns>
        TranslateEntitiesResponse TranslateEntities(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslateEntitiesResponse</returns>
        ApiResponse<TranslateEntitiesResponse> TranslateEntitiesWithHttpInfo(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslateEntitiesResponse</returns>
        TranslateEntitiesResponse TranslateEntitiesInlined(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslateEntitiesResponse</returns>
        ApiResponse<TranslateEntitiesResponse> TranslateEntitiesInlinedWithHttpInfo(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect.
        /// </summary>
        /// <remarks>
        /// Upsert the given dialect.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Dialect</returns>
        Dialect UpsertTranslationDialect(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect.
        /// </summary>
        /// <remarks>
        /// Upsert the given dialect.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Dialect</returns>
        ApiResponse<Dialect> UpsertTranslationDialectWithHttpInfo(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0);
        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script.
        /// </summary>
        /// <remarks>
        /// Upserts a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslationScript</returns>
        TranslationScript UpsertTranslationScript(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0);

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script.
        /// </summary>
        /// <remarks>
        /// Upserts a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslationScript</returns>
        ApiResponse<TranslationScript> UpsertTranslationScriptWithHttpInfo(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IScriptedTranslationApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect.
        /// </summary>
        /// <remarks>
        /// Get the dialect with the given identifier at the specific asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dialect</returns>
        System.Threading.Tasks.Task<Dialect> GetTranslationDialectAsync(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect.
        /// </summary>
        /// <remarks>
        /// Get the dialect with the given identifier at the specific asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dialect)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dialect>> GetTranslationDialectWithHttpInfoAsync(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier.
        /// </summary>
        /// <remarks>
        /// Retrieves a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslationScript</returns>
        System.Threading.Tasks.Task<TranslationScript> GetTranslationScriptAsync(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier.
        /// </summary>
        /// <remarks>
        /// Retrieves a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslationScript)</returns>
        System.Threading.Tasks.Task<ApiResponse<TranslationScript>> GetTranslationScriptWithHttpInfoAsync(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter.
        /// </summary>
        /// <remarks>
        /// List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfDialectId</returns>
        System.Threading.Tasks.Task<PagedResourceListOfDialectId> ListDialectIdsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter.
        /// </summary>
        /// <remarks>
        /// List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfDialectId)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfDialectId>> ListDialectIdsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers.
        /// </summary>
        /// <remarks>
        /// List translation script ids.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfTranslationScriptId</returns>
        System.Threading.Tasks.Task<PagedResourceListOfTranslationScriptId> ListTranslationScriptIdsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers.
        /// </summary>
        /// <remarks>
        /// List translation script ids.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfTranslationScriptId)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfTranslationScriptId>> ListTranslationScriptIdsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslateEntitiesResponse</returns>
        System.Threading.Tasks.Task<TranslateEntitiesResponse> TranslateEntitiesAsync(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslateEntitiesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<TranslateEntitiesResponse>> TranslateEntitiesWithHttpInfoAsync(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslateEntitiesResponse</returns>
        System.Threading.Tasks.Task<TranslateEntitiesResponse> TranslateEntitiesInlinedAsync(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script.
        /// </summary>
        /// <remarks>
        /// Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslateEntitiesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<TranslateEntitiesResponse>> TranslateEntitiesInlinedWithHttpInfoAsync(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect.
        /// </summary>
        /// <remarks>
        /// Upsert the given dialect.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dialect</returns>
        System.Threading.Tasks.Task<Dialect> UpsertTranslationDialectAsync(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect.
        /// </summary>
        /// <remarks>
        /// Upsert the given dialect.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dialect)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dialect>> UpsertTranslationDialectWithHttpInfoAsync(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script.
        /// </summary>
        /// <remarks>
        /// Upserts a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslationScript</returns>
        System.Threading.Tasks.Task<TranslationScript> UpsertTranslationScriptAsync(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script.
        /// </summary>
        /// <remarks>
        /// Upserts a translation script to be used for translating financial entities.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslationScript)</returns>
        System.Threading.Tasks.Task<ApiResponse<TranslationScript>> UpsertTranslationScriptWithHttpInfoAsync(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IScriptedTranslationApi : IScriptedTranslationApiSync, IScriptedTranslationApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ScriptedTranslationApi : IScriptedTranslationApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptedTranslationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ScriptedTranslationApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptedTranslationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ScriptedTranslationApi(string basePath)
        {
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                Lusid.Sdk.Client.GlobalConfiguration.Instance,
                new Lusid.Sdk.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptedTranslationApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ScriptedTranslationApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptedTranslationApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ScriptedTranslationApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect. Get the dialect with the given identifier at the specific asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Dialect</returns>
        public Dialect GetTranslationDialect(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Dialect> localVarResponse = GetTranslationDialectWithHttpInfo(scope, vendor, sourceSystem, entityType, serialisationFormat, version, asAt);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect. Get the dialect with the given identifier at the specific asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Dialect</returns>
        public Lusid.Sdk.Client.ApiResponse<Dialect> GetTranslationDialectWithHttpInfo(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'vendor' is set
            if (vendor == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'vendor' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'sourceSystem' is set
            if (sourceSystem == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'sourceSystem' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'serialisationFormat' is set
            if (serialisationFormat == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'serialisationFormat' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'version' is set
            if (version == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'version' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("vendor", Lusid.Sdk.Client.ClientUtils.ParameterToString(vendor)); // path parameter
            localVarRequestOptions.PathParameters.Add("sourceSystem", Lusid.Sdk.Client.ClientUtils.ParameterToString(sourceSystem)); // path parameter
            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("serialisationFormat", Lusid.Sdk.Client.ClientUtils.ParameterToString(serialisationFormat)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.GetTranslationDialect";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Dialect>("/api/scriptedtranslation/dialects/{scope}/{vendor}/{sourceSystem}/{entityType}/{serialisationFormat}/{version}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTranslationDialect", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect. Get the dialect with the given identifier at the specific asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dialect</returns>
        public async System.Threading.Tasks.Task<Dialect> GetTranslationDialectAsync(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Dialect> localVarResponse = await GetTranslationDialectWithHttpInfoAsync(scope, vendor, sourceSystem, entityType, serialisationFormat, version, asAt, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationDialect: Get a dialect. Get the dialect with the given identifier at the specific asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the dialect.</param>
        /// <param name="vendor">The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE.</param>
        /// <param name="sourceSystem">The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib.</param>
        /// <param name="entityType">The type of entity this dialect describes e.g. Instrument.</param>
        /// <param name="serialisationFormat">The serialisation format of a document in this dialect. e.g. JSON, XML.</param>
        /// <param name="version">The semantic version of the dialect: MAJOR.MINOR.PATCH.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dialect)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dialect>> GetTranslationDialectWithHttpInfoAsync(string scope, string vendor, string sourceSystem, string entityType, string serialisationFormat, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'vendor' is set
            if (vendor == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'vendor' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'sourceSystem' is set
            if (sourceSystem == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'sourceSystem' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'serialisationFormat' is set
            if (serialisationFormat == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'serialisationFormat' when calling ScriptedTranslationApi->GetTranslationDialect");
            }

            // verify the required parameter 'version' is set
            if (version == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'version' when calling ScriptedTranslationApi->GetTranslationDialect");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("vendor", Lusid.Sdk.Client.ClientUtils.ParameterToString(vendor)); // path parameter
            localVarRequestOptions.PathParameters.Add("sourceSystem", Lusid.Sdk.Client.ClientUtils.ParameterToString(sourceSystem)); // path parameter
            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("serialisationFormat", Lusid.Sdk.Client.ClientUtils.ParameterToString(serialisationFormat)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.GetTranslationDialect";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Dialect>("/api/scriptedtranslation/dialects/{scope}/{vendor}/{sourceSystem}/{entityType}/{serialisationFormat}/{version}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTranslationDialect", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier. Retrieves a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslationScript</returns>
        public TranslationScript GetTranslationScript(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<TranslationScript> localVarResponse = GetTranslationScriptWithHttpInfo(scope, code, version, asAt);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier. Retrieves a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslationScript</returns>
        public Lusid.Sdk.Client.ApiResponse<TranslationScript> GetTranslationScriptWithHttpInfo(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ScriptedTranslationApi->GetTranslationScript");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ScriptedTranslationApi->GetTranslationScript");
            }

            // verify the required parameter 'version' is set
            if (version == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'version' when calling ScriptedTranslationApi->GetTranslationScript");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.GetTranslationScript";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<TranslationScript>("/api/scriptedtranslation/scripts/{scope}/{code}/{version}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTranslationScript", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier. Retrieves a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslationScript</returns>
        public async System.Threading.Tasks.Task<TranslationScript> GetTranslationScriptAsync(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<TranslationScript> localVarResponse = await GetTranslationScriptWithHttpInfoAsync(scope, code, version, asAt, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier. Retrieves a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the translation script.</param>
        /// <param name="code">Code of the translation script.</param>
        /// <param name="version">Semantic version of the translation script.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the translation script. Defaults to latest. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslationScript)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TranslationScript>> GetTranslationScriptWithHttpInfoAsync(string scope, string code, string version, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling ScriptedTranslationApi->GetTranslationScript");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling ScriptedTranslationApi->GetTranslationScript");
            }

            // verify the required parameter 'version' is set
            if (version == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'version' when calling ScriptedTranslationApi->GetTranslationScript");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("version", Lusid.Sdk.Client.ClientUtils.ParameterToString(version)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.GetTranslationScript";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<TranslationScript>("/api/scriptedtranslation/scripts/{scope}/{code}/{version}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTranslationScript", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter. List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfDialectId</returns>
        public PagedResourceListOfDialectId ListDialectIds(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfDialectId> localVarResponse = ListDialectIdsWithHttpInfo(asAt, page, limit, filter);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter. List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfDialectId</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfDialectId> ListDialectIdsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.ListDialectIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfDialectId>("/api/scriptedtranslation/dialects/ids", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListDialectIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter. List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfDialectId</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfDialectId> ListDialectIdsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfDialectId> localVarResponse = await ListDialectIdsWithHttpInfoAsync(asAt, page, limit, filter, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter. List the stored dialects&#39; identifiers with pagination and filtering at the specified asAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfDialectId)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfDialectId>> ListDialectIdsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.ListDialectIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfDialectId>("/api/scriptedtranslation/dialects/ids", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListDialectIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers. List translation script ids.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PagedResourceListOfTranslationScriptId</returns>
        public PagedResourceListOfTranslationScriptId ListTranslationScriptIds(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfTranslationScriptId> localVarResponse = ListTranslationScriptIdsWithHttpInfo(asAt, limit, filter, page);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers. List translation script ids.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PagedResourceListOfTranslationScriptId</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfTranslationScriptId> ListTranslationScriptIdsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.ListTranslationScriptIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfTranslationScriptId>("/api/scriptedtranslation/scripts/ids", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTranslationScriptIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers. List translation script ids.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PagedResourceListOfTranslationScriptId</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfTranslationScriptId> ListTranslationScriptIdsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfTranslationScriptId> localVarResponse = await ListTranslationScriptIdsWithHttpInfoAsync(asAt, limit, filter, page, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers. List translation script ids.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the script identifiers. Defaults to latest. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq &#39;my-scripts&#39; to list result only for a particular scope. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfTranslationScriptId)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfTranslationScriptId>> ListTranslationScriptIdsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), string? page = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }

            localVarRequestOptions.Operation = "ScriptedTranslationApi.ListTranslationScriptIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfTranslationScriptId>("/api/scriptedtranslation/scripts/ids", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTranslationScriptIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script. Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslateEntitiesResponse</returns>
        public TranslateEntitiesResponse TranslateEntities(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse> localVarResponse = TranslateEntitiesWithHttpInfo(translateEntitiesRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script. Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslateEntitiesResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse> TranslateEntitiesWithHttpInfo(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0)
        {
            // verify the required parameter 'translateEntitiesRequest' is set
            if (translateEntitiesRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'translateEntitiesRequest' when calling ScriptedTranslationApi->TranslateEntities");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = translateEntitiesRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.TranslateEntities";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<TranslateEntitiesResponse>("/api/scriptedtranslation/translateentities", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TranslateEntities", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script. Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslateEntitiesResponse</returns>
        public async System.Threading.Tasks.Task<TranslateEntitiesResponse> TranslateEntitiesAsync(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse> localVarResponse = await TranslateEntitiesWithHttpInfoAsync(translateEntitiesRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script. Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesRequest">The entities to translate, along with identifiers for the script and (optional) dialect to use.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslateEntitiesResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse>> TranslateEntitiesWithHttpInfoAsync(TranslateEntitiesRequest translateEntitiesRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'translateEntitiesRequest' is set
            if (translateEntitiesRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'translateEntitiesRequest' when calling ScriptedTranslationApi->TranslateEntities");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = translateEntitiesRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.TranslateEntities";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<TranslateEntitiesResponse>("/api/scriptedtranslation/translateentities", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TranslateEntities", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script. Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslateEntitiesResponse</returns>
        public TranslateEntitiesResponse TranslateEntitiesInlined(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse> localVarResponse = TranslateEntitiesInlinedWithHttpInfo(translateEntitiesInlinedRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script. Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslateEntitiesResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse> TranslateEntitiesInlinedWithHttpInfo(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0)
        {
            // verify the required parameter 'translateEntitiesInlinedRequest' is set
            if (translateEntitiesInlinedRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'translateEntitiesInlinedRequest' when calling ScriptedTranslationApi->TranslateEntitiesInlined");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = translateEntitiesInlinedRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.TranslateEntitiesInlined";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<TranslateEntitiesResponse>("/api/scriptedtranslation/translateentitiesinlined", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TranslateEntitiesInlined", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script. Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslateEntitiesResponse</returns>
        public async System.Threading.Tasks.Task<TranslateEntitiesResponse> TranslateEntitiesInlinedAsync(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse> localVarResponse = await TranslateEntitiesInlinedWithHttpInfoAsync(translateEntitiesInlinedRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script. Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="translateEntitiesInlinedRequest">The entities to translate, along with the script to use and an optional schema for validation.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslateEntitiesResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TranslateEntitiesResponse>> TranslateEntitiesInlinedWithHttpInfoAsync(TranslateEntitiesInlinedRequest translateEntitiesInlinedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'translateEntitiesInlinedRequest' is set
            if (translateEntitiesInlinedRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'translateEntitiesInlinedRequest' when calling ScriptedTranslationApi->TranslateEntitiesInlined");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = translateEntitiesInlinedRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.TranslateEntitiesInlined";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<TranslateEntitiesResponse>("/api/scriptedtranslation/translateentitiesinlined", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TranslateEntitiesInlined", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect. Upsert the given dialect.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Dialect</returns>
        public Dialect UpsertTranslationDialect(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<Dialect> localVarResponse = UpsertTranslationDialectWithHttpInfo(upsertDialectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect. Upsert the given dialect.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Dialect</returns>
        public Lusid.Sdk.Client.ApiResponse<Dialect> UpsertTranslationDialectWithHttpInfo(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0)
        {
            // verify the required parameter 'upsertDialectRequest' is set
            if (upsertDialectRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'upsertDialectRequest' when calling ScriptedTranslationApi->UpsertTranslationDialect");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = upsertDialectRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.UpsertTranslationDialect";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Dialect>("/api/scriptedtranslation/dialects", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertTranslationDialect", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect. Upsert the given dialect.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dialect</returns>
        public async System.Threading.Tasks.Task<Dialect> UpsertTranslationDialectAsync(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<Dialect> localVarResponse = await UpsertTranslationDialectWithHttpInfoAsync(upsertDialectRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect. Upsert the given dialect.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertDialectRequest">The dialect to upsert.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dialect)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dialect>> UpsertTranslationDialectWithHttpInfoAsync(UpsertDialectRequest upsertDialectRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'upsertDialectRequest' is set
            if (upsertDialectRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'upsertDialectRequest' when calling ScriptedTranslationApi->UpsertTranslationDialect");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = upsertDialectRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.UpsertTranslationDialect";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Dialect>("/api/scriptedtranslation/dialects", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertTranslationDialect", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script. Upserts a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TranslationScript</returns>
        public TranslationScript UpsertTranslationScript(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0)
        {
            Lusid.Sdk.Client.ApiResponse<TranslationScript> localVarResponse = UpsertTranslationScriptWithHttpInfo(upsertTranslationScriptRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script. Upserts a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TranslationScript</returns>
        public Lusid.Sdk.Client.ApiResponse<TranslationScript> UpsertTranslationScriptWithHttpInfo(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0)
        {
            // verify the required parameter 'upsertTranslationScriptRequest' is set
            if (upsertTranslationScriptRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'upsertTranslationScriptRequest' when calling ScriptedTranslationApi->UpsertTranslationScript");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = upsertTranslationScriptRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.UpsertTranslationScript";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<TranslationScript>("/api/scriptedtranslation/scripts", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertTranslationScript", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script. Upserts a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TranslationScript</returns>
        public async System.Threading.Tasks.Task<TranslationScript> UpsertTranslationScriptAsync(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Lusid.Sdk.Client.ApiResponse<TranslationScript> localVarResponse = await UpsertTranslationScriptWithHttpInfoAsync(upsertTranslationScriptRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertTranslationScript: Upsert a translation script. Upserts a translation script to be used for translating financial entities.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="upsertTranslationScriptRequest">The translation script to be upserted.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TranslationScript)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TranslationScript>> UpsertTranslationScriptWithHttpInfoAsync(UpsertTranslationScriptRequest upsertTranslationScriptRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'upsertTranslationScriptRequest' is set
            if (upsertTranslationScriptRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'upsertTranslationScriptRequest' when calling ScriptedTranslationApi->UpsertTranslationScript");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = upsertTranslationScriptRequest;

            localVarRequestOptions.Operation = "ScriptedTranslationApi.UpsertTranslationScript";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<TranslationScript>("/api/scriptedtranslation/scripts", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertTranslationScript", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}