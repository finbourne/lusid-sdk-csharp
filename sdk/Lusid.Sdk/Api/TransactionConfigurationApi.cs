/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using Object = System.Object;
using InvalidOperationException = System.InvalidOperationException;
using Exception = System.Exception;
using ArgumentNullException = System.ArgumentNullException;
using SystemEventHandler = System.EventHandler;
using DateTimeOffset = System.DateTimeOffset;
using Guid = System.Guid;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using IApiAccessor = Lusid.Sdk.Client.IApiAccessor;
using Lusid.Sdk.Extensions;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITransactionConfigurationApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition
        /// </summary>
        /// <remarks>
        /// Delete the side which user specify in the request.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteSideDefinition(string side, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition
        /// </summary>
        /// <remarks>
        /// Delete the side which user specify in the request.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteSideDefinitionWithHttpInfo(string side, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// DeleteTransactionType: Delete a transaction type
        /// </summary>
        /// <remarks>
        /// /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteTransactionType(string source, string type, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteTransactionType: Delete a transaction type
        /// </summary>
        /// <remarks>
        /// /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteTransactionTypeWithHttpInfo(string source, string type, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// Delete all the types for the given source and scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteTransactionTypeSource(string source, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// Delete all the types for the given source and scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteTransactionTypeSourceWithHttpInfo(string source, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label)
        /// </summary>
        /// <remarks>
        /// Get the side definition user requested.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>SideDefinition</returns>
        SideDefinition GetSideDefinition(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label)
        /// </summary>
        /// <remarks>
        /// Get the side definition user requested.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of SideDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<SideDefinition> GetSideDefinitionWithHttpInfo(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type
        /// </summary>
        /// <remarks>
        /// Get a single transaction type. Returns failure if not found
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>TransactionType</returns>
        TransactionType GetTransactionType(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type
        /// </summary>
        /// <remarks>
        /// Get a single transaction type. Returns failure if not found
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of TransactionType</returns>
        Lusid.Sdk.Client.ApiResponse<TransactionType> GetTransactionTypeWithHttpInfo(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// ListSideDefinitions: List the side definitions
        /// </summary>
        /// <remarks>
        /// List all the side definitions in the given scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfSideDefinition</returns>
        ResourceListOfSideDefinition ListSideDefinitions(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// ListSideDefinitions: List the side definitions
        /// </summary>
        /// <remarks>
        /// List all the side definitions in the given scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfSideDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> ListSideDefinitionsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// ListTransactionTypes: List transaction types
        /// </summary>
        /// <remarks>
        /// Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Dictionary&lt;string, List&lt;TransactionType&gt;&gt;</returns>
        Dictionary<string, List<TransactionType>> ListTransactionTypes(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// ListTransactionTypes: List transaction types
        /// </summary>
        /// <remarks>
        /// Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;TransactionType&gt;&gt;</returns>
        Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<TransactionType>>> ListTransactionTypesWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// SetSideDefinition: Set a side definition
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>SideDefinition</returns>
        SideDefinition SetSideDefinition(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// SetSideDefinition: Set a side definition
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of SideDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<SideDefinition> SetSideDefinitionWithHttpInfo(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// SetSideDefinitions: Set the given side definitions
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfSideDefinition</returns>
        ResourceListOfSideDefinition SetSideDefinitions(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// SetSideDefinitions: Set the given side definitions
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfSideDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> SetSideDefinitionsWithHttpInfo(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// SetTransactionType: Set a specific transaction type
        /// </summary>
        /// <remarks>
        /// Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>TransactionType</returns>
        TransactionType SetTransactionType(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// SetTransactionType: Set a specific transaction type
        /// </summary>
        /// <remarks>
        /// Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of TransactionType</returns>
        Lusid.Sdk.Client.ApiResponse<TransactionType> SetTransactionTypeWithHttpInfo(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// The complete set of transaction types for the source.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfTransactionType</returns>
        ResourceListOfTransactionType SetTransactionTypeSource(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// The complete set of transaction types for the source.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfTransactionType</returns>
        Lusid.Sdk.Client.ApiResponse<ResourceListOfTransactionType> SetTransactionTypeSourceWithHttpInfo(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITransactionConfigurationApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition
        /// </summary>
        /// <remarks>
        /// Delete the side which user specify in the request.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteSideDefinitionAsync(string side, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition
        /// </summary>
        /// <remarks>
        /// Delete the side which user specify in the request.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteSideDefinitionWithHttpInfoAsync(string side, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// DeleteTransactionType: Delete a transaction type
        /// </summary>
        /// <remarks>
        /// /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteTransactionTypeAsync(string source, string type, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteTransactionType: Delete a transaction type
        /// </summary>
        /// <remarks>
        /// /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteTransactionTypeWithHttpInfoAsync(string source, string type, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// Delete all the types for the given source and scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteTransactionTypeSourceAsync(string source, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// Delete all the types for the given source and scope.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteTransactionTypeSourceWithHttpInfoAsync(string source, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label)
        /// </summary>
        /// <remarks>
        /// Get the side definition user requested.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of SideDefinition</returns>
        System.Threading.Tasks.Task<SideDefinition> GetSideDefinitionAsync(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label)
        /// </summary>
        /// <remarks>
        /// Get the side definition user requested.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (SideDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<SideDefinition>> GetSideDefinitionWithHttpInfoAsync(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type
        /// </summary>
        /// <remarks>
        /// Get a single transaction type. Returns failure if not found
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of TransactionType</returns>
        System.Threading.Tasks.Task<TransactionType> GetTransactionTypeAsync(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type
        /// </summary>
        /// <remarks>
        /// Get a single transaction type. Returns failure if not found
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (TransactionType)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TransactionType>> GetTransactionTypeWithHttpInfoAsync(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// ListSideDefinitions: List the side definitions
        /// </summary>
        /// <remarks>
        /// List all the side definitions in the given scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfSideDefinition</returns>
        System.Threading.Tasks.Task<ResourceListOfSideDefinition> ListSideDefinitionsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// ListSideDefinitions: List the side definitions
        /// </summary>
        /// <remarks>
        /// List all the side definitions in the given scope
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfSideDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition>> ListSideDefinitionsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// ListTransactionTypes: List transaction types
        /// </summary>
        /// <remarks>
        /// Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;TransactionType&gt;&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, List<TransactionType>>> ListTransactionTypesAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// ListTransactionTypes: List transaction types
        /// </summary>
        /// <remarks>
        /// Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;TransactionType&gt;&gt;)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<TransactionType>>>> ListTransactionTypesWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// SetSideDefinition: Set a side definition
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of SideDefinition</returns>
        System.Threading.Tasks.Task<SideDefinition> SetSideDefinitionAsync(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// SetSideDefinition: Set a side definition
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (SideDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<SideDefinition>> SetSideDefinitionWithHttpInfoAsync(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// SetSideDefinitions: Set the given side definitions
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfSideDefinition</returns>
        System.Threading.Tasks.Task<ResourceListOfSideDefinition> SetSideDefinitionsAsync(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// SetSideDefinitions: Set the given side definitions
        /// </summary>
        /// <remarks>
        /// Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfSideDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition>> SetSideDefinitionsWithHttpInfoAsync(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// SetTransactionType: Set a specific transaction type
        /// </summary>
        /// <remarks>
        /// Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of TransactionType</returns>
        System.Threading.Tasks.Task<TransactionType> SetTransactionTypeAsync(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// SetTransactionType: Set a specific transaction type
        /// </summary>
        /// <remarks>
        /// Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (TransactionType)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TransactionType>> SetTransactionTypeWithHttpInfoAsync(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// The complete set of transaction types for the source.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfTransactionType</returns>
        System.Threading.Tasks.Task<ResourceListOfTransactionType> SetTransactionTypeSourceAsync(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope
        /// </summary>
        /// <remarks>
        /// The complete set of transaction types for the source.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfTransactionType)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfTransactionType>> SetTransactionTypeSourceWithHttpInfoAsync(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITransactionConfigurationApi : ITransactionConfigurationApiSync, ITransactionConfigurationApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class TransactionConfigurationApi : ITransactionConfigurationApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionConfigurationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TransactionConfigurationApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionConfigurationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TransactionConfigurationApi(string basePath)
        {
            var globalConfiguration = Lusid.Sdk.Client.GlobalConfiguration.Instance;
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                globalConfiguration,
                new Lusid.Sdk.Client.Configuration
                {
                    BasePath = basePath,
                    TimeoutMs = globalConfiguration.TimeoutMs,
                    RateLimitRetries = globalConfiguration.RateLimitRetries
                }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionConfigurationApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public TransactionConfigurationApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionConfigurationApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public TransactionConfigurationApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition Delete the side which user specify in the request.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteSideDefinition(string side, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteSideDefinitionWithHttpInfo(side, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition Delete the side which user specify in the request.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteSideDefinitionWithHttpInfo(string side, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'side' is set
            if (side == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'side' when calling TransactionConfigurationApi->DeleteSideDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("side", Lusid.Sdk.Client.ClientUtils.ParameterToString(side)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.DeleteSideDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/transactionconfiguration/sides/{side}/$delete", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSideDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition Delete the side which user specify in the request.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteSideDefinitionAsync(string side, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteSideDefinitionWithHttpInfoAsync(side, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteSideDefinition: Delete the given side definition Delete the side which user specify in the request.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteSideDefinitionWithHttpInfoAsync(string side, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'side' is set
            if (side == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'side' when calling TransactionConfigurationApi->DeleteSideDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("side", Lusid.Sdk.Client.ClientUtils.ParameterToString(side)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.DeleteSideDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/transactionconfiguration/sides/{side}/$delete", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteSideDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// DeleteTransactionType: Delete a transaction type /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteTransactionType(string source, string type, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteTransactionTypeWithHttpInfo(source, type, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteTransactionType: Delete a transaction type /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteTransactionTypeWithHttpInfo(string source, string type, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->DeleteTransactionType");
            }

            // verify the required parameter 'type' is set
            if (type == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'type' when calling TransactionConfigurationApi->DeleteTransactionType");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            localVarRequestOptions.PathParameters.Add("type", Lusid.Sdk.Client.ClientUtils.ParameterToString(type)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.DeleteTransactionType";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/transactionconfiguration/types/{source}/{type}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTransactionType", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// DeleteTransactionType: Delete a transaction type /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteTransactionTypeAsync(string source, string type, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteTransactionTypeWithHttpInfoAsync(source, type, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteTransactionType: Delete a transaction type /// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteTransactionTypeWithHttpInfoAsync(string source, string type, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->DeleteTransactionType");
            }

            // verify the required parameter 'type' is set
            if (type == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'type' when calling TransactionConfigurationApi->DeleteTransactionType");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            localVarRequestOptions.PathParameters.Add("type", Lusid.Sdk.Client.ClientUtils.ParameterToString(type)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.DeleteTransactionType";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/transactionconfiguration/types/{source}/{type}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTransactionType", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope Delete all the types for the given source and scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteTransactionTypeSource(string source, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteTransactionTypeSourceWithHttpInfo(source, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope Delete all the types for the given source and scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteTransactionTypeSourceWithHttpInfo(string source, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->DeleteTransactionTypeSource");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.DeleteTransactionTypeSource";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/transactionconfiguration/types/{source}/$delete", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTransactionTypeSource", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope Delete all the types for the given source and scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteTransactionTypeSourceAsync(string source, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteTransactionTypeSourceWithHttpInfoAsync(source, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteTransactionTypeSource: Delete all transaction types for the given source and scope Delete all the types for the given source and scope.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteTransactionTypeSourceWithHttpInfoAsync(string source, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->DeleteTransactionTypeSource");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.DeleteTransactionTypeSource";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/transactionconfiguration/types/{source}/$delete", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTransactionTypeSource", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label) Get the side definition user requested.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>SideDefinition</returns>
        public SideDefinition GetSideDefinition(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<SideDefinition> localVarResponse = GetSideDefinitionWithHttpInfo(side, scope, asAt, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label) Get the side definition user requested.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of SideDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<SideDefinition> GetSideDefinitionWithHttpInfo(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'side' is set
            if (side == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'side' when calling TransactionConfigurationApi->GetSideDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("side", Lusid.Sdk.Client.ClientUtils.ParameterToString(side)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.GetSideDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SideDefinition>("/api/transactionconfiguration/sides/{side}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSideDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label) Get the side definition user requested.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of SideDefinition</returns>
        public async System.Threading.Tasks.Task<SideDefinition> GetSideDefinitionAsync(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<SideDefinition> localVarResponse = await GetSideDefinitionWithHttpInfoAsync(side, scope, asAt, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetSideDefinition: Get the side definition for a given side name( or label) Get the side definition user requested.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (SideDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<SideDefinition>> GetSideDefinitionWithHttpInfoAsync(string side, string? scope = default(string?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'side' is set
            if (side == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'side' when calling TransactionConfigurationApi->GetSideDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("side", Lusid.Sdk.Client.ClientUtils.ParameterToString(side)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.GetSideDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SideDefinition>("/api/transactionconfiguration/sides/{side}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSideDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type Get a single transaction type. Returns failure if not found
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>TransactionType</returns>
        public TransactionType GetTransactionType(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<TransactionType> localVarResponse = GetTransactionTypeWithHttpInfo(source, type, asAt, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type Get a single transaction type. Returns failure if not found
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of TransactionType</returns>
        public Lusid.Sdk.Client.ApiResponse<TransactionType> GetTransactionTypeWithHttpInfo(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->GetTransactionType");
            }

            // verify the required parameter 'type' is set
            if (type == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'type' when calling TransactionConfigurationApi->GetTransactionType");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            localVarRequestOptions.PathParameters.Add("type", Lusid.Sdk.Client.ClientUtils.ParameterToString(type)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.GetTransactionType";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<TransactionType>("/api/transactionconfiguration/types/{source}/{type}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTransactionType", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type Get a single transaction type. Returns failure if not found
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of TransactionType</returns>
        public async System.Threading.Tasks.Task<TransactionType> GetTransactionTypeAsync(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<TransactionType> localVarResponse = await GetTransactionTypeWithHttpInfoAsync(source, type, asAt, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetTransactionType: Get a single transaction configuration type Get a single transaction type. Returns failure if not found
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source that the type is in</param>
        /// <param name="type">One of the type&#39;s aliases</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified (optional)</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (TransactionType)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TransactionType>> GetTransactionTypeWithHttpInfoAsync(string source, string type, DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->GetTransactionType");
            }

            // verify the required parameter 'type' is set
            if (type == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'type' when calling TransactionConfigurationApi->GetTransactionType");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            localVarRequestOptions.PathParameters.Add("type", Lusid.Sdk.Client.ClientUtils.ParameterToString(type)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.GetTransactionType";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<TransactionType>("/api/transactionconfiguration/types/{source}/{type}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTransactionType", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ListSideDefinitions: List the side definitions List all the side definitions in the given scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfSideDefinition</returns>
        public ResourceListOfSideDefinition ListSideDefinitions(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> localVarResponse = ListSideDefinitionsWithHttpInfo(asAt, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ListSideDefinitions: List the side definitions List all the side definitions in the given scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfSideDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> ListSideDefinitionsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.ListSideDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ResourceListOfSideDefinition>("/api/transactionconfiguration/sides", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSideDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ListSideDefinitions: List the side definitions List all the side definitions in the given scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfSideDefinition</returns>
        public async System.Threading.Tasks.Task<ResourceListOfSideDefinition> ListSideDefinitionsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> localVarResponse = await ListSideDefinitionsWithHttpInfoAsync(asAt, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ListSideDefinitions: List the side definitions List all the side definitions in the given scope
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfSideDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition>> ListSideDefinitionsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.ListSideDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ResourceListOfSideDefinition>("/api/transactionconfiguration/sides", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSideDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ListTransactionTypes: List transaction types Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Dictionary&lt;string, List&lt;TransactionType&gt;&gt;</returns>
        public Dictionary<string, List<TransactionType>> ListTransactionTypes(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<TransactionType>>> localVarResponse = ListTransactionTypesWithHttpInfo(asAt, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ListTransactionTypes: List transaction types Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;TransactionType&gt;&gt;</returns>
        public Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<TransactionType>>> ListTransactionTypesWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.ListTransactionTypes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, List<TransactionType>>>("/api/transactionconfiguration/types", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTransactionTypes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ListTransactionTypes: List transaction types Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;TransactionType&gt;&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, List<TransactionType>>> ListTransactionTypesAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<TransactionType>>> localVarResponse = await ListTransactionTypesWithHttpInfoAsync(asAt, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ListTransactionTypes: List transaction types Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified. (optional)</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;TransactionType&gt;&gt;)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<TransactionType>>>> ListTransactionTypesWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }

            localVarRequestOptions.Operation = "TransactionConfigurationApi.ListTransactionTypes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, List<TransactionType>>>("/api/transactionconfiguration/types", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTransactionTypes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetSideDefinition: Set a side definition Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>SideDefinition</returns>
        public SideDefinition SetSideDefinition(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<SideDefinition> localVarResponse = SetSideDefinitionWithHttpInfo(side, sideDefinitionRequest, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetSideDefinition: Set a side definition Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of SideDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<SideDefinition> SetSideDefinitionWithHttpInfo(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'side' is set
            if (side == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'side' when calling TransactionConfigurationApi->SetSideDefinition");
            }

            // verify the required parameter 'sideDefinitionRequest' is set
            if (sideDefinitionRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'sideDefinitionRequest' when calling TransactionConfigurationApi->SetSideDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("side", Lusid.Sdk.Client.ClientUtils.ParameterToString(side)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = sideDefinitionRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetSideDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<SideDefinition>("/api/transactionconfiguration/sides/{side}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetSideDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetSideDefinition: Set a side definition Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of SideDefinition</returns>
        public async System.Threading.Tasks.Task<SideDefinition> SetSideDefinitionAsync(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<SideDefinition> localVarResponse = await SetSideDefinitionWithHttpInfoAsync(side, sideDefinitionRequest, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetSideDefinition: Set a side definition Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="side">The label to uniquely identify the side.</param>
        /// <param name="sideDefinitionRequest">The side definition to create or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (SideDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<SideDefinition>> SetSideDefinitionWithHttpInfoAsync(string side, SideDefinitionRequest sideDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'side' is set
            if (side == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'side' when calling TransactionConfigurationApi->SetSideDefinition");
            }

            // verify the required parameter 'sideDefinitionRequest' is set
            if (sideDefinitionRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'sideDefinitionRequest' when calling TransactionConfigurationApi->SetSideDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("side", Lusid.Sdk.Client.ClientUtils.ParameterToString(side)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = sideDefinitionRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetSideDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<SideDefinition>("/api/transactionconfiguration/sides/{side}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetSideDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetSideDefinitions: Set the given side definitions Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfSideDefinition</returns>
        public ResourceListOfSideDefinition SetSideDefinitions(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> localVarResponse = SetSideDefinitionsWithHttpInfo(sidesDefinitionRequest, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetSideDefinitions: Set the given side definitions Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfSideDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> SetSideDefinitionsWithHttpInfo(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'sidesDefinitionRequest' is set
            if (sidesDefinitionRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'sidesDefinitionRequest' when calling TransactionConfigurationApi->SetSideDefinitions");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = sidesDefinitionRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetSideDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ResourceListOfSideDefinition>("/api/transactionconfiguration/sides", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetSideDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetSideDefinitions: Set the given side definitions Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfSideDefinition</returns>
        public async System.Threading.Tasks.Task<ResourceListOfSideDefinition> SetSideDefinitionsAsync(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition> localVarResponse = await SetSideDefinitionsWithHttpInfoAsync(sidesDefinitionRequest, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetSideDefinitions: Set the given side definitions Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sidesDefinitionRequest">The list of side definitions to create, or replace.</param>
        /// <param name="scope">The scope in which the side exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfSideDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfSideDefinition>> SetSideDefinitionsWithHttpInfoAsync(List<SidesDefinitionRequest> sidesDefinitionRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'sidesDefinitionRequest' is set
            if (sidesDefinitionRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'sidesDefinitionRequest' when calling TransactionConfigurationApi->SetSideDefinitions");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = sidesDefinitionRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetSideDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ResourceListOfSideDefinition>("/api/transactionconfiguration/sides", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetSideDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetTransactionType: Set a specific transaction type Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>TransactionType</returns>
        public TransactionType SetTransactionType(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<TransactionType> localVarResponse = SetTransactionTypeWithHttpInfo(source, type, transactionTypeRequest, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetTransactionType: Set a specific transaction type Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of TransactionType</returns>
        public Lusid.Sdk.Client.ApiResponse<TransactionType> SetTransactionTypeWithHttpInfo(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->SetTransactionType");
            }

            // verify the required parameter 'type' is set
            if (type == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'type' when calling TransactionConfigurationApi->SetTransactionType");
            }

            // verify the required parameter 'transactionTypeRequest' is set
            if (transactionTypeRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'transactionTypeRequest' when calling TransactionConfigurationApi->SetTransactionType");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            localVarRequestOptions.PathParameters.Add("type", Lusid.Sdk.Client.ClientUtils.ParameterToString(type)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = transactionTypeRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetTransactionType";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<TransactionType>("/api/transactionconfiguration/types/{source}/{type}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetTransactionType", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetTransactionType: Set a specific transaction type Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of TransactionType</returns>
        public async System.Threading.Tasks.Task<TransactionType> SetTransactionTypeAsync(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<TransactionType> localVarResponse = await SetTransactionTypeWithHttpInfoAsync(source, type, transactionTypeRequest, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetTransactionType: Set a specific transaction type Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction configuration for</param>
        /// <param name="type">One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type</param>
        /// <param name="transactionTypeRequest">The transaction configuration to set</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (TransactionType)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<TransactionType>> SetTransactionTypeWithHttpInfoAsync(string source, string type, TransactionTypeRequest transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->SetTransactionType");
            }

            // verify the required parameter 'type' is set
            if (type == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'type' when calling TransactionConfigurationApi->SetTransactionType");
            }

            // verify the required parameter 'transactionTypeRequest' is set
            if (transactionTypeRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'transactionTypeRequest' when calling TransactionConfigurationApi->SetTransactionType");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            localVarRequestOptions.PathParameters.Add("type", Lusid.Sdk.Client.ClientUtils.ParameterToString(type)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = transactionTypeRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetTransactionType";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<TransactionType>("/api/transactionconfiguration/types/{source}/{type}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetTransactionType", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope The complete set of transaction types for the source.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfTransactionType</returns>
        public ResourceListOfTransactionType SetTransactionTypeSource(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfTransactionType> localVarResponse = SetTransactionTypeSourceWithHttpInfo(source, transactionTypeRequest, scope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope The complete set of transaction types for the source.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfTransactionType</returns>
        public Lusid.Sdk.Client.ApiResponse<ResourceListOfTransactionType> SetTransactionTypeSourceWithHttpInfo(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->SetTransactionTypeSource");
            }

            // verify the required parameter 'transactionTypeRequest' is set
            if (transactionTypeRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'transactionTypeRequest' when calling TransactionConfigurationApi->SetTransactionTypeSource");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = transactionTypeRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetTransactionTypeSource";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ResourceListOfTransactionType>("/api/transactionconfiguration/types/{source}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetTransactionTypeSource", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope The complete set of transaction types for the source.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfTransactionType</returns>
        public async System.Threading.Tasks.Task<ResourceListOfTransactionType> SetTransactionTypeSourceAsync(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfTransactionType> localVarResponse = await SetTransactionTypeSourceWithHttpInfoAsync(source, transactionTypeRequest, scope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// SetTransactionTypeSource: Set the transaction types for the given source and scope The complete set of transaction types for the source.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="source">The source to set the transaction types for.</param>
        /// <param name="transactionTypeRequest">The set of transaction types.</param>
        /// <param name="scope">The scope in which the transaction types exists. When not supplied the scope is &#39;default&#39;. (optional, default to &quot;default&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfTransactionType)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfTransactionType>> SetTransactionTypeSourceWithHttpInfoAsync(string source, List<TransactionTypeRequest> transactionTypeRequest, string? scope = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'source' is set
            if (source == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'source' when calling TransactionConfigurationApi->SetTransactionTypeSource");
            }

            // verify the required parameter 'transactionTypeRequest' is set
            if (transactionTypeRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'transactionTypeRequest' when calling TransactionConfigurationApi->SetTransactionTypeSource");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("source", Lusid.Sdk.Client.ClientUtils.ParameterToString(source)); // path parameter
            if (scope != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "scope", scope));
            }
            localVarRequestOptions.Data = transactionTypeRequest;

            localVarRequestOptions.Operation = "TransactionConfigurationApi.SetTransactionTypeSource";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ResourceListOfTransactionType>("/api/transactionconfiguration/types/{source}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetTransactionTypeSource", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}