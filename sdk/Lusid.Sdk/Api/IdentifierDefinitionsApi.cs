/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using Object = System.Object;
using InvalidOperationException = System.InvalidOperationException;
using Exception = System.Exception;
using ArgumentNullException = System.ArgumentNullException;
using SystemEventHandler = System.EventHandler;
using DateTimeOffset = System.DateTimeOffset;
using Guid = System.Guid;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using IApiAccessor = Lusid.Sdk.Client.IApiAccessor;
using Lusid.Sdk.Extensions;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IIdentifierDefinitionsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition
        /// </summary>
        /// <remarks>
        /// Define a new Identifier Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>IdentifierDefinition</returns>
        IdentifierDefinition CreateIdentifierDefinition(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition
        /// </summary>
        /// <remarks>
        /// Define a new Identifier Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of IdentifierDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> CreateIdentifierDefinitionWithHttpInfo(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteIdentifierDefinition(string domain, string identifierScope, string identifierType, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteIdentifierDefinitionWithHttpInfo(string domain, string identifierScope, string identifierType, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition
        /// </summary>
        /// <remarks>
        /// Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>IdentifierDefinition</returns>
        IdentifierDefinition GetIdentifierDefinition(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition
        /// </summary>
        /// <remarks>
        /// Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of IdentifierDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> GetIdentifierDefinitionWithHttpInfo(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions
        /// </summary>
        /// <remarks>
        /// Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfIdentifierDefinition</returns>
        PagedResourceListOfIdentifierDefinition ListIdentifierDefinitions(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions
        /// </summary>
        /// <remarks>
        /// Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfIdentifierDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<PagedResourceListOfIdentifierDefinition> ListIdentifierDefinitionsWithHttpInfo(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Identifier Definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>IdentifierDefinition</returns>
        IdentifierDefinition UpdateIdentifierDefinition(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Identifier Definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of IdentifierDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> UpdateIdentifierDefinitionWithHttpInfo(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IIdentifierDefinitionsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition
        /// </summary>
        /// <remarks>
        /// Define a new Identifier Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of IdentifierDefinition</returns>
        System.Threading.Tasks.Task<IdentifierDefinition> CreateIdentifierDefinitionAsync(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition
        /// </summary>
        /// <remarks>
        /// Define a new Identifier Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (IdentifierDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<IdentifierDefinition>> CreateIdentifierDefinitionWithHttpInfoAsync(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteIdentifierDefinitionAsync(string domain, string identifierScope, string identifierType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteIdentifierDefinitionWithHttpInfoAsync(string domain, string identifierScope, string identifierType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition
        /// </summary>
        /// <remarks>
        /// Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of IdentifierDefinition</returns>
        System.Threading.Tasks.Task<IdentifierDefinition> GetIdentifierDefinitionAsync(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition
        /// </summary>
        /// <remarks>
        /// Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (IdentifierDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<IdentifierDefinition>> GetIdentifierDefinitionWithHttpInfoAsync(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions
        /// </summary>
        /// <remarks>
        /// Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfIdentifierDefinition</returns>
        System.Threading.Tasks.Task<PagedResourceListOfIdentifierDefinition> ListIdentifierDefinitionsAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions
        /// </summary>
        /// <remarks>
        /// Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfIdentifierDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfIdentifierDefinition>> ListIdentifierDefinitionsWithHttpInfoAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Identifier Definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of IdentifierDefinition</returns>
        System.Threading.Tasks.Task<IdentifierDefinition> UpdateIdentifierDefinitionAsync(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Identifier Definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (IdentifierDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<IdentifierDefinition>> UpdateIdentifierDefinitionWithHttpInfoAsync(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IIdentifierDefinitionsApi : IIdentifierDefinitionsApiSync, IIdentifierDefinitionsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class IdentifierDefinitionsApi : IIdentifierDefinitionsApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="IdentifierDefinitionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public IdentifierDefinitionsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IdentifierDefinitionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public IdentifierDefinitionsApi(string basePath)
        {
            var globalConfiguration = Lusid.Sdk.Client.GlobalConfiguration.Instance;
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                globalConfiguration,
                new Lusid.Sdk.Client.Configuration
                {
                    BasePath = basePath,
                    TimeoutMs = globalConfiguration.TimeoutMs,
                    RateLimitRetries = globalConfiguration.RateLimitRetries
                }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IdentifierDefinitionsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public IdentifierDefinitionsApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IdentifierDefinitionsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public IdentifierDefinitionsApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition Define a new Identifier Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>IdentifierDefinition</returns>
        public IdentifierDefinition CreateIdentifierDefinition(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> localVarResponse = CreateIdentifierDefinitionWithHttpInfo(createIdentifierDefinitionRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition Define a new Identifier Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of IdentifierDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> CreateIdentifierDefinitionWithHttpInfo(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createIdentifierDefinitionRequest;

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.CreateIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<IdentifierDefinition>("/api/identifierdefinitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition Define a new Identifier Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of IdentifierDefinition</returns>
        public async System.Threading.Tasks.Task<IdentifierDefinition> CreateIdentifierDefinitionAsync(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> localVarResponse = await CreateIdentifierDefinitionWithHttpInfoAsync(createIdentifierDefinitionRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateIdentifierDefinition: Create an Identifier Definition Define a new Identifier Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createIdentifierDefinitionRequest">The request defining the new definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (IdentifierDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<IdentifierDefinition>> CreateIdentifierDefinitionWithHttpInfoAsync(CreateIdentifierDefinitionRequest? createIdentifierDefinitionRequest = default(CreateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createIdentifierDefinitionRequest;

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.CreateIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IdentifierDefinition>("/api/identifierdefinitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteIdentifierDefinition(string domain, string identifierScope, string identifierType, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteIdentifierDefinitionWithHttpInfo(domain, identifierScope, identifierType, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteIdentifierDefinitionWithHttpInfo(string domain, string identifierScope, string identifierType, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'domain' is set
            if (domain == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'domain' when calling IdentifierDefinitionsApi->DeleteIdentifierDefinition");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling IdentifierDefinitionsApi->DeleteIdentifierDefinition");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling IdentifierDefinitionsApi->DeleteIdentifierDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("domain", Lusid.Sdk.Client.ClientUtils.ParameterToString(domain)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierScope", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierScope)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.DeleteIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/identifierdefinitions/{domain}/{identifierScope}/{identifierType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteIdentifierDefinitionAsync(string domain, string identifierScope, string identifierType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteIdentifierDefinitionWithHttpInfoAsync(domain, identifierScope, identifierType, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteIdentifierDefinition: Delete a particular Identifier Definition The deletion will take effect from the Identifier Definition deletion datetime. i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteIdentifierDefinitionWithHttpInfoAsync(string domain, string identifierScope, string identifierType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'domain' is set
            if (domain == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'domain' when calling IdentifierDefinitionsApi->DeleteIdentifierDefinition");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling IdentifierDefinitionsApi->DeleteIdentifierDefinition");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling IdentifierDefinitionsApi->DeleteIdentifierDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("domain", Lusid.Sdk.Client.ClientUtils.ParameterToString(domain)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierScope", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierScope)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.DeleteIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/identifierdefinitions/{domain}/{identifierScope}/{identifierType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>IdentifierDefinition</returns>
        public IdentifierDefinition GetIdentifierDefinition(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> localVarResponse = GetIdentifierDefinitionWithHttpInfo(domain, identifierScope, identifierType, asAt, effectiveAt, propertyKeys, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of IdentifierDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> GetIdentifierDefinitionWithHttpInfo(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'domain' is set
            if (domain == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'domain' when calling IdentifierDefinitionsApi->GetIdentifierDefinition");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling IdentifierDefinitionsApi->GetIdentifierDefinition");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling IdentifierDefinitionsApi->GetIdentifierDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("domain", Lusid.Sdk.Client.ClientUtils.ParameterToString(domain)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierScope", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierScope)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.GetIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IdentifierDefinition>("/api/identifierdefinitions/{domain}/{identifierScope}/{identifierType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of IdentifierDefinition</returns>
        public async System.Threading.Tasks.Task<IdentifierDefinition> GetIdentifierDefinitionAsync(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> localVarResponse = await GetIdentifierDefinitionWithHttpInfoAsync(domain, identifierScope, identifierType, asAt, effectiveAt, propertyKeys, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetIdentifierDefinition: Get a single Identifier Definition Get a single Identifier Definition using domain, identifierScope, identifierType, and an optional asAt             - defaulting to latest if not specified
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates.</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the identifier definition</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definition. Defaults to return             the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. If no properties are specified, then no properties will be returned. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (IdentifierDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<IdentifierDefinition>> GetIdentifierDefinitionWithHttpInfoAsync(string domain, string identifierScope, string identifierType, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'domain' is set
            if (domain == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'domain' when calling IdentifierDefinitionsApi->GetIdentifierDefinition");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling IdentifierDefinitionsApi->GetIdentifierDefinition");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling IdentifierDefinitionsApi->GetIdentifierDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("domain", Lusid.Sdk.Client.ClientUtils.ParameterToString(domain)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierScope", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierScope)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.GetIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<IdentifierDefinition>("/api/identifierdefinitions/{domain}/{identifierScope}/{identifierType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfIdentifierDefinition</returns>
        public PagedResourceListOfIdentifierDefinition ListIdentifierDefinitions(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfIdentifierDefinition> localVarResponse = ListIdentifierDefinitionsWithHttpInfo(effectiveAt, asAt, page, limit, filter, sortBy, propertyKeys, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfIdentifierDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfIdentifierDefinition> ListIdentifierDefinitionsWithHttpInfo(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.ListIdentifierDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfIdentifierDefinition>("/api/identifierdefinitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListIdentifierDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfIdentifierDefinition</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfIdentifierDefinition> ListIdentifierDefinitionsAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfIdentifierDefinition> localVarResponse = await ListIdentifierDefinitionsWithHttpInfoAsync(effectiveAt, asAt, page, limit, filter, sortBy, propertyKeys, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListIdentifierDefinitions: List Identifier Definitions Retrieves all Identifier Definitions that fit the filter, in a specific order if sortBy is provided Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Identifier Definitions.             Since Identifier Definitions exist for all effective time, this will only apply to properties (if requested)             on the Identifier Definition. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Identifier Definitions. Defaults to return the latest             version of the Identifier Definitions if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Identifier Definitions from a previous call to list             Identifier Definitions. This value is returned from the previous call. If a pagination token is provided the sortBy,             filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:             https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;IdentifierDefinition&#39; domain to decorate onto the Identifier Definition.             These must take the format {domain}/{scope}/{code}. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfIdentifierDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfIdentifierDefinition>> ListIdentifierDefinitionsWithHttpInfoAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.ListIdentifierDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfIdentifierDefinition>("/api/identifierdefinitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListIdentifierDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType Overwrites an existing Identifier Definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>IdentifierDefinition</returns>
        public IdentifierDefinition UpdateIdentifierDefinition(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> localVarResponse = UpdateIdentifierDefinitionWithHttpInfo(domain, identifierScope, identifierType, updateIdentifierDefinitionRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType Overwrites an existing Identifier Definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of IdentifierDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> UpdateIdentifierDefinitionWithHttpInfo(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'domain' is set
            if (domain == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'domain' when calling IdentifierDefinitionsApi->UpdateIdentifierDefinition");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling IdentifierDefinitionsApi->UpdateIdentifierDefinition");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling IdentifierDefinitionsApi->UpdateIdentifierDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("domain", Lusid.Sdk.Client.ClientUtils.ParameterToString(domain)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierScope", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierScope)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.Data = updateIdentifierDefinitionRequest;

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.UpdateIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<IdentifierDefinition>("/api/identifierdefinitions/{domain}/{identifierScope}/{identifierType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType Overwrites an existing Identifier Definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of IdentifierDefinition</returns>
        public async System.Threading.Tasks.Task<IdentifierDefinition> UpdateIdentifierDefinitionAsync(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<IdentifierDefinition> localVarResponse = await UpdateIdentifierDefinitionWithHttpInfoAsync(domain, identifierScope, identifierType, updateIdentifierDefinitionRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateIdentifierDefinition: Update Identifier Definition defined by domain, identifierScope, and identifierType Overwrites an existing Identifier Definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="domain">The type of entity to which the identifier relates</param>
        /// <param name="identifierScope">The scope that the identifier exists in</param>
        /// <param name="identifierType">What the identifier represents. Together with \&quot;domain\&quot; and \&quot;identifierScope\&quot; this uniquely identifies the Identifier Definition</param>
        /// <param name="updateIdentifierDefinitionRequest">The request containing the updated details of the Identifier Definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (IdentifierDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<IdentifierDefinition>> UpdateIdentifierDefinitionWithHttpInfoAsync(string domain, string identifierScope, string identifierType, UpdateIdentifierDefinitionRequest? updateIdentifierDefinitionRequest = default(UpdateIdentifierDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'domain' is set
            if (domain == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'domain' when calling IdentifierDefinitionsApi->UpdateIdentifierDefinition");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling IdentifierDefinitionsApi->UpdateIdentifierDefinition");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling IdentifierDefinitionsApi->UpdateIdentifierDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("domain", Lusid.Sdk.Client.ClientUtils.ParameterToString(domain)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierScope", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierScope)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.Data = updateIdentifierDefinitionRequest;

            localVarRequestOptions.Operation = "IdentifierDefinitionsApi.UpdateIdentifierDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<IdentifierDefinition>("/api/identifierdefinitions/{domain}/{identifierScope}/{identifierType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateIdentifierDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}