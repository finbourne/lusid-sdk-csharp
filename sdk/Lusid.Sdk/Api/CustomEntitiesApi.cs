/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using Object = System.Object;
using InvalidOperationException = System.InvalidOperationException;
using Exception = System.Exception;
using ArgumentNullException = System.ArgumentNullException;
using SystemEventHandler = System.EventHandler;
using DateTimeOffset = System.DateTimeOffset;
using Guid = System.Guid;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using IApiAccessor = Lusid.Sdk.Client.IApiAccessor;
using Lusid.Sdk.Extensions;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICustomEntitiesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Delete a Custom Entity instance by a specific entity type.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteCustomEntity(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Delete a Custom Entity instance by a specific entity type.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteCustomEntityWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        Dictionary<string, List<AccessMetadataValue>> GetAllCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> GetAllCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CustomEntityResponse</returns>
        CustomEntityResponse GetCustomEntity(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CustomEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> GetCustomEntityWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get Custom Entity access metadata for the specified metadata key
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>List&lt;AccessMetadataValue&gt;</returns>
        List<AccessMetadataValue> GetCustomEntityAccessMetadataByKey(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get Custom Entity access metadata for the specified metadata key
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of List&lt;AccessMetadataValue&gt;</returns>
        Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> GetCustomEntityAccessMetadataByKeyWithHttpInfo(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified Custom Entity.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfRelationship</returns>
        ResourceListOfRelationship GetCustomEntityRelationships(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified Custom Entity.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfRelationship</returns>
        Lusid.Sdk.Client.ApiResponse<ResourceListOfRelationship> GetCustomEntityRelationshipsWithHttpInfo(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType.
        /// </summary>
        /// <remarks>
        /// List all the Custom Entities matching particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfCustomEntityResponse</returns>
        PagedResourceListOfCustomEntityResponse ListCustomEntities(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType.
        /// </summary>
        /// <remarks>
        /// List all the Custom Entities matching particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfCustomEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCustomEntityResponse> ListCustomEntitiesWithHttpInfo(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity.
        /// </summary>
        /// <remarks>
        /// Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        Dictionary<string, List<AccessMetadataValue>> PatchCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity.
        /// </summary>
        /// <remarks>
        /// Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> PatchCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities
        /// </summary>
        /// <remarks>
        /// Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>UpsertCustomEntitiesResponse</returns>
        UpsertCustomEntitiesResponse UpsertCustomEntities(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities
        /// </summary>
        /// <remarks>
        /// Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of UpsertCustomEntitiesResponse</returns>
        Lusid.Sdk.Client.ApiResponse<UpsertCustomEntitiesResponse> UpsertCustomEntitiesWithHttpInfo(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance
        /// </summary>
        /// <remarks>
        /// Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CustomEntityResponse</returns>
        CustomEntityResponse UpsertCustomEntity(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance
        /// </summary>
        /// <remarks>
        /// Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CustomEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> UpsertCustomEntityWithHttpInfo(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>List&lt;AccessMetadataValue&gt;</returns>
        List<AccessMetadataValue> UpsertCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of List&lt;AccessMetadataValue&gt;</returns>
        Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> UpsertCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICustomEntitiesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Delete a Custom Entity instance by a specific entity type.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteCustomEntityAsync(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Delete a Custom Entity instance by a specific entity type.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteCustomEntityWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry
        /// </summary>
        /// <remarks>
        /// Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> GetAllCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> GetAllCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CustomEntityResponse</returns>
        System.Threading.Tasks.Task<CustomEntityResponse> GetCustomEntityAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance.
        /// </summary>
        /// <remarks>
        /// Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CustomEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CustomEntityResponse>> GetCustomEntityWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get Custom Entity access metadata for the specified metadata key
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of List&lt;AccessMetadataValue&gt;</returns>
        System.Threading.Tasks.Task<List<AccessMetadataValue>> GetCustomEntityAccessMetadataByKeyAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity
        /// </summary>
        /// <remarks>
        /// Get Custom Entity access metadata for the specified metadata key
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (List&lt;AccessMetadataValue&gt;)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>>> GetCustomEntityAccessMetadataByKeyWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified Custom Entity.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfRelationship</returns>
        System.Threading.Tasks.Task<ResourceListOfRelationship> GetCustomEntityRelationshipsAsync(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity
        /// </summary>
        /// <remarks>
        /// Get relationships for the specified Custom Entity.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfRelationship)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfRelationship>> GetCustomEntityRelationshipsWithHttpInfoAsync(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType.
        /// </summary>
        /// <remarks>
        /// List all the Custom Entities matching particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfCustomEntityResponse</returns>
        System.Threading.Tasks.Task<PagedResourceListOfCustomEntityResponse> ListCustomEntitiesAsync(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType.
        /// </summary>
        /// <remarks>
        /// List all the Custom Entities matching particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfCustomEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCustomEntityResponse>> ListCustomEntitiesWithHttpInfoAsync(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity.
        /// </summary>
        /// <remarks>
        /// Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> PatchCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity.
        /// </summary>
        /// <remarks>
        /// Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> PatchCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities
        /// </summary>
        /// <remarks>
        /// Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of UpsertCustomEntitiesResponse</returns>
        System.Threading.Tasks.Task<UpsertCustomEntitiesResponse> UpsertCustomEntitiesAsync(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities
        /// </summary>
        /// <remarks>
        /// Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (UpsertCustomEntitiesResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<UpsertCustomEntitiesResponse>> UpsertCustomEntitiesWithHttpInfoAsync(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance
        /// </summary>
        /// <remarks>
        /// Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CustomEntityResponse</returns>
        System.Threading.Tasks.Task<CustomEntityResponse> UpsertCustomEntityAsync(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance
        /// </summary>
        /// <remarks>
        /// Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CustomEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CustomEntityResponse>> UpsertCustomEntityWithHttpInfoAsync(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of List&lt;AccessMetadataValue&gt;</returns>
        System.Threading.Tasks.Task<List<AccessMetadataValue>> UpsertCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
        /// </summary>
        /// <remarks>
        /// Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (List&lt;AccessMetadataValue&gt;)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>>> UpsertCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICustomEntitiesApi : ICustomEntitiesApiSync, ICustomEntitiesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CustomEntitiesApi : ICustomEntitiesApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomEntitiesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CustomEntitiesApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomEntitiesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CustomEntitiesApi(string basePath)
        {
            var globalConfiguration = Lusid.Sdk.Client.GlobalConfiguration.Instance;
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                globalConfiguration,
                new Lusid.Sdk.Client.Configuration
                {
                    BasePath = basePath,
                    TimeoutMs = globalConfiguration.TimeoutMs,
                    RateLimitRetries = globalConfiguration.RateLimitRetries
                }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomEntitiesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CustomEntitiesApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomEntitiesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public CustomEntitiesApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance. Delete a Custom Entity instance by a specific entity type.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteCustomEntity(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteCustomEntityWithHttpInfo(entityType, identifierType, identifierValue, identifierScope, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance. Delete a Custom Entity instance by a specific entity type.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteCustomEntityWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));

            localVarRequestOptions.Operation = "CustomEntitiesApi.DeleteCustomEntity";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/customentities/{entityType}/{identifierType}/{identifierValue}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCustomEntity", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance. Delete a Custom Entity instance by a specific entity type.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteCustomEntityAsync(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteCustomEntityWithHttpInfoAsync(entityType, identifierType, identifierValue, identifierScope, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// DeleteCustomEntity: Delete a Custom Entity instance. Delete a Custom Entity instance by a specific entity type.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to remove.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteCustomEntityWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->DeleteCustomEntity");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->DeleteCustomEntity");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));

            localVarRequestOptions.Operation = "CustomEntitiesApi.DeleteCustomEntity";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/customentities/{entityType}/{identifierType}/{identifierValue}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCustomEntity", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteCustomEntityAccessMetadataWithHttpInfo(entityType, identifierType, identifierValue, metadataKey, identifierScope, effectiveAt, effectiveUntil, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'metadataKey' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.PathParameters.Add("metadataKey", Lusid.Sdk.Client.ClientUtils.ParameterToString(metadataKey)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (effectiveUntil != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveUntil", effectiveUntil));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.DeleteCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata/{metadataKey}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteCustomEntityAccessMetadataWithHttpInfoAsync(entityType, identifierType, identifierValue, metadataKey, identifierScope, effectiveAt, effectiveUntil, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.  It is important to always check to verify success (or failure).
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to delete.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which to retrieve the Access Metadata. (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'metadataKey' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->DeleteCustomEntityAccessMetadata");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.PathParameters.Add("metadataKey", Lusid.Sdk.Client.ClientUtils.ParameterToString(metadataKey)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (effectiveUntil != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveUntil", effectiveUntil));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.DeleteCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata/{metadataKey}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public Dictionary<string, List<AccessMetadataValue>> GetAllCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = GetAllCustomEntityAccessMetadataWithHttpInfo(entityType, identifierType, identifierValue, identifierScope, effectiveAt, asAt, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> GetAllCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetAllCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, List<AccessMetadataValue>>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> GetAllCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = await GetAllCustomEntityAccessMetadataWithHttpInfoAsync(entityType, identifierType, identifierValue, identifierScope, effectiveAt, asAt, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity Get all the Custom Entity access metadata for the specified identifier scope, code and value
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> GetAllCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetAllCustomEntityAccessMetadata");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetAllCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, List<AccessMetadataValue>>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAllCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance. Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CustomEntityResponse</returns>
        public CustomEntityResponse GetCustomEntity(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> localVarResponse = GetCustomEntityWithHttpInfo(entityType, identifierType, identifierValue, identifierScope, asAt, effectiveAt, relatedEntityPropertyKeys, relationshipDefinitionIds, propertyKeys, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance. Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CustomEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> GetCustomEntityWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetCustomEntity");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetCustomEntity");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetCustomEntity");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetCustomEntity");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (relatedEntityPropertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relatedEntityPropertyKeys", relatedEntityPropertyKeys));
            }
            if (relationshipDefinitionIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relationshipDefinitionIds", relationshipDefinitionIds));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetCustomEntity";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CustomEntityResponse>("/api/customentities/{entityType}/{identifierType}/{identifierValue}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCustomEntity", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance. Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CustomEntityResponse</returns>
        public async System.Threading.Tasks.Task<CustomEntityResponse> GetCustomEntityAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> localVarResponse = await GetCustomEntityWithHttpInfoAsync(entityType, identifierType, identifierValue, identifierScope, asAt, effectiveAt, relatedEntityPropertyKeys, relationshipDefinitionIds, propertyKeys, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// GetCustomEntity: Get a Custom Entity instance. Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to retrieve. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="asAt">The AsAt datetime at which to retrieve the Custom Entity instance. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CustomEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CustomEntityResponse>> GetCustomEntityWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetCustomEntity");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetCustomEntity");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetCustomEntity");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetCustomEntity");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (relatedEntityPropertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relatedEntityPropertyKeys", relatedEntityPropertyKeys));
            }
            if (relationshipDefinitionIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relationshipDefinitionIds", relationshipDefinitionIds));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetCustomEntity";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CustomEntityResponse>("/api/customentities/{entityType}/{identifierType}/{identifierValue}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCustomEntity", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity Get Custom Entity access metadata for the specified metadata key
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>List&lt;AccessMetadataValue&gt;</returns>
        public List<AccessMetadataValue> GetCustomEntityAccessMetadataByKey(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> localVarResponse = GetCustomEntityAccessMetadataByKeyWithHttpInfo(entityType, identifierType, identifierValue, metadataKey, identifierScope, effectiveAt, asAt, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity Get Custom Entity access metadata for the specified metadata key
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of List&lt;AccessMetadataValue&gt;</returns>
        public Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> GetCustomEntityAccessMetadataByKeyWithHttpInfo(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'metadataKey' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.PathParameters.Add("metadataKey", Lusid.Sdk.Client.ClientUtils.ParameterToString(metadataKey)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetCustomEntityAccessMetadataByKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<AccessMetadataValue>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata/{metadataKey}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCustomEntityAccessMetadataByKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity Get Custom Entity access metadata for the specified metadata key
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of List&lt;AccessMetadataValue&gt;</returns>
        public async System.Threading.Tasks.Task<List<AccessMetadataValue>> GetCustomEntityAccessMetadataByKeyAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> localVarResponse = await GetCustomEntityAccessMetadataByKeyWithHttpInfoAsync(entityType, identifierType, identifierValue, metadataKey, identifierScope, effectiveAt, asAt, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity Get Custom Entity access metadata for the specified metadata key
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (List&lt;AccessMetadataValue&gt;)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>>> GetCustomEntityAccessMetadataByKeyWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'metadataKey' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetCustomEntityAccessMetadataByKey");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.PathParameters.Add("metadataKey", Lusid.Sdk.Client.ClientUtils.ParameterToString(metadataKey)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetCustomEntityAccessMetadataByKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<AccessMetadataValue>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata/{metadataKey}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCustomEntityAccessMetadataByKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity Get relationships for the specified Custom Entity.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ResourceListOfRelationship</returns>
        public ResourceListOfRelationship GetCustomEntityRelationships(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfRelationship> localVarResponse = GetCustomEntityRelationshipsWithHttpInfo(entityType, identifierScope, identifierType, identifierValue, effectiveAt, asAt, filter, identifierTypes, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity Get relationships for the specified Custom Entity.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of ResourceListOfRelationship</returns>
        public Lusid.Sdk.Client.ApiResponse<ResourceListOfRelationship> GetCustomEntityRelationshipsWithHttpInfo(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (identifierTypes != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "identifierTypes", identifierTypes));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetCustomEntityRelationships";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ResourceListOfRelationship>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/relationships", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCustomEntityRelationships", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity Get relationships for the specified Custom Entity.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ResourceListOfRelationship</returns>
        public async System.Threading.Tasks.Task<ResourceListOfRelationship> GetCustomEntityRelationshipsAsync(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<ResourceListOfRelationship> localVarResponse = await GetCustomEntityRelationshipsWithHttpInfoAsync(entityType, identifierScope, identifierType, identifierValue, effectiveAt, asAt, filter, identifierTypes, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity Get relationships for the specified Custom Entity.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of entity get relationships for.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified. (optional)</param>
        /// <param name="filter">Expression to filter relationships. Users should provide null or empty string for this field until further notice. (optional)</param>
        /// <param name="identifierTypes">Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format             {domain}/{scope}/{code} e.g. \&quot;Person/CompanyDetails/Role\&quot;. They must be from the \&quot;Person\&quot; or \&quot;LegalEntity\&quot; domain.             Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (ResourceListOfRelationship)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<ResourceListOfRelationship>> GetCustomEntityRelationshipsWithHttpInfoAsync(string entityType, string identifierScope, string identifierType, string identifierValue, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? filter = default(string?), List<string>? identifierTypes = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->GetCustomEntityRelationships");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (identifierTypes != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "identifierTypes", identifierTypes));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.GetCustomEntityRelationships";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ResourceListOfRelationship>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/relationships", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCustomEntityRelationships", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType. List all the Custom Entities matching particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfCustomEntityResponse</returns>
        public PagedResourceListOfCustomEntityResponse ListCustomEntities(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCustomEntityResponse> localVarResponse = ListCustomEntitiesWithHttpInfo(entityType, effectiveAt, asAt, limit, filter, sortBy, page, relatedEntityPropertyKeys, relationshipDefinitionIds, propertyKeys, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType. List all the Custom Entities matching particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfCustomEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCustomEntityResponse> ListCustomEntitiesWithHttpInfo(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->ListCustomEntities");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (relatedEntityPropertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relatedEntityPropertyKeys", relatedEntityPropertyKeys));
            }
            if (relationshipDefinitionIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relationshipDefinitionIds", relationshipDefinitionIds));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.ListCustomEntities";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfCustomEntityResponse>("/api/customentities/{entityType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCustomEntities", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType. List all the Custom Entities matching particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfCustomEntityResponse</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfCustomEntityResponse> ListCustomEntitiesAsync(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCustomEntityResponse> localVarResponse = await ListCustomEntitiesWithHttpInfoAsync(entityType, effectiveAt, asAt, limit, filter, sortBy, page, relatedEntityPropertyKeys, relationshipDefinitionIds, propertyKeys, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// ListCustomEntities: List Custom Entities of the specified entityType. List all the Custom Entities matching particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of Custom Entity to list.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the entities. Defaults to the current LUSID             system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the entities. Defaults to returning the latest version             of each portfolio if not specified. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results. For more information about filtering             results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing entities; this             value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt             and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="relatedEntityPropertyKeys">A list of property keys from any domain that supports relationships             to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. (optional)</param>
        /// <param name="relationshipDefinitionIds">A list of relationship definitions that are used to decorate related entities             onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CustomEntity&#39; domain to decorate onto             the custom entities of any type supported by that property (defined within the property definition CustomEntityTypes).             These must have the format {domain}/{scope}/{code}, for example &#39;CustomEntity/someScope/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfCustomEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCustomEntityResponse>> ListCustomEntitiesWithHttpInfoAsync(string entityType, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), string? page = default(string?), List<string>? relatedEntityPropertyKeys = default(List<string>?), List<string>? relationshipDefinitionIds = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->ListCustomEntities");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (relatedEntityPropertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relatedEntityPropertyKeys", relatedEntityPropertyKeys));
            }
            if (relationshipDefinitionIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "relationshipDefinitionIds", relationshipDefinitionIds));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CustomEntitiesApi.ListCustomEntities";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfCustomEntityResponse>("/api/customentities/{entityType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCustomEntities", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity. Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public Dictionary<string, List<AccessMetadataValue>> PatchCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = PatchCustomEntityAccessMetadataWithHttpInfo(entityType, identifierType, identifierValue, identifierScope, accessMetadataOperation, effectiveAt, effectiveUntil, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity. Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> PatchCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'accessMetadataOperation' is set
            if (accessMetadataOperation == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'accessMetadataOperation' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (effectiveUntil != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveUntil", effectiveUntil));
            }
            localVarRequestOptions.Data = accessMetadataOperation;

            localVarRequestOptions.Operation = "CustomEntitiesApi.PatchCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Dictionary<string, List<AccessMetadataValue>>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PatchCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity. Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, List<AccessMetadataValue>>> PatchCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>> localVarResponse = await PatchCustomEntityAccessMetadataWithHttpInfoAsync(entityType, identifierType, identifierValue, identifierScope, accessMetadataOperation, effectiveAt, effectiveUntil, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity. Patch Custom Entity Access Metadata Rules in a single scope. The behaviour is defined by the JSON Patch specification.              Currently only &#39;add&#39; is a supported operation on the patch document  Currently only valid metadata keys are supported paths on the patch document              The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="accessMetadataOperation">The Json Patch document</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, List&lt;AccessMetadataValue&gt;&gt;)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<Dictionary<string, List<AccessMetadataValue>>>> PatchCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string identifierScope, List<AccessMetadataOperation> accessMetadataOperation, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }

            // verify the required parameter 'accessMetadataOperation' is set
            if (accessMetadataOperation == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'accessMetadataOperation' when calling CustomEntitiesApi->PatchCustomEntityAccessMetadata");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (effectiveUntil != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveUntil", effectiveUntil));
            }
            localVarRequestOptions.Data = accessMetadataOperation;

            localVarRequestOptions.Operation = "CustomEntitiesApi.PatchCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Dictionary<string, List<AccessMetadataValue>>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PatchCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>UpsertCustomEntitiesResponse</returns>
        public UpsertCustomEntitiesResponse UpsertCustomEntities(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<UpsertCustomEntitiesResponse> localVarResponse = UpsertCustomEntitiesWithHttpInfo(entityType, successMode, requestBody, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of UpsertCustomEntitiesResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<UpsertCustomEntitiesResponse> UpsertCustomEntitiesWithHttpInfo(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->UpsertCustomEntities");
            }

            // verify the required parameter 'successMode' is set
            if (successMode == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'successMode' when calling CustomEntitiesApi->UpsertCustomEntities");
            }

            // verify the required parameter 'requestBody' is set
            if (requestBody == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'requestBody' when calling CustomEntitiesApi->UpsertCustomEntities");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "successMode", successMode));
            localVarRequestOptions.Data = requestBody;

            localVarRequestOptions.Operation = "CustomEntitiesApi.UpsertCustomEntities";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UpsertCustomEntitiesResponse>("/api/customentities/{entityType}/$batchUpsert", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertCustomEntities", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of UpsertCustomEntitiesResponse</returns>
        public async System.Threading.Tasks.Task<UpsertCustomEntitiesResponse> UpsertCustomEntitiesAsync(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<UpsertCustomEntitiesResponse> localVarResponse = await UpsertCustomEntitiesWithHttpInfoAsync(entityType, successMode, requestBody, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="successMode">Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial</param>
        /// <param name="requestBody">The payload describing the Custom Entity instances</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (UpsertCustomEntitiesResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<UpsertCustomEntitiesResponse>> UpsertCustomEntitiesWithHttpInfoAsync(string entityType, string successMode, Dictionary<string, CustomEntityRequest> requestBody, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->UpsertCustomEntities");
            }

            // verify the required parameter 'successMode' is set
            if (successMode == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'successMode' when calling CustomEntitiesApi->UpsertCustomEntities");
            }

            // verify the required parameter 'requestBody' is set
            if (requestBody == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'requestBody' when calling CustomEntitiesApi->UpsertCustomEntities");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "successMode", successMode));
            localVarRequestOptions.Data = requestBody;

            localVarRequestOptions.Operation = "CustomEntitiesApi.UpsertCustomEntities";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<UpsertCustomEntitiesResponse>("/api/customentities/{entityType}/$batchUpsert", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertCustomEntities", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CustomEntityResponse</returns>
        public CustomEntityResponse UpsertCustomEntity(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> localVarResponse = UpsertCustomEntityWithHttpInfo(entityType, customEntityRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CustomEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> UpsertCustomEntityWithHttpInfo(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->UpsertCustomEntity");
            }

            // verify the required parameter 'customEntityRequest' is set
            if (customEntityRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'customEntityRequest' when calling CustomEntitiesApi->UpsertCustomEntity");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.Data = customEntityRequest;

            localVarRequestOptions.Operation = "CustomEntitiesApi.UpsertCustomEntity";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CustomEntityResponse>("/api/customentities/{entityType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertCustomEntity", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CustomEntityResponse</returns>
        public async System.Threading.Tasks.Task<CustomEntityResponse> UpsertCustomEntityAsync(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CustomEntityResponse> localVarResponse = await UpsertCustomEntityWithHttpInfoAsync(entityType, customEntityRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// UpsertCustomEntity: Upsert a Custom Entity instance Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity to be created. An entityType can be created using the \&quot;CreateCustomEntityDefinition\&quot; endpoint for CustomEntityDefinitions.</param>
        /// <param name="customEntityRequest">The payload describing the Custom Entity instance.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CustomEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CustomEntityResponse>> UpsertCustomEntityWithHttpInfoAsync(string entityType, CustomEntityRequest customEntityRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->UpsertCustomEntity");
            }

            // verify the required parameter 'customEntityRequest' is set
            if (customEntityRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'customEntityRequest' when calling CustomEntitiesApi->UpsertCustomEntity");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.Data = customEntityRequest;

            localVarRequestOptions.Operation = "CustomEntitiesApi.UpsertCustomEntity";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CustomEntityResponse>("/api/customentities/{entityType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertCustomEntity", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>List&lt;AccessMetadataValue&gt;</returns>
        public List<AccessMetadataValue> UpsertCustomEntityAccessMetadata(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> localVarResponse = UpsertCustomEntityAccessMetadataWithHttpInfo(entityType, identifierType, identifierValue, metadataKey, identifierScope, upsertCustomEntityAccessMetadataRequest, effectiveAt, effectiveUntil, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of List&lt;AccessMetadataValue&gt;</returns>
        public Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> UpsertCustomEntityAccessMetadataWithHttpInfo(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'metadataKey' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'upsertCustomEntityAccessMetadataRequest' is set
            if (upsertCustomEntityAccessMetadataRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'upsertCustomEntityAccessMetadataRequest' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.PathParameters.Add("metadataKey", Lusid.Sdk.Client.ClientUtils.ParameterToString(metadataKey)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (effectiveUntil != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveUntil", effectiveUntil));
            }
            localVarRequestOptions.Data = upsertCustomEntityAccessMetadataRequest;

            localVarRequestOptions.Operation = "CustomEntitiesApi.UpsertCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<List<AccessMetadataValue>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata/{metadataKey}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of List&lt;AccessMetadataValue&gt;</returns>
        public async System.Threading.Tasks.Task<List<AccessMetadataValue>> UpsertCustomEntityAccessMetadataAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>> localVarResponse = await UpsertCustomEntityAccessMetadataWithHttpInfoAsync(entityType, identifierType, identifierValue, metadataKey, identifierScope, upsertCustomEntityAccessMetadataRequest, effectiveAt, effectiveUntil, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID. Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists and inserted if it does not.              The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.              It is important to always check to verify success (or failure).              Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityType">The type of the Custom Entity.</param>
        /// <param name="identifierType">An identifier type attached to the Custom Entity instance.</param>
        /// <param name="identifierValue">The identifier value.</param>
        /// <param name="metadataKey">Key of the metadata entry to retrieve</param>
        /// <param name="identifierScope">The identifier scope.</param>
        /// <param name="upsertCustomEntityAccessMetadataRequest">The Custom Entity Access Metadata entry to upsert</param>
        /// <param name="effectiveAt">The effectiveAt datetime at which the Access Metadata will be effective from (optional)</param>
        /// <param name="effectiveUntil">The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next &#39;effectiveAt&#39; datetime of the Access Metadata (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (List&lt;AccessMetadataValue&gt;)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<List<AccessMetadataValue>>> UpsertCustomEntityAccessMetadataWithHttpInfoAsync(string entityType, string identifierType, string identifierValue, string metadataKey, string identifierScope, UpsertCustomEntityAccessMetadataRequest upsertCustomEntityAccessMetadataRequest, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? effectiveUntil = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'entityType' is set
            if (entityType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'entityType' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierType' is set
            if (identifierType == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierType' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierValue' is set
            if (identifierValue == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierValue' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'metadataKey' is set
            if (metadataKey == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'metadataKey' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'identifierScope' is set
            if (identifierScope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'identifierScope' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }

            // verify the required parameter 'upsertCustomEntityAccessMetadataRequest' is set
            if (upsertCustomEntityAccessMetadataRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'upsertCustomEntityAccessMetadataRequest' when calling CustomEntitiesApi->UpsertCustomEntityAccessMetadata");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("entityType", Lusid.Sdk.Client.ClientUtils.ParameterToString(entityType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierType", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierType)); // path parameter
            localVarRequestOptions.PathParameters.Add("identifierValue", Lusid.Sdk.Client.ClientUtils.ParameterToString(identifierValue)); // path parameter
            localVarRequestOptions.PathParameters.Add("metadataKey", Lusid.Sdk.Client.ClientUtils.ParameterToString(metadataKey)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "identifierScope", identifierScope));
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (effectiveUntil != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveUntil", effectiveUntil));
            }
            localVarRequestOptions.Data = upsertCustomEntityAccessMetadataRequest;

            localVarRequestOptions.Operation = "CustomEntitiesApi.UpsertCustomEntityAccessMetadata";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<List<AccessMetadataValue>>("/api/customentities/{entityType}/{identifierType}/{identifierValue}/metadata/{metadataKey}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpsertCustomEntityAccessMetadata", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}