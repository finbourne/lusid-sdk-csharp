/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using Object = System.Object;
using InvalidOperationException = System.InvalidOperationException;
using Exception = System.Exception;
using ArgumentNullException = System.ArgumentNullException;
using SystemEventHandler = System.EventHandler;
using DateTimeOffset = System.DateTimeOffset;
using Guid = System.Guid;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using IApiAccessor = Lusid.Sdk.Client.IApiAccessor;
using Lusid.Sdk.Extensions;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICheckDefinitionsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition
        /// </summary>
        /// <remarks>
        /// Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CheckDefinition</returns>
        CheckDefinition CreateCheckDefinition(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition
        /// </summary>
        /// <remarks>
        /// Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CheckDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<CheckDefinition> CreateCheckDefinitionWithHttpInfo(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteCheckDefinition(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteCheckDefinitionWithHttpInfo(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CheckDefinition</returns>
        CheckDefinition GetCheckDefinition(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CheckDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<CheckDefinition> GetCheckDefinitionWithHttpInfo(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions
        /// </summary>
        /// <remarks>
        /// List all the Check Definitions matching a particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfCheckDefinition</returns>
        PagedResourceListOfCheckDefinition ListCheckDefinitions(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions
        /// </summary>
        /// <remarks>
        /// List all the Check Definitions matching a particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfCheckDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCheckDefinition> ListCheckDefinitionsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset.
        /// </summary>
        /// <remarks>
        /// Runs a Check Definition against given dataset.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>RunCheckResponse</returns>
        RunCheckResponse RunCheckDefinition(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset.
        /// </summary>
        /// <remarks>
        /// Runs a Check Definition against given dataset.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of RunCheckResponse</returns>
        Lusid.Sdk.Client.ApiResponse<RunCheckResponse> RunCheckDefinitionWithHttpInfo(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CheckDefinition</returns>
        CheckDefinition UpdateCheckDefinition(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CheckDefinition</returns>
        Lusid.Sdk.Client.ApiResponse<CheckDefinition> UpdateCheckDefinitionWithHttpInfo(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICheckDefinitionsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition
        /// </summary>
        /// <remarks>
        /// Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CheckDefinition</returns>
        System.Threading.Tasks.Task<CheckDefinition> CreateCheckDefinitionAsync(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition
        /// </summary>
        /// <remarks>
        /// Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CheckDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CheckDefinition>> CreateCheckDefinitionWithHttpInfoAsync(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteCheckDefinitionAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteCheckDefinitionWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CheckDefinition</returns>
        System.Threading.Tasks.Task<CheckDefinition> GetCheckDefinitionAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CheckDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CheckDefinition>> GetCheckDefinitionWithHttpInfoAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions
        /// </summary>
        /// <remarks>
        /// List all the Check Definitions matching a particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfCheckDefinition</returns>
        System.Threading.Tasks.Task<PagedResourceListOfCheckDefinition> ListCheckDefinitionsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions
        /// </summary>
        /// <remarks>
        /// List all the Check Definitions matching a particular criteria.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfCheckDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCheckDefinition>> ListCheckDefinitionsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset.
        /// </summary>
        /// <remarks>
        /// Runs a Check Definition against given dataset.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of RunCheckResponse</returns>
        System.Threading.Tasks.Task<RunCheckResponse> RunCheckDefinitionAsync(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset.
        /// </summary>
        /// <remarks>
        /// Runs a Check Definition against given dataset.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (RunCheckResponse)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<RunCheckResponse>> RunCheckDefinitionWithHttpInfoAsync(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CheckDefinition</returns>
        System.Threading.Tasks.Task<CheckDefinition> UpdateCheckDefinitionAsync(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CheckDefinition)</returns>
        System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CheckDefinition>> UpdateCheckDefinitionWithHttpInfoAsync(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICheckDefinitionsApi : ICheckDefinitionsApiSync, ICheckDefinitionsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CheckDefinitionsApi : ICheckDefinitionsApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="CheckDefinitionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CheckDefinitionsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CheckDefinitionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CheckDefinitionsApi(string basePath)
        {
            var globalConfiguration = Lusid.Sdk.Client.GlobalConfiguration.Instance;
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                globalConfiguration,
                new Lusid.Sdk.Client.Configuration
                {
                    BasePath = basePath,
                    TimeoutMs = globalConfiguration.TimeoutMs,
                    RateLimitRetries = globalConfiguration.RateLimitRetries
                }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CheckDefinitionsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CheckDefinitionsApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CheckDefinitionsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public CheckDefinitionsApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CheckDefinition</returns>
        public CheckDefinition CreateCheckDefinition(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CheckDefinition> localVarResponse = CreateCheckDefinitionWithHttpInfo(createCheckDefinitionRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CheckDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<CheckDefinition> CreateCheckDefinitionWithHttpInfo(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createCheckDefinitionRequest;

            localVarRequestOptions.Operation = "CheckDefinitionsApi.CreateCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CheckDefinition>("/api/dataquality/checkdefinitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CheckDefinition</returns>
        public async System.Threading.Tasks.Task<CheckDefinition> CreateCheckDefinitionAsync(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CheckDefinition> localVarResponse = await CreateCheckDefinitionWithHttpInfoAsync(createCheckDefinitionRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateCheckDefinition: Create a Check Definition Creates a Check Definition. Returns the created Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Upserted Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCheckDefinitionRequest">The request containing the details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CheckDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CheckDefinition>> CreateCheckDefinitionWithHttpInfoAsync(CreateCheckDefinitionRequest? createCheckDefinitionRequest = default(CreateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createCheckDefinitionRequest;

            localVarRequestOptions.Operation = "CheckDefinitionsApi.CreateCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CheckDefinition>("/api/dataquality/checkdefinitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteCheckDefinition(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteCheckDefinitionWithHttpInfo(scope, code, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteCheckDefinitionWithHttpInfo(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->DeleteCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->DeleteCheckDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "CheckDefinitionsApi.DeleteCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/dataquality/checkdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteCheckDefinitionAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteCheckDefinitionWithHttpInfoAsync(scope, code, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteCheckDefinition: Deletes a particular Check Definition The deletion will take effect from the Check Definition deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely              identifies the Check Definition.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteCheckDefinitionWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->DeleteCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->DeleteCheckDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "CheckDefinitionsApi.DeleteCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/dataquality/checkdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code. Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CheckDefinition</returns>
        public CheckDefinition GetCheckDefinition(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CheckDefinition> localVarResponse = GetCheckDefinitionWithHttpInfo(scope, code, asAt, effectiveAt, propertyKeys, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code. Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CheckDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<CheckDefinition> GetCheckDefinitionWithHttpInfo(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->GetCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->GetCheckDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (asAt != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (propertyKeys != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CheckDefinitionsApi.GetCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CheckDefinition>("/api/dataquality/checkdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code. Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CheckDefinition</returns>
        public async System.Threading.Tasks.Task<CheckDefinition> GetCheckDefinitionAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CheckDefinition> localVarResponse = await GetCheckDefinitionWithHttpInfoAsync(scope, code, asAt, effectiveAt, propertyKeys, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetCheckDefinition: Get a single Check Definition by scope and code. Retrieves one Check Definition by scope and code.  Check Definitions are mono-temporal. The EffectiveAt is only applied to Time-Variant Properties.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the scope this uniquely              identifies the Check Definition.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the Check Definition definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the check definition properties.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto              the Check Definition.              These must have the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/system/Name&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CheckDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CheckDefinition>> GetCheckDefinitionWithHttpInfoAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->GetCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->GetCheckDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CheckDefinitionsApi.GetCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CheckDefinition>("/api/dataquality/checkdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions List all the Check Definitions matching a particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfCheckDefinition</returns>
        public PagedResourceListOfCheckDefinition ListCheckDefinitions(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCheckDefinition> localVarResponse = ListCheckDefinitionsWithHttpInfo(asAt, effectiveAt, page, limit, filter, sortBy, propertyKeys, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions List all the Check Definitions matching a particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfCheckDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCheckDefinition> ListCheckDefinitionsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (page != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (propertyKeys != null)
            {

                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CheckDefinitionsApi.ListCheckDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfCheckDefinition>("/api/dataquality/checkdefinitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCheckDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions List all the Check Definitions matching a particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfCheckDefinition</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfCheckDefinition> ListCheckDefinitionsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCheckDefinition> localVarResponse = await ListCheckDefinitionsWithHttpInfoAsync(asAt, effectiveAt, page, limit, filter, sortBy, propertyKeys, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListCheckDefinitions: List Check Definitions List all the Check Definitions matching a particular criteria.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to list the Check Definitions. Defaults to returning the latest version of each Check Definition if not specified. (optional)</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the Check Definitions.              Note that Check Definitions are monotemporal, the effectiveAt is for Timevariant Properties on the Check Definition only.              Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing Check Definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the results to this number. Defaults to 100 if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the results.              For example, to filter on the displayName, specify \&quot;displayName eq &#39;MyCheckDefinition&#39;\&quot;. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914. (optional)</param>
        /// <param name="sortBy">A list of field names or properties to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="propertyKeys">A list of property keys from the &#39;CheckDefinition&#39; domain to decorate onto each Check Definition.              These must take the format {domain}/{scope}/{code}, for example &#39;CheckDefinition/Account/id&#39;. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfCheckDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfCheckDefinition>> ListCheckDefinitionsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), List<string>? propertyKeys = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (propertyKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "propertyKeys", propertyKeys));
            }

            localVarRequestOptions.Operation = "CheckDefinitionsApi.ListCheckDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfCheckDefinition>("/api/dataquality/checkdefinitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCheckDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset. Runs a Check Definition against given dataset.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>RunCheckResponse</returns>
        public RunCheckResponse RunCheckDefinition(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<RunCheckResponse> localVarResponse = RunCheckDefinitionWithHttpInfo(scope, code, runCheckRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset. Runs a Check Definition against given dataset.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of RunCheckResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<RunCheckResponse> RunCheckDefinitionWithHttpInfo(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->RunCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->RunCheckDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = runCheckRequest;

            localVarRequestOptions.Operation = "CheckDefinitionsApi.RunCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<RunCheckResponse>("/api/dataquality/checkdefinitions/{scope}/{code}/$run", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RunCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset. Runs a Check Definition against given dataset.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of RunCheckResponse</returns>
        public async System.Threading.Tasks.Task<RunCheckResponse> RunCheckDefinitionAsync(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<RunCheckResponse> localVarResponse = await RunCheckDefinitionWithHttpInfoAsync(scope, code, runCheckRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunCheckDefinition: Runs a Check Definition against given dataset. Runs a Check Definition against given dataset.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Scope of the CheckDefinition to run.</param>
        /// <param name="code">Code of the CheckDefinition to run.</param>
        /// <param name="runCheckRequest">Run request defining what dataset to run against. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (RunCheckResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<RunCheckResponse>> RunCheckDefinitionWithHttpInfoAsync(string scope, string code, RunCheckRequest? runCheckRequest = default(RunCheckRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->RunCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->RunCheckDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = runCheckRequest;

            localVarRequestOptions.Operation = "CheckDefinitionsApi.RunCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<RunCheckResponse>("/api/dataquality/checkdefinitions/{scope}/{code}/$run", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RunCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>CheckDefinition</returns>
        public CheckDefinition UpdateCheckDefinition(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CheckDefinition> localVarResponse = UpdateCheckDefinitionWithHttpInfo(scope, code, updateCheckDefinitionRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of CheckDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<CheckDefinition> UpdateCheckDefinitionWithHttpInfo(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->UpdateCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->UpdateCheckDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateCheckDefinitionRequest;

            localVarRequestOptions.Operation = "CheckDefinitionsApi.UpdateCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<CheckDefinition>("/api/dataquality/checkdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of CheckDefinition</returns>
        public async System.Threading.Tasks.Task<CheckDefinition> UpdateCheckDefinitionAsync(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<CheckDefinition> localVarResponse = await UpdateCheckDefinitionWithHttpInfoAsync(scope, code, updateCheckDefinitionRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateCheckDefinition: Update Check Definition defined by scope and code Overwrites an existing Check Definition  Update request has the same required fields as Create apart from the id.  Returns the updated Check Definition at the current effectiveAt.  Note that Check Definitions are mono-temporal, however they can have Time-Variant Properties.  Updated Properties will be returned at the latest AsAt and EffectiveAt
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified Check Definition.</param>
        /// <param name="code">The code of the specified Check Definition. Together with the domain and scope this uniquely identifies the Check Definition.</param>
        /// <param name="updateCheckDefinitionRequest">The request containing the updated details of the Check Definition (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (CheckDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<CheckDefinition>> UpdateCheckDefinitionWithHttpInfoAsync(string scope, string code, UpdateCheckDefinitionRequest? updateCheckDefinitionRequest = default(UpdateCheckDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling CheckDefinitionsApi->UpdateCheckDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling CheckDefinitionsApi->UpdateCheckDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateCheckDefinitionRequest;

            localVarRequestOptions.Operation = "CheckDefinitionsApi.UpdateCheckDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<CheckDefinition>("/api/dataquality/checkdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCheckDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}