/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using Object = System.Object;
using InvalidOperationException = System.InvalidOperationException;
using Exception = System.Exception;
using ArgumentNullException = System.ArgumentNullException;
using SystemEventHandler = System.EventHandler;
using DateTimeOffset = System.DateTimeOffset;
using Guid = System.Guid;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Lusid.Sdk.Client;
using Lusid.Sdk.Extensions;
using Lusid.Sdk.Client.Auth;
using Lusid.Sdk.Model;

namespace Lusid.Sdk.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IGroupReconciliationsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition.
        /// </summary>
        /// <remarks>
        /// Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>BatchUpdateUserReviewForComparisonResultResponse</returns>
        BatchUpdateUserReviewForComparisonResultResponse BatchUpdateComparisonResults(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition.
        /// </summary>
        /// <remarks>
        /// Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of BatchUpdateUserReviewForComparisonResultResponse</returns>
        ApiResponse<BatchUpdateUserReviewForComparisonResultResponse> BatchUpdateComparisonResultsWithHttpInfo(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonRuleset</returns>
        GroupReconciliationComparisonRuleset CreateComparisonRuleset(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonRuleset</returns>
        ApiResponse<GroupReconciliationComparisonRuleset> CreateComparisonRulesetWithHttpInfo(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Creates a Group Reconciliation Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationDefinition</returns>
        GroupReconciliationDefinition CreateGroupReconciliationDefinition(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Creates a Group Reconciliation Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationDefinition</returns>
        ApiResponse<GroupReconciliationDefinition> CreateGroupReconciliationDefinitionWithHttpInfo(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteComparisonRuleset(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeleteComparisonRulesetWithHttpInfo(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Delete the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        DeletedEntityResponse DeleteGroupReconciliationDefinition(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Delete the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        ApiResponse<DeletedEntityResponse> DeleteGroupReconciliationDefinitionWithHttpInfo(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonResult</returns>
        GroupReconciliationComparisonResult GetComparisonResult(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonResult</returns>
        ApiResponse<GroupReconciliationComparisonResult> GetComparisonResultWithHttpInfo(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonRuleset</returns>
        GroupReconciliationComparisonRuleset GetComparisonRuleset(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonRuleset</returns>
        ApiResponse<GroupReconciliationComparisonRuleset> GetComparisonRulesetWithHttpInfo(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Retrieves a Group Reconciliation Definition by scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationDefinition</returns>
        GroupReconciliationDefinition GetGroupReconciliationDefinition(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Retrieves a Group Reconciliation Definition by scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationDefinition</returns>
        ApiResponse<GroupReconciliationDefinition> GetGroupReconciliationDefinitionWithHttpInfo(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results.
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfGroupReconciliationComparisonResult</returns>
        PagedResourceListOfGroupReconciliationComparisonResult ListComparisonResults(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results.
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfGroupReconciliationComparisonResult</returns>
        ApiResponse<PagedResourceListOfGroupReconciliationComparisonResult> ListComparisonResultsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfGroupReconciliationComparisonRuleset</returns>
        PagedResourceListOfGroupReconciliationComparisonRuleset ListComparisonRulesets(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfGroupReconciliationComparisonRuleset</returns>
        ApiResponse<PagedResourceListOfGroupReconciliationComparisonRuleset> ListComparisonRulesetsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions
        /// </summary>
        /// <remarks>
        /// Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfGroupReconciliationDefinition</returns>
        PagedResourceListOfGroupReconciliationDefinition ListGroupReconciliationDefinitions(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions
        /// </summary>
        /// <remarks>
        /// Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfGroupReconciliationDefinition</returns>
        ApiResponse<PagedResourceListOfGroupReconciliationDefinition> ListGroupReconciliationDefinitionsWithHttpInfo(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation
        /// </summary>
        /// <remarks>
        /// Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationRunResponse</returns>
        GroupReconciliationRunResponse RunReconciliation(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation
        /// </summary>
        /// <remarks>
        /// Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationRunResponse</returns>
        ApiResponse<GroupReconciliationRunResponse> RunReconciliationWithHttpInfo(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonRuleset</returns>
        GroupReconciliationComparisonRuleset UpdateComparisonRuleset(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonRuleset</returns>
        ApiResponse<GroupReconciliationComparisonRuleset> UpdateComparisonRulesetWithHttpInfo(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Update the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationDefinition</returns>
        GroupReconciliationDefinition UpdateGroupReconciliationDefinition(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Update the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationDefinition</returns>
        ApiResponse<GroupReconciliationDefinition> UpdateGroupReconciliationDefinitionWithHttpInfo(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IGroupReconciliationsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition.
        /// </summary>
        /// <remarks>
        /// Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of BatchUpdateUserReviewForComparisonResultResponse</returns>
        System.Threading.Tasks.Task<BatchUpdateUserReviewForComparisonResultResponse> BatchUpdateComparisonResultsAsync(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition.
        /// </summary>
        /// <remarks>
        /// Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (BatchUpdateUserReviewForComparisonResultResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchUpdateUserReviewForComparisonResultResponse>> BatchUpdateComparisonResultsWithHttpInfoAsync(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonRuleset</returns>
        System.Threading.Tasks.Task<GroupReconciliationComparisonRuleset> CreateComparisonRulesetAsync(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonRuleset)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationComparisonRuleset>> CreateComparisonRulesetWithHttpInfoAsync(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Creates a Group Reconciliation Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationDefinition</returns>
        System.Threading.Tasks.Task<GroupReconciliationDefinition> CreateGroupReconciliationDefinitionAsync(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Creates a Group Reconciliation Definition
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationDefinition)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationDefinition>> CreateGroupReconciliationDefinitionWithHttpInfoAsync(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteComparisonRulesetAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset
        /// </summary>
        /// <remarks>
        /// The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeleteComparisonRulesetWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Delete the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        System.Threading.Tasks.Task<DeletedEntityResponse> DeleteGroupReconciliationDefinitionAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition
        /// </summary>
        /// <remarks>
        /// Delete the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeletedEntityResponse>> DeleteGroupReconciliationDefinitionWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonResult</returns>
        System.Threading.Tasks.Task<GroupReconciliationComparisonResult> GetComparisonResultAsync(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationComparisonResult>> GetComparisonResultWithHttpInfoAsync(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonRuleset</returns>
        System.Threading.Tasks.Task<GroupReconciliationComparisonRuleset> GetComparisonRulesetAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <remarks>
        /// Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonRuleset)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationComparisonRuleset>> GetComparisonRulesetWithHttpInfoAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Retrieves a Group Reconciliation Definition by scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationDefinition</returns>
        System.Threading.Tasks.Task<GroupReconciliationDefinition> GetGroupReconciliationDefinitionAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Retrieves a Group Reconciliation Definition by scope and code
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationDefinition)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationDefinition>> GetGroupReconciliationDefinitionWithHttpInfoAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results.
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfGroupReconciliationComparisonResult</returns>
        System.Threading.Tasks.Task<PagedResourceListOfGroupReconciliationComparisonResult> ListComparisonResultsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results.
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfGroupReconciliationComparisonResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfGroupReconciliationComparisonResult>> ListComparisonResultsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfGroupReconciliationComparisonRuleset</returns>
        System.Threading.Tasks.Task<PagedResourceListOfGroupReconciliationComparisonRuleset> ListComparisonRulesetsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets
        /// </summary>
        /// <remarks>
        /// Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfGroupReconciliationComparisonRuleset)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfGroupReconciliationComparisonRuleset>> ListComparisonRulesetsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions
        /// </summary>
        /// <remarks>
        /// Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfGroupReconciliationDefinition</returns>
        System.Threading.Tasks.Task<PagedResourceListOfGroupReconciliationDefinition> ListGroupReconciliationDefinitionsAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions
        /// </summary>
        /// <remarks>
        /// Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfGroupReconciliationDefinition)</returns>
        System.Threading.Tasks.Task<ApiResponse<PagedResourceListOfGroupReconciliationDefinition>> ListGroupReconciliationDefinitionsWithHttpInfoAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation
        /// </summary>
        /// <remarks>
        /// Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationRunResponse</returns>
        System.Threading.Tasks.Task<GroupReconciliationRunResponse> RunReconciliationAsync(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation
        /// </summary>
        /// <remarks>
        /// Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationRunResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationRunResponse>> RunReconciliationWithHttpInfoAsync(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonRuleset</returns>
        System.Threading.Tasks.Task<GroupReconciliationComparisonRuleset> UpdateComparisonRulesetAsync(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code
        /// </summary>
        /// <remarks>
        /// Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonRuleset)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationComparisonRuleset>> UpdateComparisonRulesetWithHttpInfoAsync(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Update the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationDefinition</returns>
        System.Threading.Tasks.Task<GroupReconciliationDefinition> UpdateGroupReconciliationDefinitionAsync(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);

        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition
        /// </summary>
        /// <remarks>
        /// Update the group reconciliation definition.
        /// </remarks>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationDefinition)</returns>
        System.Threading.Tasks.Task<ApiResponse<GroupReconciliationDefinition>> UpdateGroupReconciliationDefinitionWithHttpInfoAsync(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IGroupReconciliationsApi : IGroupReconciliationsApiSync, IGroupReconciliationsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class GroupReconciliationsApi : IGroupReconciliationsApi
    {
        private Lusid.Sdk.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="GroupReconciliationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GroupReconciliationsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GroupReconciliationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GroupReconciliationsApi(string basePath)
        {
            var globalConfiguration = Lusid.Sdk.Client.GlobalConfiguration.Instance;
            this.Configuration = Lusid.Sdk.Client.Configuration.MergeConfigurations(
                globalConfiguration,
                new Lusid.Sdk.Client.Configuration
                {
                    BasePath = basePath,
                    TimeoutMs = globalConfiguration.TimeoutMs,
                    RateLimitRetries = globalConfiguration.RateLimitRetries
                }
            );
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GroupReconciliationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public GroupReconciliationsApi(Lusid.Sdk.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = configuration;
            this.Client = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Lusid.Sdk.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GroupReconciliationsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public GroupReconciliationsApi(Lusid.Sdk.Client.ISynchronousClient client, Lusid.Sdk.Client.IAsynchronousClient asyncClient, Lusid.Sdk.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Lusid.Sdk.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Lusid.Sdk.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Lusid.Sdk.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Lusid.Sdk.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Lusid.Sdk.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition. Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>BatchUpdateUserReviewForComparisonResultResponse</returns>
        public BatchUpdateUserReviewForComparisonResultResponse BatchUpdateComparisonResults(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<BatchUpdateUserReviewForComparisonResultResponse> localVarResponse = BatchUpdateComparisonResultsWithHttpInfo(scope, code, batchUpdateUserReviewForComparisonResultRequest, successMode, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition. Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of BatchUpdateUserReviewForComparisonResultResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<BatchUpdateUserReviewForComparisonResultResponse> BatchUpdateComparisonResultsWithHttpInfo(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->BatchUpdateComparisonResults");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->BatchUpdateComparisonResults");
            }

            // verify the required parameter 'batchUpdateUserReviewForComparisonResultRequest' is set
            if (batchUpdateUserReviewForComparisonResultRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'batchUpdateUserReviewForComparisonResultRequest' when calling GroupReconciliationsApi->BatchUpdateComparisonResults");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (successMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "successMode", successMode));
            }
            localVarRequestOptions.Data = batchUpdateUserReviewForComparisonResultRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.BatchUpdateComparisonResults";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchUpdateUserReviewForComparisonResultResponse>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}/comparisonresults/$batchReview", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("BatchUpdateComparisonResults", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition. Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of BatchUpdateUserReviewForComparisonResultResponse</returns>
        public async System.Threading.Tasks.Task<BatchUpdateUserReviewForComparisonResultResponse> BatchUpdateComparisonResultsAsync(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<BatchUpdateUserReviewForComparisonResultResponse> localVarResponse = await BatchUpdateComparisonResultsWithHttpInfoAsync(scope, code, batchUpdateUserReviewForComparisonResultRequest, successMode, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] BatchUpdateComparisonResults: Add User Review entries for a range of comparison results related to a specific GroupReconciliationDefinition. Allows to update multiple Group Reconciliation Comparison Results related to the same definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code.  Updates User Review with new entries and sets the relevant Review Status.  Supports partial success when all the entries that haven&#39;t passed validation or are not related to the definition will be returned with respectful error details.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">Shared Scope of the GroupReconciliationDefinition and GroupReconciliationComparisonResults.</param>
        /// <param name="code">GroupReconciliationDefinitionId code.</param>
        /// <param name="batchUpdateUserReviewForComparisonResultRequest">A collection of the comparison result Ids and their user review entries to be added or removed.                  Single request contains resultId, break code/match key/comment to add and break code/match key/comment to remove by added timestamp.</param>
        /// <param name="successMode">Defines whether the request should fail if at least one of the entries is failed to update                  or process all the entries regardless and return collections of successful and failed updates. \&quot;Partial\&quot; (default) | \&quot;Atomic\&quot;. (optional, default to &quot;Partial&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (BatchUpdateUserReviewForComparisonResultResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<BatchUpdateUserReviewForComparisonResultResponse>> BatchUpdateComparisonResultsWithHttpInfoAsync(string scope, string code, List<BatchUpdateUserReviewForComparisonResultRequest> batchUpdateUserReviewForComparisonResultRequest, string? successMode = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->BatchUpdateComparisonResults");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->BatchUpdateComparisonResults");
            }

            // verify the required parameter 'batchUpdateUserReviewForComparisonResultRequest' is set
            if (batchUpdateUserReviewForComparisonResultRequest == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'batchUpdateUserReviewForComparisonResultRequest' when calling GroupReconciliationsApi->BatchUpdateComparisonResults");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (successMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "successMode", successMode));
            }
            localVarRequestOptions.Data = batchUpdateUserReviewForComparisonResultRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.BatchUpdateComparisonResults";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchUpdateUserReviewForComparisonResultResponse>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}/comparisonresults/$batchReview", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("BatchUpdateComparisonResults", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonRuleset</returns>
        public GroupReconciliationComparisonRuleset CreateComparisonRuleset(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> localVarResponse = CreateComparisonRulesetWithHttpInfo(createGroupReconciliationComparisonRulesetRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonRuleset</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> CreateComparisonRulesetWithHttpInfo(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createGroupReconciliationComparisonRulesetRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.CreateComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<GroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonRuleset</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationComparisonRuleset> CreateComparisonRulesetAsync(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> localVarResponse = await CreateComparisonRulesetWithHttpInfoAsync(createGroupReconciliationComparisonRulesetRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateComparisonRuleset: Create a Group Reconciliation Comparison Ruleset Creates a set of core and aggregate rules to be run for a group reconciliation
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationComparisonRulesetRequest">The request containing the details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonRuleset)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset>> CreateComparisonRulesetWithHttpInfoAsync(CreateGroupReconciliationComparisonRulesetRequest? createGroupReconciliationComparisonRulesetRequest = default(CreateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createGroupReconciliationComparisonRulesetRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.CreateComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<GroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition Creates a Group Reconciliation Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationDefinition</returns>
        public GroupReconciliationDefinition CreateGroupReconciliationDefinition(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> localVarResponse = CreateGroupReconciliationDefinitionWithHttpInfo(createGroupReconciliationDefinitionRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition Creates a Group Reconciliation Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> CreateGroupReconciliationDefinitionWithHttpInfo(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createGroupReconciliationDefinitionRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.CreateGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<GroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition Creates a Group Reconciliation Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationDefinition</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationDefinition> CreateGroupReconciliationDefinitionAsync(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> localVarResponse = await CreateGroupReconciliationDefinitionWithHttpInfoAsync(createGroupReconciliationDefinitionRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] CreateGroupReconciliationDefinition: Create Group Reconciliation Definition Creates a Group Reconciliation Definition
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createGroupReconciliationDefinitionRequest">The definition Group Reconciliation Definition details (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition>> CreateGroupReconciliationDefinitionWithHttpInfoAsync(CreateGroupReconciliationDefinitionRequest? createGroupReconciliationDefinitionRequest = default(CreateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = createGroupReconciliationDefinitionRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.CreateGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<GroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteComparisonRuleset(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteComparisonRulesetWithHttpInfo(scope, code, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteComparisonRulesetWithHttpInfo(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->DeleteComparisonRuleset");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->DeleteComparisonRuleset");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "GroupReconciliationsApi.DeleteComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/reconciliations/comparisonrulesets/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteComparisonRulesetAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteComparisonRulesetWithHttpInfoAsync(scope, code, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteComparisonRuleset: Deletes a particular Group Reconciliation Comparison Ruleset The deletion will take effect from the reconciliation comparison ruleset deletion datetime.  i.e. will no longer exist at any asAt datetime after the asAt datetime of deletion.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteComparisonRulesetWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->DeleteComparisonRuleset");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->DeleteComparisonRuleset");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "GroupReconciliationsApi.DeleteComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/reconciliations/comparisonrulesets/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition Delete the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>DeletedEntityResponse</returns>
        public DeletedEntityResponse DeleteGroupReconciliationDefinition(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = DeleteGroupReconciliationDefinitionWithHttpInfo(scope, code, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition Delete the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of DeletedEntityResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> DeleteGroupReconciliationDefinitionWithHttpInfo(string scope, string code, int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->DeleteGroupReconciliationDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->DeleteGroupReconciliationDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "GroupReconciliationsApi.DeleteGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<DeletedEntityResponse>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition Delete the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of DeletedEntityResponse</returns>
        public async System.Threading.Tasks.Task<DeletedEntityResponse> DeleteGroupReconciliationDefinitionAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse> localVarResponse = await DeleteGroupReconciliationDefinitionWithHttpInfoAsync(scope, code, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] DeleteGroupReconciliationDefinition: Delete Group Reconciliation Definition Delete the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to delete.</param>
        /// <param name="code">The code of the group reconciliation definition to delete. Together with the scope this uniquely identifies the group reconciliation definition to delete.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (DeletedEntityResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<DeletedEntityResponse>> DeleteGroupReconciliationDefinitionWithHttpInfoAsync(string scope, string code, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->DeleteGroupReconciliationDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->DeleteGroupReconciliationDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter

            localVarRequestOptions.Operation = "GroupReconciliationsApi.DeleteGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<DeletedEntityResponse>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code. Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonResult</returns>
        public GroupReconciliationComparisonResult GetComparisonResult(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonResult> localVarResponse = GetComparisonResultWithHttpInfo(scope, code, resultId, asAt, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code. Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonResult</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonResult> GetComparisonResultWithHttpInfo(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->GetComparisonResult");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->GetComparisonResult");
            }

            // verify the required parameter 'resultId' is set
            if (resultId == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'resultId' when calling GroupReconciliationsApi->GetComparisonResult");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("resultId", Lusid.Sdk.Client.ClientUtils.ParameterToString(resultId)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.GetComparisonResult";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GroupReconciliationComparisonResult>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}/{resultId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetComparisonResult", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code. Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonResult</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationComparisonResult> GetComparisonResultAsync(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonResult> localVarResponse = await GetComparisonResultWithHttpInfoAsync(scope, code, resultId, asAt, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonResult: Get a single Group Reconciliation Comparison Result by scope and code. Retrieves one Group Reconciliation Comparison Result by scope and code  with the prior validation that its related reconciliation definition exists.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison result and its related reconciliation definition.</param>
        /// <param name="code">The code of the reconciliation definition that was used to produce the reconciliation result.</param>
        /// <param name="resultId">The code of the specified reconciliation result. Together with the domain and scope this uniquely              identifies the reconciliation comparison result. This value is also the same as the computed result hash based on property values.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison result definition. Defaults to return              the latest version if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonResult)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonResult>> GetComparisonResultWithHttpInfoAsync(string scope, string code, string resultId, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->GetComparisonResult");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->GetComparisonResult");
            }

            // verify the required parameter 'resultId' is set
            if (resultId == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'resultId' when calling GroupReconciliationsApi->GetComparisonResult");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.PathParameters.Add("resultId", Lusid.Sdk.Client.ClientUtils.ParameterToString(resultId)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.GetComparisonResult";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GroupReconciliationComparisonResult>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}/{resultId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetComparisonResult", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code. Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonRuleset</returns>
        public GroupReconciliationComparisonRuleset GetComparisonRuleset(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> localVarResponse = GetComparisonRulesetWithHttpInfo(scope, code, asAt, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code. Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonRuleset</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> GetComparisonRulesetWithHttpInfo(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->GetComparisonRuleset");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->GetComparisonRuleset");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.GetComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code. Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonRuleset</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationComparisonRuleset> GetComparisonRulesetAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> localVarResponse = await GetComparisonRulesetWithHttpInfoAsync(scope, code, asAt, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetComparisonRuleset: Get a single Group Reconciliation Comparison Ruleset by scope and code. Retrieves one Group Reconciliation Comparison Ruleset by scope and code.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely              identifies the reconciliation comparison ruleset.</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison ruleset definition. Defaults to return              the latest version of the definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonRuleset)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset>> GetComparisonRulesetWithHttpInfoAsync(string scope, string code, DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->GetComparisonRuleset");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->GetComparisonRuleset");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.GetComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition Retrieves a Group Reconciliation Definition by scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationDefinition</returns>
        public GroupReconciliationDefinition GetGroupReconciliationDefinition(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> localVarResponse = GetGroupReconciliationDefinitionWithHttpInfo(scope, code, effectiveAt, asAt, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition Retrieves a Group Reconciliation Definition by scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> GetGroupReconciliationDefinitionWithHttpInfo(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->GetGroupReconciliationDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->GetGroupReconciliationDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.GetGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition Retrieves a Group Reconciliation Definition by scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationDefinition</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationDefinition> GetGroupReconciliationDefinitionAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> localVarResponse = await GetGroupReconciliationDefinitionWithHttpInfoAsync(scope, code, effectiveAt, asAt, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] GetGroupReconciliationDefinition: Get group reconciliation definition Retrieves a Group Reconciliation Definition by scope and code
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to retrieve.</param>
        /// <param name="code">The code of the group reconciliation definition to retrieve. Together with the scope              this uniquely identifies the group reconciliation definition.</param>
        /// <param name="effectiveAt">The effective datetime or cut label at which to retrieve the group reconciliation definition. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to retrieve the group reconciliation definition. Defaults to return the latest version of the portfolio group definition if not specified. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition>> GetGroupReconciliationDefinitionWithHttpInfoAsync(string scope, string code, DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->GetGroupReconciliationDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->GetGroupReconciliationDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.GetGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results. Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfGroupReconciliationComparisonResult</returns>
        public PagedResourceListOfGroupReconciliationComparisonResult ListComparisonResults(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonResult> localVarResponse = ListComparisonResultsWithHttpInfo(asAt, page, sortBy, limit, filter, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results. Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfGroupReconciliationComparisonResult</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonResult> ListComparisonResultsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.ListComparisonResults";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfGroupReconciliationComparisonResult>("/api/reconciliations/comparisonresults", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListComparisonResults", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results. Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfGroupReconciliationComparisonResult</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfGroupReconciliationComparisonResult> ListComparisonResultsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonResult> localVarResponse = await ListComparisonResultsWithHttpInfoAsync(asAt, page, sortBy, limit, filter, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonResults: Get a set of Group Reconciliation Comparison Results. Retrieves all Group Reconciliation Comparison Results that fit the filter, in a specific order if sortBy is provided.  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison results. Defaults to return the latest              version of the comparison results if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison results from a previous call to list              comparison results. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot;. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfGroupReconciliationComparisonResult)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonResult>> ListComparisonResultsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.ListComparisonResults";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfGroupReconciliationComparisonResult>("/api/reconciliations/comparisonresults", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListComparisonResults", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfGroupReconciliationComparisonRuleset</returns>
        public PagedResourceListOfGroupReconciliationComparisonRuleset ListComparisonRulesets(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonRuleset> localVarResponse = ListComparisonRulesetsWithHttpInfo(asAt, page, sortBy, limit, filter, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfGroupReconciliationComparisonRuleset</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonRuleset> ListComparisonRulesetsWithHttpInfo(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.ListComparisonRulesets";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfGroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListComparisonRulesets", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfGroupReconciliationComparisonRuleset</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfGroupReconciliationComparisonRuleset> ListComparisonRulesetsAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonRuleset> localVarResponse = await ListComparisonRulesetsWithHttpInfoAsync(asAt, page, sortBy, limit, filter, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListComparisonRulesets: Get a set of Group Reconciliation Comparison Rulesets Retrieves all Group Reconciliation Comparison Ruleset that fit the filter, in a specific order if sortBy is provided  Supports pagination
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="asAt">The asAt datetime at which to retrieve the comparison rulesets. Defaults to return the latest              version of the comparison rulesets if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing comparison rulesets from a previous call to list              comparison rulesets. This value is returned from the previous call. If a pagination token is provided the sortBy,              filter, effectiveAt, and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many per page. (optional)</param>
        /// <param name="filter">Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfGroupReconciliationComparisonRuleset)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationComparisonRuleset>> ListComparisonRulesetsWithHttpInfoAsync(DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), List<string>? sortBy = default(List<string>?), int? limit = default(int?), string? filter = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.ListComparisonRulesets";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfGroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListComparisonRulesets", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>PagedResourceListOfGroupReconciliationDefinition</returns>
        public PagedResourceListOfGroupReconciliationDefinition ListGroupReconciliationDefinitions(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationDefinition> localVarResponse = ListGroupReconciliationDefinitionsWithHttpInfo(effectiveAt, asAt, page, limit, filter, sortBy, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of PagedResourceListOfGroupReconciliationDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationDefinition> ListGroupReconciliationDefinitionsWithHttpInfo(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.ListGroupReconciliationDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PagedResourceListOfGroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGroupReconciliationDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of PagedResourceListOfGroupReconciliationDefinition</returns>
        public async System.Threading.Tasks.Task<PagedResourceListOfGroupReconciliationDefinition> ListGroupReconciliationDefinitionsAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationDefinition> localVarResponse = await ListGroupReconciliationDefinitionsWithHttpInfoAsync(effectiveAt, asAt, page, limit, filter, sortBy, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] ListGroupReconciliationDefinitions: List group reconciliation definitions Lists Group Reconciliation Definitions matching any provided filter, limit and sorting rules
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="effectiveAt">The effective datetime or cut label at which to list the group reconciliation definitions. Defaults to the current LUSID system datetime if not specified. (optional)</param>
        /// <param name="asAt">The asAt datetime at which to list the group reconciliation definitions. Defaults to return the latest version of each group reconciliation definition if not specified. (optional)</param>
        /// <param name="page">The pagination token to use to continue listing group reconciliation definitions from a previous call to list group reconciliation definitions. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request. (optional)</param>
        /// <param name="limit">When paginating, limit the number of returned results to this many. Defaults to no limit if not specified. (optional)</param>
        /// <param name="filter">Expression to filter the result set.              For example, to filter on the Display Name, use \&quot;displayName eq &#39;string&#39;\&quot;              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid. (optional)</param>
        /// <param name="sortBy">A list of field names to sort by, each suffixed by \&quot; ASC\&quot; or \&quot; DESC\&quot; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (PagedResourceListOfGroupReconciliationDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<PagedResourceListOfGroupReconciliationDefinition>> ListGroupReconciliationDefinitionsWithHttpInfoAsync(DateTimeOrCutLabel? effectiveAt = default(DateTimeOrCutLabel?), DateTimeOffset? asAt = default(DateTimeOffset?), string? page = default(string?), int? limit = default(int?), string? filter = default(string?), List<string>? sortBy = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (effectiveAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "effectiveAt", effectiveAt));
            }
            if (asAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "asAt", asAt));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (filter != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("", "filter", filter));
            }
            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Lusid.Sdk.Client.ClientUtils.ParameterToMultiMap("multi", "sortBy", sortBy));
            }

            localVarRequestOptions.Operation = "GroupReconciliationsApi.ListGroupReconciliationDefinitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PagedResourceListOfGroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGroupReconciliationDefinitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationRunResponse</returns>
        public GroupReconciliationRunResponse RunReconciliation(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationRunResponse> localVarResponse = RunReconciliationWithHttpInfo(scope, code, groupReconciliationRunRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationRunResponse</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationRunResponse> RunReconciliationWithHttpInfo(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->RunReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->RunReconciliation");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = groupReconciliationRunRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.RunReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<GroupReconciliationRunResponse>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}/$run", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RunReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationRunResponse</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationRunResponse> RunReconciliationAsync(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationRunResponse> localVarResponse = await RunReconciliationWithHttpInfoAsync(scope, code, groupReconciliationRunRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] RunReconciliation: Runs a Group Reconciliation Runs a Group Reconciliation using the definition specified by the Finbourne.Identifiers.Abstractions.Scope and Finbourne.Identifiers.Abstractions.Code  Supports pagination.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="code">The code of the group reconciliation definition to use for the reconciliation.</param>
        /// <param name="groupReconciliationRunRequest"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationRunResponse)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationRunResponse>> RunReconciliationWithHttpInfoAsync(string scope, string code, GroupReconciliationRunRequest? groupReconciliationRunRequest = default(GroupReconciliationRunRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->RunReconciliation");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->RunReconciliation");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = groupReconciliationRunRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.RunReconciliation";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<GroupReconciliationRunResponse>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}/$run", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RunReconciliation", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationComparisonRuleset</returns>
        public GroupReconciliationComparisonRuleset UpdateComparisonRuleset(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> localVarResponse = UpdateComparisonRulesetWithHttpInfo(scope, code, updateGroupReconciliationComparisonRulesetRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationComparisonRuleset</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> UpdateComparisonRulesetWithHttpInfo(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->UpdateComparisonRuleset");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->UpdateComparisonRuleset");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateGroupReconciliationComparisonRulesetRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.UpdateComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<GroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationComparisonRuleset</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationComparisonRuleset> UpdateComparisonRulesetAsync(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset> localVarResponse = await UpdateComparisonRulesetWithHttpInfoAsync(scope, code, updateGroupReconciliationComparisonRulesetRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateComparisonRuleset: Update Group Reconciliation Comparison Ruleset defined by scope and code Overwrites an existing Group Reconciliation Comparison Ruleset  Update request has the same required fields as Create apart from the Id
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the specified comparison ruleset.</param>
        /// <param name="code">The code of the specified comparison ruleset. Together with the domain and scope this uniquely                  identifies the reconciliation comparison ruleset.</param>
        /// <param name="updateGroupReconciliationComparisonRulesetRequest">The request containing the updated details of the ruleset (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationComparisonRuleset)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationComparisonRuleset>> UpdateComparisonRulesetWithHttpInfoAsync(string scope, string code, UpdateGroupReconciliationComparisonRulesetRequest? updateGroupReconciliationComparisonRulesetRequest = default(UpdateGroupReconciliationComparisonRulesetRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->UpdateComparisonRuleset");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->UpdateComparisonRuleset");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateGroupReconciliationComparisonRulesetRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.UpdateComparisonRuleset";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<GroupReconciliationComparisonRuleset>("/api/reconciliations/comparisonrulesets/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateComparisonRuleset", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition Update the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>GroupReconciliationDefinition</returns>
        public GroupReconciliationDefinition UpdateGroupReconciliationDefinition(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> localVarResponse = UpdateGroupReconciliationDefinitionWithHttpInfo(scope, code, updateGroupReconciliationDefinitionRequest, opts: opts);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition Update the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>ApiResponse of GroupReconciliationDefinition</returns>
        public Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> UpdateGroupReconciliationDefinitionWithHttpInfo(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->UpdateGroupReconciliationDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->UpdateGroupReconciliationDefinition");
            }

            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json",
                "application/json",
                "text/json",
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateGroupReconciliationDefinitionRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.UpdateGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<GroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition Update the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of GroupReconciliationDefinition</returns>
        public async System.Threading.Tasks.Task<GroupReconciliationDefinition> UpdateGroupReconciliationDefinitionAsync(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition> localVarResponse = await UpdateGroupReconciliationDefinitionWithHttpInfoAsync(scope, code, updateGroupReconciliationDefinitionRequest, operationIndex, cancellationToken, opts).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// [EXPERIMENTAL] UpdateGroupReconciliationDefinition: Update group reconciliation definition Update the group reconciliation definition.
        /// </summary>
        /// <exception cref="Lusid.Sdk.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="scope">The scope of the group reconciliation definition to update the details for.</param>
        /// <param name="code">The code of the group reconciliation definition to update the details for. Together with the scope this uniquely identifies the group reconciliation definition.</param>
        /// <param name="updateGroupReconciliationDefinitionRequest">The updated group reconciliation definition. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <param name="opts">Options for this request.</param>
        /// <returns>Task of ApiResponse (GroupReconciliationDefinition)</returns>
        public async System.Threading.Tasks.Task<Lusid.Sdk.Client.ApiResponse<GroupReconciliationDefinition>> UpdateGroupReconciliationDefinitionWithHttpInfoAsync(string scope, string code, UpdateGroupReconciliationDefinitionRequest? updateGroupReconciliationDefinitionRequest = default(UpdateGroupReconciliationDefinitionRequest?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken), ConfigurationOptions? opts = null)
        {
            // verify the required parameter 'scope' is set
            if (scope == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'scope' when calling GroupReconciliationsApi->UpdateGroupReconciliationDefinition");
            }

            // verify the required parameter 'code' is set
            if (code == null)
            {
                throw new Lusid.Sdk.Client.ApiException(400, "Missing required parameter 'code' when calling GroupReconciliationsApi->UpdateGroupReconciliationDefinition");
            }


            Lusid.Sdk.Client.RequestOptions localVarRequestOptions = new Lusid.Sdk.Client.RequestOptions();

            if (opts is { TimeoutMs: not null })
            {
                localVarRequestOptions.TimeoutMs = opts.TimeoutMs.Value;
            }
            
            if (opts is { RateLimitRetries: not null })
            {
                localVarRequestOptions.RateLimitRetries = opts.RateLimitRetries.Value;
            }

            string[] _contentTypes = new string[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/*+json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain",
                "application/json",
                "text/json"
            };

            var localVarContentType = Lusid.Sdk.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Lusid.Sdk.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("scope", Lusid.Sdk.Client.ClientUtils.ParameterToString(scope)); // path parameter
            localVarRequestOptions.PathParameters.Add("code", Lusid.Sdk.Client.ClientUtils.ParameterToString(code)); // path parameter
            localVarRequestOptions.Data = updateGroupReconciliationDefinitionRequest;

            localVarRequestOptions.Operation = "GroupReconciliationsApi.UpdateGroupReconciliationDefinition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (oauth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<GroupReconciliationDefinition>("/api/reconciliations/groupreconciliationdefinitions/{scope}/{code}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGroupReconciliationDefinition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}